{
    "metadata": {
        "abstractText": {
            "page": 0,
            "region": {
                "x1": 53.79798889160156,
                "x2": 300.5446472167969,
                "y1": 155.59207153320312,
                "y2": 176.1409912109375
            },
            "text": "ABSTRACT Detecting fraudulent activities in financial and e-commerce transac-"
        },
        "figures": [
            {
                "caption": "Figure 1: Activity analysis from our industry partner. Data normalized for privacy.",
                "captionBoundary": {
                    "x1": 312.9739990234375,
                    "x2": 558.1984252929688,
                    "y1": 238.7340850830078,
                    "y2": 255.322998046875
                },
                "figType": "Figure",
                "imageText": [
                    "(b)",
                    "System",
                    "Load",
                    "Distribution.",
                    "Device",
                    "Activities",
                    "Count",
                    "Capability",
                    "of",
                    "Spade",
                    "System",
                    "Heavy",
                    "Time",
                    "10",
                    "5",
                    ")",
                    "Device",
                    "Activities",
                    "Count",
                    "Per",
                    "Minute",
                    "nt",
                    "(\u00d7",
                    "C",
                    "ou",
                    "iti",
                    "es",
                    "ct",
                    "iv",
                    "ce",
                    "A",
                    "De",
                    "vi",
                    "3",
                    "2",
                    "1",
                    "00:00",
                    "03:00",
                    "06:00",
                    "09:00",
                    "12:00",
                    "15:00",
                    "18:00",
                    "21:00",
                    "00:00",
                    "Time",
                    "(HH:MM)",
                    "(a)",
                    "Error",
                    "Accumulation",
                    "Trends.",
                    "Correct",
                    "Density",
                    "Spade",
                    "Density",
                    "Error",
                    "da",
                    "r)",
                    "Density",
                    "Comparison",
                    "Over",
                    "Time",
                    "(Error",
                    "in",
                    "one",
                    "day)",
                    "Fr",
                    "au",
                    "(b",
                    "y",
                    "ns",
                    "ity",
                    "h",
                    "De",
                    "Gr",
                    "ap",
                    "0.7",
                    "0.6",
                    "0.5",
                    "00:00",
                    "03:00",
                    "06:00",
                    "09:00",
                    "12:00",
                    "15:00",
                    "18:00",
                    "21:00",
                    "00:00",
                    "Time",
                    "(HH:MM)"
                ],
                "name": "1",
                "page": 0,
                "regionBoundary": {
                    "x1": 315.0534973144531,
                    "x2": 555.0,
                    "y1": 152.9656524658203,
                    "y2": 230.71600341796875
                }
            },
            {
                "caption": "Figure 4: Example of parallel peeling algorithms",
                "captionBoundary": {
                    "x1": 78.28900146484375,
                    "x2": 274.53656005859375,
                    "y1": 654.0441284179688,
                    "y2": 659.675048828125
                },
                "figType": "Figure",
                "imageText": [
                    "u1",
                    "2",
                    "2",
                    "u2",
                    "u5",
                    "u6",
                    "2",
                    "3",
                    "4",
                    "u4",
                    "u1",
                    "u3",
                    "2",
                    "2",
                    "u2",
                    "u5",
                    "u6",
                    "2",
                    "3",
                    "4",
                    "u4",
                    "u3",
                    "Density:",
                    "2.33",
                    "Density:",
                    "2.75",
                    "Density:",
                    "2",
                    "u1",
                    "1",
                    "2",
                    "2",
                    "u2",
                    "u5",
                    "Intialization:",
                    "G",
                    "u6",
                    "Peeling",
                    "Sequence:",
                    "Seq",
                    "=",
                    "[u1,",
                    "u2;u3,",
                    "u4;u5,",
                    "u6]",
                    "Iteration",
                    "1:",
                    "peel",
                    "u1",
                    "and",
                    "u2",
                    "Iteration",
                    "2:",
                    "peel",
                    "u3",
                    "and",
                    "u4",
                    "2",
                    "3",
                    "4",
                    "u4",
                    "u3",
                    "Example",
                    "4.1",
                    "(Parallel",
                    "Peeling",
                    "Algorithm).",
                    "Consider",
                    "the",
                    "graph",
                    "\ud835\udc3a",
                    "as",
                    "illustrated",
                    "in",
                    "Figure",
                    "4.",
                    "The",
                    "parallel",
                    "peeling",
                    "algorithm",
                    "significantly",
                    "reduces",
                    "the",
                    "number",
                    "of",
                    "iterations",
                    "needed",
                    "to",
                    "peel",
                    "the",
                    "graph.",
                    "In",
                    "the",
                    "first",
                    "iteration,",
                    "vertices",
                    "\ud835\udc621",
                    "and",
                    "\ud835\udc622",
                    "are",
                    "peeled",
                    "simulta-",
                    "neously",
                    "since",
                    "they",
                    "both",
                    "satisfy",
                    "the",
                    "peeling",
                    "criteria.",
                    "This",
                    "results",
                    "in",
                    "an",
                    "updated",
                    "graph",
                    "density",
                    "of",
                    "2.75.",
                    "The",
                    "second",
                    "iteration",
                    "sees",
                    "the",
                    "simultaneous",
                    "peeling",
                    "of",
                    "\ud835\udc623",
                    "and",
                    "\ud835\udc624,",
                    "leaving",
                    "the",
                    "remaining",
                    "ver-",
                    "tices",
                    "\ud835\udc625",
                    "and",
                    "\ud835\udc626",
                    "disconnected",
                    "and",
                    "thus",
                    "effectively",
                    "peeled",
                    "from",
                    "the",
                    "graph",
                    "as",
                    "well.",
                    "The",
                    "parallel",
                    "algorithm",
                    "completes",
                    "the",
                    "peeling",
                    "pro-",
                    "cess",
                    "in",
                    "only",
                    "two",
                    "iterations,",
                    "a",
                    "notable",
                    "improvement",
                    "over",
                    "sequential",
                    "methods.",
                    "Consequently,",
                    "the",
                    "peeling",
                    "sequence",
                    "is",
                    "succinctly",
                    "repre-",
                    "sented",
                    "as",
                    "\ud835\udc42",
                    "=",
                    "[\ud835\udc621,",
                    "\ud835\udc622;\ud835\udc623,",
                    "\ud835\udc624;\ud835\udc625,",
                    "\ud835\udc626],",
                    "where",
                    "semicolons",
                    "denote",
                    "the",
                    "parallel",
                    "groups",
                    "peeled",
                    "in",
                    "each",
                    "iteration."
                ],
                "name": "4",
                "page": 5,
                "regionBoundary": {
                    "x1": 53.0,
                    "x2": 300.0,
                    "y1": 360.0,
                    "y2": 646.2644653320312
                }
            },
            {
                "caption": "Figure 5: Illustration of Parallel \ud835\udc58CLiDS Peeling for \ud835\udc58 = 3. Nodes marked in red indicate those to be peeled in the current iteration. The grayed areas represent nodes that have been peeled in previous iterations. Labels adjacent to each node denote the count of \ud835\udc58-Cliques that the node participates in within the current subgraph.",
                "captionBoundary": {
                    "x1": 312.6239929199219,
                    "x2": 559.7345581054688,
                    "y1": 191.1031036376953,
                    "y2": 251.52801513671875
                },
                "figType": "Figure",
                "imageText": [
                    "Example",
                    "4.2.",
                    "In",
                    "Figure",
                    "5,",
                    "we",
                    "demonstrate",
                    "the",
                    "prowess",
                    "ofDupin",
                    "in",
                    "executing",
                    "parallel",
                    "node",
                    "peeling",
                    "for",
                    "TDS",
                    "with",
                    "\ud835\udc58",
                    "=",
                    "3.",
                    "Consider",
                    "the",
                    "\ud835\udc56-th",
                    "iteration",
                    "illustrated",
                    "on",
                    "the",
                    "left:",
                    "the",
                    "five",
                    "vertices",
                    "in",
                    "red",
                    "would",
                    "require",
                    "five",
                    "iterations",
                    "to",
                    "peel",
                    "using",
                    "sequential",
                    "algorithms.",
                    "Prior",
                    "methodologies,",
                    "such",
                    "as",
                    "those",
                    "described",
                    "in",
                    "[41],",
                    "could",
                    "necessitate",
                    "up",
                    "to",
                    "three",
                    "iterations",
                    "for",
                    "complete",
                    "peeling,",
                    "as",
                    "they",
                    "are",
                    "constrained",
                    "to",
                    "peeling",
                    "vertices",
                    "with",
                    "identical",
                    "weights",
                    "concurrently",
                    "and",
                    "the",
                    "recalculations",
                    "of",
                    "peeling",
                    "weights",
                    "are",
                    "time-intensive.Dupin,",
                    "on",
                    "the",
                    "other",
                    "hand,",
                    "facilitates",
                    "the",
                    "simultaneous",
                    "peeling",
                    "of",
                    "these",
                    "vertices",
                    "within",
                    "a",
                    "single",
                    "iteration,",
                    "thus",
                    "leading",
                    "to",
                    "the",
                    "formation",
                    "of",
                    "a",
                    "denser",
                    "subgraph",
                    "in",
                    "the",
                    "subsequent",
                    "iteration.",
                    "This",
                    "optimizes",
                    "the",
                    "process",
                    "to",
                    "just",
                    "three",
                    "iterations",
                    "to",
                    "uncover",
                    "the",
                    "targeted",
                    "dense",
                    "subgraph,",
                    "underscoring",
                    "Dupin\u2019s",
                    "enhanced",
                    "efficiency."
                ],
                "name": "5",
                "page": 5,
                "regionBoundary": {
                    "x1": 312.0,
                    "x2": 559.0,
                    "y1": 257.0,
                    "y2": 407.0
                }
            },
            {
                "caption": "Table 7: Overall effectiveness evaluation for TDS and \ud835\udc58CLiDS.",
                "captionBoundary": {
                    "x1": 53.50199890136719,
                    "x2": 299.026611328125,
                    "y1": 475.3760986328125,
                    "y2": 481.0069885253906
                },
                "figType": "Table",
                "imageText": [
                    "TLE",
                    "TLE",
                    "kCLIST",
                    "-",
                    "-",
                    "1,447,859",
                    "424,908,400",
                    "PBBS",
                    "-",
                    "-",
                    "1,447,859",
                    "TLE",
                    "Dupin",
                    "-",
                    "-",
                    "1,447,788",
                    "426,677,504",
                    "kron",
                    "-",
                    "-",
                    "gfg",
                    "TLE",
                    "TLE",
                    "kCLIST",
                    "3,561,222",
                    "3,280,083,600",
                    "1,043,100",
                    "542,860,800",
                    "PBBS",
                    "TLE",
                    "TLE",
                    "1,187,388",
                    "TLE",
                    "Dupin",
                    "3,769,671",
                    "2,997,257,620",
                    "1,138,083",
                    "544,047,728",
                    "Spade",
                    "bio",
                    "TLE",
                    "TLE",
                    "rv",
                    "TLE",
                    "TLE",
                    "kCLIST",
                    "188,524",
                    "44,272,600",
                    "3,865,986",
                    "3,306,718,000",
                    "PBBS",
                    "304,577",
                    "TLE",
                    "TLE",
                    "TLE",
                    "Dupin",
                    "187,260",
                    "33,823,488",
                    "3,974,028",
                    "3,167,144,896",
                    "Spade",
                    "la",
                    "TLE",
                    "TLE",
                    "uk",
                    "sk",
                    "TLE",
                    "TLE",
                    "kCLIST",
                    "1,525,517",
                    "645,536,400",
                    "TLE",
                    "TLE",
                    "PBBS",
                    "1,994,617",
                    "TLE",
                    "TLE",
                    "TLE",
                    "Dupin",
                    "1,533,939",
                    "606,708,980",
                    "9,995,529",
                    "14,890,921,876",
                    "Spade",
                    "TLE",
                    "TLE",
                    "soc",
                    "Methods",
                    "Dataset",
                    "TDS",
                    "\ud835\udc58CLiDS",
                    "Dataset",
                    "TDS",
                    "\ud835\udc58CLiDS",
                    "Spade"
                ],
                "name": "7",
                "page": 10,
                "regionBoundary": {
                    "x1": 55.0,
                    "x2": 298.0,
                    "y1": 496.0,
                    "y2": 638.0
                }
            },
            {
                "caption": "Table 5: Overall efficiency evaluation conducted using 128 threads for density metrics TDS and \ud835\udc58CLiDS.",
                "captionBoundary": {
                    "x1": 53.50199890136719,
                    "x2": 299.0281677246094,
                    "y1": 85.7260971069336,
                    "y2": 102.31597900390625
                },
                "figType": "Table",
                "imageText": [
                    "TLE",
                    "TLE",
                    "kCLIST",
                    "10",
                    "9",
                    "406",
                    "450",
                    "PBBS",
                    "1.37",
                    "0.79",
                    "330.18",
                    "TLE",
                    "Dupin",
                    "0.74",
                    "0.69",
                    "11.69",
                    "138.63",
                    "kron",
                    "5.66",
                    "5.84",
                    "gfg",
                    "TLE",
                    "TLE",
                    "kCLIST",
                    "5561",
                    "4655",
                    "230.0",
                    "255.0",
                    "PBBS",
                    "TLE",
                    "TLE",
                    "225.06",
                    "TLE",
                    "Dupin",
                    "96.32",
                    "1009.45",
                    "6.25",
                    "82.54",
                    "Spade",
                    "bio",
                    "TLE",
                    "TLE",
                    "rv",
                    "TLE",
                    "TLE",
                    "kCLIST",
                    "494",
                    "447",
                    "10663",
                    "8003",
                    "PBBS",
                    "2900.83",
                    "TLE",
                    "TLE",
                    "TLE",
                    "Dupin",
                    "16.66",
                    "186.31",
                    "145.72",
                    "2241.69",
                    "Spade",
                    "la",
                    "TLE",
                    "TLE",
                    "uk",
                    "sk",
                    "TLE",
                    "TLE",
                    "kCLIST",
                    "1516",
                    "1444",
                    "TLE",
                    "TLE",
                    "PBBS",
                    "3524.11",
                    "TLE",
                    "TLE",
                    "TLE",
                    "Dupin",
                    "32.59",
                    "283.70",
                    "42.73",
                    "2636.17",
                    "Spade",
                    "TLE",
                    "TLE",
                    "soc",
                    "Methods",
                    "Dataset",
                    "TDS",
                    "\ud835\udc58CLiDS",
                    "Dataset",
                    "TDS",
                    "\ud835\udc58CLiDS",
                    "Spade"
                ],
                "name": "5",
                "page": 10,
                "regionBoundary": {
                    "x1": 79.0,
                    "x2": 273.0,
                    "y1": 117.0,
                    "y2": 251.0
                }
            },
            {
                "caption": "Table 6: Overall effectiveness evaluation for DG, DW, and FD.",
                "captionBoundary": {
                    "x1": 53.50199890136719,
                    "x2": 298.9472961425781,
                    "y1": 257.0561218261719,
                    "y2": 262.68701171875
                },
                "figType": "Table",
                "imageText": [
                    "GBBS",
                    "28",
                    "1,432",
                    "5,018",
                    "1,177",
                    "53,539",
                    "14,861",
                    "PKMC",
                    "28",
                    "1,396",
                    "4,782",
                    "1,169",
                    "49,983",
                    "12,829",
                    "FWA",
                    "28",
                    "1,432",
                    "5,108",
                    "1,177",
                    "53,539",
                    "14,861",
                    "ALENEX",
                    "28",
                    "1,432",
                    "5,108",
                    "1,177",
                    "53,539",
                    "14,861",
                    "Dupin",
                    "26",
                    "1,405",
                    "4,879",
                    "1,177",
                    "52,695",
                    "13,912",
                    "1,177",
                    "53,539",
                    "15,381",
                    "kron",
                    "28",
                    "1,432",
                    "5,369",
                    "gfg",
                    "GBBS",
                    "1,643",
                    "74,779",
                    "20,749",
                    "777",
                    "36,446",
                    "12,669",
                    "PKMC",
                    "1,437",
                    "67,328",
                    "16,753",
                    "721",
                    "32,284",
                    "11,283",
                    "FWA",
                    "1,643",
                    "TLE",
                    "TLE",
                    "787",
                    "36,446",
                    "12,669",
                    "ALENEX",
                    "1,643",
                    "74,779",
                    "20,749",
                    "787",
                    "36,446",
                    "12,669",
                    "Dupin",
                    "1,518",
                    "71,058",
                    "18,115",
                    "699",
                    "31,172",
                    "10,404",
                    "Spade",
                    "777",
                    "36,446",
                    "13,039",
                    "bio",
                    "1,643",
                    "74,779",
                    "22,678",
                    "rv",
                    "GBBS",
                    "426",
                    "27,812",
                    "8,987",
                    "1,877",
                    "89,641",
                    "21,774",
                    "PKMC",
                    "375",
                    "24,279",
                    "8,268",
                    "1,512",
                    "83,049",
                    "19,637",
                    "FWA",
                    "486",
                    "TLE",
                    "TLE",
                    "1,877",
                    "TLE",
                    "TLE",
                    "ALENEX",
                    "486",
                    "27,812",
                    "8,987",
                    "1,877",
                    "89,641",
                    "21,774",
                    "Dupin",
                    "309",
                    "24,796",
                    "8,424",
                    "1,843",
                    "87,671",
                    "20,610",
                    "Spade",
                    "1,877",
                    "89,641",
                    "22,198",
                    "la",
                    "426",
                    "27,812",
                    "10,155",
                    "uk",
                    "GBBS",
                    "1,307",
                    "63,372",
                    "16,883",
                    "2,257",
                    "109,097",
                    "28,118",
                    "PKMC",
                    "1,053",
                    "54,373",
                    "15,363",
                    "1,954",
                    "95,241",
                    "25,868",
                    "FWA",
                    "1,307",
                    "63,372",
                    "16,883",
                    "2,257",
                    "109,097",
                    "28,188",
                    "ALENEX",
                    "1,307",
                    "63,372",
                    "16,883",
                    "2,257",
                    "109,097",
                    "28,188",
                    "Dupin",
                    "1,286",
                    "59,379",
                    "16,234",
                    "2,235",
                    "98,669",
                    "27,067",
                    "Spade",
                    "2,257",
                    "109,097",
                    "33,741",
                    "sk",
                    "1,307",
                    "63,372",
                    "16,947",
                    "soc",
                    "Methods",
                    "Dataset",
                    "DG",
                    "DW",
                    "FD",
                    "Dataset",
                    "DG",
                    "DW",
                    "FD",
                    "Spade"
                ],
                "name": "6",
                "page": 10,
                "regionBoundary": {
                    "x1": 67.0,
                    "x2": 286.0,
                    "y1": 278.0,
                    "y2": 469.0
                }
            },
            {
                "caption": "Table 1: Frequently used notations",
                "captionBoundary": {
                    "x1": 365.50201416015625,
                    "x2": 505.3780212402344,
                    "y1": 173.96803283691406,
                    "y2": 179.59893798828125
                },
                "figType": "Table",
                "imageText": [
                    "\ud835\udc46\ud835\udc43",
                    "the",
                    "vertex",
                    "set",
                    "returned",
                    "by\ud835\udc44",
                    "\ud835\udc46\u2217",
                    "the",
                    "optimal",
                    "vertex",
                    "set",
                    "\ud835\udc44",
                    "the",
                    "peeling",
                    "algorithms",
                    "\ud835\udc64\ud835\udc62",
                    "(\ud835\udc46)",
                    "the",
                    "peeling",
                    "weight,",
                    "i.e.,",
                    "the",
                    "decrease",
                    "in",
                    "\ud835\udc53",
                    "by",
                    "peeling",
                    "\ud835\udc62",
                    "from",
                    "\ud835\udc46",
                    "\ud835\udc53",
                    "(\ud835\udc46)",
                    "the",
                    "sum",
                    "of",
                    "the",
                    "suspiciousness",
                    "of",
                    "vertex",
                    "set",
                    "\ud835\udc46",
                    "\ud835\udc54(\ud835\udc46)",
                    "the",
                    "suspiciousness",
                    "density",
                    "of",
                    "vertex",
                    "set",
                    "\ud835\udc46",
                    "\ud835\udc4e\ud835\udc56",
                    "/",
                    "\ud835\udc50\ud835\udc56",
                    "\ud835\udc57",
                    "the",
                    "weight",
                    "on",
                    "vertex",
                    "\ud835\udc62\ud835\udc56",
                    "/",
                    "on",
                    "edge",
                    "(\ud835\udc62\ud835\udc56",
                    ",\ud835\udc62",
                    "\ud835\udc57",
                    ")",
                    "\ud835\udc41",
                    "(\ud835\udc62)",
                    "the",
                    "neighbors",
                    "of",
                    "\ud835\udc62",
                    "Notation",
                    "Definition",
                    "\ud835\udc3a",
                    "/",
                    "\u2206\ud835\udc3a",
                    "a",
                    "transaction",
                    "graph",
                    "/",
                    "updates",
                    "to",
                    "graph\ud835\udc3a"
                ],
                "name": "1",
                "page": 1,
                "regionBoundary": {
                    "x1": 325.0,
                    "x2": 547.0,
                    "y1": 187.0,
                    "y2": 275.0
                }
            },
            {
                "caption": "Table 2: Impact ofGPO and LPO on Peeling Rounds for Various Metrics. Experimented on dataset la with 52,579,682 vertices.",
                "captionBoundary": {
                    "x1": 312.6780090332031,
                    "x2": 558.2041015625,
                    "y1": 437.66510009765625,
                    "y2": 454.2550048828125
                },
                "figType": "Table",
                "imageText": [
                    "%",
                    "Reduction",
                    "in",
                    "Rounds",
                    "81.74%",
                    "92.79%",
                    "9.65%",
                    "Sparse",
                    "vertices",
                    "13,324,405",
                    "15,487,382",
                    "3,762,288",
                    "Rounds",
                    "with",
                    "LPO",
                    "3,221",
                    "10,832",
                    "101,255",
                    "%",
                    "Reduction",
                    "in",
                    "Rounds",
                    "24.67%",
                    "46.84%",
                    "3.01%",
                    "Long-tail",
                    "vertices",
                    "45,017,232",
                    "48,248,685",
                    "5,658,425",
                    "Rounds",
                    "with",
                    "GPO",
                    "13,287",
                    "79,835",
                    "108,706",
                    "Rounds",
                    "without",
                    "GPO",
                    "17,637",
                    "150,223",
                    "112,074",
                    "Method",
                    "DG",
                    "DW",
                    "FD"
                ],
                "name": "2",
                "page": 6,
                "regionBoundary": {
                    "x1": 327.0,
                    "x2": 544.0,
                    "y1": 469.0,
                    "y2": 574.0
                }
            },
            {
                "caption": "Table 4: Overall efficiency evaluation conducted using 128 threads for density metrics DG, DW, and FD. The notation \u2018TLE\u2019 signifies \u201cTime Limit Exceeded,\u201d indicating that the task did not finish within 7,200 seconds. A dash (\u201c-\u201d) denotes that the framework does not support the density metrics.",
                "captionBoundary": {
                    "x1": 312.2919921875,
                    "x2": 558.4769897460938,
                    "y1": 270.7831115722656,
                    "y2": 320.25
                },
                "figType": "Table",
                "imageText": [
                    "GBBS",
                    "0.41",
                    "2.10",
                    "5.74",
                    "1.47",
                    "6.62",
                    "9.58",
                    "PKMC",
                    "15.96",
                    "15.00",
                    "16.25",
                    "34.47",
                    "35.71",
                    "37.23",
                    "FWA",
                    "133",
                    "186",
                    "173",
                    "254",
                    "344",
                    "372",
                    "ALENEX",
                    "4.13",
                    "4.01",
                    "4.75",
                    "85.8",
                    "83.05",
                    "82.98",
                    "Dupin",
                    "0.29",
                    "0.33",
                    "0.35",
                    "0.18",
                    "0.36",
                    "0.23",
                    "5.08",
                    "5.36",
                    "5.61",
                    "kron",
                    "2.30",
                    "2.62",
                    "2.70",
                    "gfg",
                    "GBBS",
                    "32.51",
                    "62.29",
                    "71.67",
                    "2.55",
                    "5.04",
                    "5.21",
                    "PKMC",
                    "659.04",
                    "659.15",
                    "693.83",
                    "11.38",
                    "11.39",
                    "12.97",
                    "FWA",
                    "3569",
                    "TLE",
                    "TLE",
                    "62",
                    "393",
                    "428",
                    "ALENEX",
                    "158.64",
                    "132.88",
                    "158.79",
                    "62.16",
                    "68.22",
                    "63.62",
                    "Dupin",
                    "3.34",
                    "3.76",
                    "3.89",
                    "0.15",
                    "0.20",
                    "0.23",
                    "Spade",
                    "1.99",
                    "2.02",
                    "2.11",
                    "bio",
                    "135.89",
                    "135.05",
                    "132.61",
                    "rv",
                    "GBBS",
                    "7.26",
                    "27.15",
                    "50.29",
                    "50.21",
                    "80.66",
                    "50.29",
                    "PKMC",
                    "167.76",
                    "168.81",
                    "187.61",
                    "946.64",
                    "1048.48",
                    "1024.23",
                    "FWA",
                    "1,794",
                    "TLE",
                    "TLE",
                    "4995",
                    "TLE",
                    "TLE",
                    "ALENEX",
                    "238.36",
                    "209.30",
                    "213.80",
                    "215.98",
                    "154.17",
                    "194.06",
                    "Dupin",
                    "3.38",
                    "3.57",
                    "3.56",
                    "4.55",
                    "4.41",
                    "5.16",
                    "Spade",
                    "175.07",
                    "242.26",
                    "224.47",
                    "la",
                    "67.08",
                    "93.66",
                    "83.20",
                    "uk",
                    "GBBS",
                    "10.01",
                    "23.28",
                    "35.43",
                    "13.95",
                    "35.91",
                    "48.80",
                    "PKMC",
                    "103.16",
                    "105.77",
                    "106.96",
                    "388.85",
                    "393.01",
                    "431.04",
                    "FWA",
                    "704",
                    "1,241",
                    "1,381",
                    "3,092",
                    "4,934",
                    "4,716",
                    "ALENEX",
                    "138.73",
                    "120.19",
                    "128.81",
                    "411.75",
                    "488.49",
                    "473.45",
                    "Dupin",
                    "1.79",
                    "2.26",
                    "2.38",
                    "3.87",
                    "3.93",
                    "4.25",
                    "Spade",
                    "182.28",
                    "215.27",
                    "210.26",
                    "sk",
                    "23.46",
                    "28.10",
                    "30.67",
                    "soc",
                    "Methods",
                    "Dataset",
                    "DG",
                    "DW",
                    "FD",
                    "Dataset",
                    "DG",
                    "DW",
                    "FD",
                    "Spade"
                ],
                "name": "4",
                "page": 9,
                "regionBoundary": {
                    "x1": 314.0,
                    "x2": 557.0,
                    "y1": 335.0,
                    "y2": 539.0
                }
            },
            {
                "caption": "Figure 7: Scalability of GBBS, PBBS, and Dupin by varying the number of the threads.",
                "captionBoundary": {
                    "x1": 135.62100219726562,
                    "x2": 476.3798522949219,
                    "y1": 255.71510314941406,
                    "y2": 261.34600830078125
                },
                "figType": "Figure",
                "imageText": [
                    "(e)",
                    "Varying",
                    "the",
                    "number",
                    "of",
                    "threads",
                    "for",
                    "kCLiDS",
                    "(k=4)",
                    "PBBS",
                    "Dupin",
                    "DupinGPO",
                    "DupinLPO",
                    "2",
                    "4",
                    "8",
                    "16",
                    "32",
                    "64",
                    "128",
                    "10000",
                    "2000",
                    "3000",
                    "4000",
                    "5000",
                    "6000",
                    "7000",
                    "8000",
                    "9000",
                    "(d)",
                    "Varying",
                    "the",
                    "number",
                    "of",
                    "threads",
                    "for",
                    "TDS",
                    ")",
                    "e",
                    "(s",
                    "T",
                    "im",
                    "PBBS",
                    "Dupin",
                    "DupinGPO",
                    "DupinLPO",
                    "2",
                    "4",
                    "8",
                    "16",
                    "32",
                    "64",
                    "128",
                    "10000",
                    "1000",
                    "100",
                    "(c)",
                    "Varying",
                    "the",
                    "number",
                    "of",
                    "threads",
                    "for",
                    "FD",
                    "GBBS",
                    "Dupin",
                    "DupinGPO",
                    "DupinLPO",
                    "2",
                    "4",
                    "8",
                    "16",
                    "32",
                    "64",
                    "128",
                    "300",
                    "250",
                    "200",
                    "150",
                    "100",
                    "50",
                    "0",
                    "(b)",
                    "Varying",
                    "the",
                    "number",
                    "of",
                    "threads",
                    "for",
                    "DW",
                    "GBBS",
                    "Dupin",
                    "DupinGPO",
                    "DupinLPO",
                    "2",
                    "4",
                    "8",
                    "16",
                    "32",
                    "64",
                    "128",
                    "200",
                    "150",
                    "100",
                    "50",
                    "0",
                    "(a)",
                    "Varying",
                    "the",
                    "number",
                    "of",
                    "threads",
                    "for",
                    "DG",
                    ")",
                    "e",
                    "(s",
                    "T",
                    "im",
                    "GBBS",
                    "Dupin",
                    "DupinGPO",
                    "DupinLPO",
                    "2",
                    "4",
                    "8",
                    "16",
                    "32",
                    "64",
                    "128",
                    "200",
                    "150",
                    "100",
                    "50",
                    "0"
                ],
                "name": "7",
                "page": 9,
                "regionBoundary": {
                    "x1": 65.6713638305664,
                    "x2": 519.0,
                    "y1": 91.0,
                    "y2": 237.31878662109375
                }
            },
            {
                "caption": "Figure 6: Demonstrating Long-Tail Pruning. Nodes highlighted in red are targeted for removal in the current iteration, while the nodes shaded in gray indicate those that have been previously peeled. This sequence illustrates the progressive peeling from left to right.",
                "captionBoundary": {
                    "x1": 53.79800033569336,
                    "x2": 300.6290283203125,
                    "y1": 199.91407775878906,
                    "y2": 249.3800048828125
                },
                "figType": "Figure",
                "imageText": [
                    "\u03c4",
                    "=",
                    "0",
                    "2",
                    "=",
                    "2.19",
                    "\u03c4max",
                    "=",
                    "4.28",
                    "Iteration",
                    "i",
                    "Iteration",
                    "i+1",
                    "Iteration",
                    "i+2",
                    "u",
                    "\u03c4",
                    "=",
                    "2\u00d7",
                    "0.83",
                    "=",
                    "1.66",
                    "2",
                    "=",
                    "2.19",
                    "\u03c4max",
                    "=",
                    "4.28",
                    "\u03c4",
                    "=",
                    "2\u00d7",
                    "4.28",
                    "=",
                    "8.56",
                    "2",
                    "=",
                    "2.19",
                    "\u03c4max",
                    "=",
                    "4.28",
                    "Density:",
                    "0",
                    "4",
                    "4",
                    "4",
                    "4",
                    "4",
                    "4",
                    "0.5",
                    "1",
                    "1",
                    "2",
                    "2",
                    "2",
                    "2",
                    "2",
                    "2",
                    "Density:",
                    "0.83",
                    "4",
                    "4",
                    "4",
                    "4",
                    "4",
                    "4",
                    "0.5",
                    "1",
                    "1",
                    "2",
                    "2",
                    "2",
                    "2",
                    "2",
                    "2",
                    "Density:",
                    "4.28",
                    "4",
                    "4",
                    "4",
                    "4",
                    "4",
                    "4",
                    "0.5",
                    "1",
                    "1",
                    "2",
                    "2",
                    "2",
                    "2",
                    "2",
                    "2"
                ],
                "name": "6",
                "page": 7,
                "regionBoundary": {
                    "x1": 66.05997467041016,
                    "x2": 286.7457275390625,
                    "y1": 87.05442810058594,
                    "y2": 185.0771484375
                }
            },
            {
                "caption": "Figure 2: Example of sequential peeling algorithms",
                "captionBoundary": {
                    "x1": 202.38499450683594,
                    "x2": 409.6165771484375,
                    "y1": 173.2801055908203,
                    "y2": 178.9110107421875
                },
                "figType": "Figure",
                "imageText": [
                    "Density:",
                    "0",
                    "u1",
                    "u3",
                    "u6",
                    "2",
                    "2",
                    "u2",
                    "u5",
                    "2",
                    "3",
                    "4",
                    "u4",
                    "u1",
                    "2",
                    "2",
                    "u2",
                    "u5",
                    "u6",
                    "2",
                    "3",
                    "4",
                    "u4",
                    "u1",
                    "u3",
                    "2",
                    "2",
                    "u2",
                    "u5",
                    "u6",
                    "2",
                    "3",
                    "4",
                    "u4",
                    "u1",
                    "u3",
                    "2",
                    "2",
                    "u2",
                    "u5",
                    "u6",
                    "2",
                    "3",
                    "4",
                    "u4",
                    "u1",
                    "u3",
                    "1",
                    "2",
                    "2",
                    "u2",
                    "u5",
                    "u6",
                    "2",
                    "3",
                    "4",
                    "u4",
                    "u3",
                    "Density:",
                    "2.33",
                    "Density:",
                    "2.6",
                    "Density:",
                    "2.75",
                    "Density:",
                    "2.33",
                    "Density:",
                    "2",
                    "Iteration",
                    "1:",
                    "peel",
                    "u1",
                    "u1",
                    "1",
                    "Iteration",
                    "5:",
                    "peel",
                    "u5",
                    "2",
                    "2",
                    "u2",
                    "u5",
                    "Intialization:",
                    "G",
                    "u6",
                    "Peeling",
                    "Sequence:",
                    "Seq",
                    "=",
                    "[u1,",
                    "u2,",
                    "u3,",
                    "u4,",
                    "u5,",
                    "u6]",
                    "Iteration",
                    "2:",
                    "peel",
                    "u2",
                    "Iteration",
                    "3:",
                    "peel",
                    "u3",
                    "Iteration",
                    "4:",
                    "peel",
                    "u4",
                    "2",
                    "3",
                    "4",
                    "u4",
                    "u3"
                ],
                "name": "2",
                "page": 3,
                "regionBoundary": {
                    "x1": 53.79800033569336,
                    "x2": 557.9091796875,
                    "y1": 85.1849365234375,
                    "y2": 165.33355712890625
                }
            },
            {
                "caption": "Table 8: Latency vs. Prevention Ratio by Method: A method\u2019s performance in latency (L: seconds) against its prevention ratio (R), detailing the effectiveness of various computational strategies in real-time environments.",
                "captionBoundary": {
                    "x1": 312.6780090332031,
                    "x2": 558.2061767578125,
                    "y1": 340.0531005859375,
                    "y2": 378.5610046386719
                },
                "figType": "Table",
                "imageText": [
                    "Dupin",
                    "3.10",
                    "78%",
                    "3.54",
                    "86%",
                    "3.59",
                    "94.5%",
                    "2145.00",
                    "32%",
                    "Spade",
                    "165.20",
                    "58%",
                    "235.63",
                    "63%",
                    "197.61",
                    "45%",
                    "TLE",
                    "TLE",
                    "GBBS",
                    "927.88",
                    "12%",
                    "TLE",
                    "TLE",
                    "6014.00",
                    "3%",
                    "-",
                    "-",
                    "DG",
                    "DW",
                    "FD",
                    "TDS",
                    "L",
                    "R",
                    "L",
                    "R",
                    "L",
                    "R",
                    "L",
                    "R"
                ],
                "name": "8",
                "page": 11,
                "regionBoundary": {
                    "x1": 314.0,
                    "x2": 557.0,
                    "y1": 287.0,
                    "y2": 337.0
                }
            },
            {
                "caption": "Figure 8: Effectiveness of Dupin by varying \ud835\udf16",
                "captionBoundary": {
                    "x1": 216.76499938964844,
                    "x2": 394.5948486328125,
                    "y1": 244.83106994628906,
                    "y2": 250.46197509765625
                },
                "figType": "Figure",
                "imageText": [
                    "(e)",
                    "Varying",
                    "\u03b5",
                    "for",
                    "kCLiDS",
                    "(k=4)",
                    "0",
                    "9",
                    ")",
                    "x",
                    "1",
                    "ty",
                    "(",
                    "Dupin",
                    "DupinGPO",
                    "DupinLPOD",
                    "en",
                    "si",
                    "0.1",
                    "0.2",
                    "0.3",
                    "0.4",
                    "0.5",
                    "0.6",
                    "0.7",
                    "0.8",
                    "0.9",
                    "4",
                    "3.5",
                    "3",
                    "2.5",
                    "2",
                    "(d)",
                    "Varying",
                    "\u03b5",
                    "for",
                    "TDS",
                    "6",
                    ")",
                    "1",
                    "0",
                    "(x",
                    "si",
                    "ty",
                    "D",
                    "en",
                    "Dupin",
                    "DupinGPO",
                    "DupinLPO",
                    "0.1",
                    "0.2",
                    "0.3",
                    "0.4",
                    "0.5",
                    "0.6",
                    "0.7",
                    "0.8",
                    "0.9",
                    "5",
                    "4.5",
                    "4",
                    "3.5",
                    "3",
                    "(c)",
                    "Varying",
                    "\u03b5",
                    "for",
                    "FD",
                    "4",
                    ")",
                    "1",
                    "0",
                    "ty",
                    "(x",
                    "Dupin",
                    "DupinGPO",
                    "DupinLPOD",
                    "en",
                    "si",
                    "0.1",
                    "0.2",
                    "0.3",
                    "0.4",
                    "0.5",
                    "0.6",
                    "0.7",
                    "0.8",
                    "0.9",
                    "2.2",
                    "2.1",
                    "2",
                    "1.9",
                    "1.8",
                    "1.7",
                    "(b)",
                    "Varying",
                    "\u03b5",
                    "for",
                    "DW",
                    "4",
                    ")",
                    "1",
                    "0",
                    "ty",
                    "(x",
                    "Dupin",
                    "DupinGPO",
                    "DupinLPOD",
                    "en",
                    "si",
                    "0.1",
                    "0.2",
                    "0.3",
                    "0.4",
                    "0.5",
                    "0.6",
                    "0.7",
                    "0.8",
                    "0.9",
                    "9",
                    "8.5",
                    "8",
                    "7.5",
                    "7",
                    "(a)",
                    "Varying",
                    "\u03b5",
                    "for",
                    "DG",
                    "3",
                    ")",
                    "1",
                    "0",
                    "ty",
                    "(x",
                    "Dupin",
                    "DupinGPO",
                    "DupinLPOD",
                    "en",
                    "si",
                    "0.1",
                    "0.2",
                    "0.3",
                    "0.4",
                    "0.5",
                    "0.6",
                    "0.7",
                    "0.8",
                    "0.9",
                    "1.85",
                    "1.9",
                    "1.75",
                    "1.8",
                    "1.65",
                    "1.7",
                    "1.5",
                    "1.55",
                    "1.6"
                ],
                "name": "8",
                "page": 11,
                "regionBoundary": {
                    "x1": 58.403053283691406,
                    "x2": 519.0,
                    "y1": 88.6611099243164,
                    "y2": 235.40081787109375
                }
            },
            {
                "caption": "Figure 9: Weekly Graph Density Comparison in Anon\u2014 Shows Correct Density (green), Spade Density (orange dashed), and Dupin Density (blue dotted) over one week. Gray and navy shaded areas indicate error margins for Spade and Dupin, highlighting their deviations from the ideal density.",
                "captionBoundary": {
                    "x1": 53.79800033569336,
                    "x2": 300.62847900390625,
                    "y1": 357.49310302734375,
                    "y2": 406.9599914550781
                },
                "figType": "Figure",
                "imageText": [
                    "da",
                    "r)",
                    "Density",
                    "Comparison",
                    "Over",
                    "Time",
                    "(Error",
                    "in",
                    "one",
                    "week)",
                    "Correct",
                    "Density",
                    "Spade",
                    "Density",
                    "Dupin",
                    "Density",
                    "Spade",
                    "Error",
                    "Dupin",
                    "Error",
                    "Fr",
                    "au",
                    "(b",
                    "y",
                    "ns",
                    "ity",
                    "h",
                    "De",
                    "Gr",
                    "ap",
                    "1.4",
                    "1.2",
                    "1.0",
                    "0.8",
                    "0.6",
                    "0.4",
                    "Time",
                    "00",
                    ":00",
                    "12",
                    ":00",
                    "00",
                    ":00",
                    "12",
                    ":00",
                    "00",
                    ":00",
                    "12",
                    ":00",
                    "00",
                    ":00",
                    "12",
                    ":00",
                    "00",
                    ":00",
                    "12",
                    ":00",
                    "00",
                    ":00",
                    "12",
                    ":00",
                    "00",
                    ":00",
                    "12",
                    ":00"
                ],
                "name": "9",
                "page": 11,
                "regionBoundary": {
                    "x1": 68.84568786621094,
                    "x2": 286.0,
                    "y1": 256.7752990722656,
                    "y2": 341.232421875
                }
            },
            {
                "caption": "Table 3: Statistics of real-world datasets",
                "captionBoundary": {
                    "x1": 96.33399963378906,
                    "x2": 256.19598388671875,
                    "y1": 615.340087890625,
                    "y2": 620.9710083007812
                },
                "figType": "Table",
                "imageText": [
                    "biomine",
                    "bio",
                    "1,508,587",
                    "32,761,889",
                    "22",
                    "Biologic",
                    "graph",
                    "soc-twitter",
                    "soc",
                    "28,504,110",
                    "531,000,244",
                    "18",
                    "Social",
                    "network",
                    "Web-uk-2005",
                    "uk",
                    "39,454,748",
                    "936,364,284",
                    "24",
                    "Web",
                    "graph",
                    "Twitter-rv",
                    "rv",
                    "41,652,230",
                    "1,468,365,182",
                    "35",
                    "Social",
                    "network",
                    "kron-logn21",
                    "kron",
                    "1,544,088",
                    "91,042,012",
                    "58",
                    "Cheminformatics",
                    "Web-sk-2005",
                    "sk",
                    "50,636,151",
                    "1,949,412,601",
                    "38",
                    "Web",
                    "graph",
                    "links-anon",
                    "la",
                    "52,579,682",
                    "1,963,263,821",
                    "37",
                    "Social",
                    "network",
                    "Datasets",
                    "Name",
                    "|V",
                    "|",
                    "|E",
                    "|",
                    "avg.",
                    "degree",
                    "Type",
                    "GFG",
                    "gfg",
                    "3,646,185",
                    "28,635,763",
                    "17",
                    "Transaction"
                ],
                "name": "3",
                "page": 8,
                "regionBoundary": {
                    "x1": 63.0,
                    "x2": 290.0,
                    "y1": 629.0,
                    "y2": 708.0
                }
            },
            {
                "caption": "Figure 3: Architecture of Dupin",
                "captionBoundary": {
                    "x1": 114.05999755859375,
                    "x2": 238.76467895507812,
                    "y1": 204.9210968017578,
                    "y2": 210.552001953125
                },
                "figType": "Figure",
                "imageText": [
                    "isBenign",
                    "setEpsilon",
                    "setK",
                    "Parallel",
                    "Peeling",
                    "VSusp",
                    "ESusp",
                    "fraud",
                    "semanticsanalyse/ban",
                    "Long-Tail",
                    "Pruning:",
                    "GPO",
                    "and",
                    "LPO",
                    "Sequential",
                    "Peeling",
                    "Fraudulent",
                    "Community",
                    "Auto.",
                    "Parallelization",
                    "Graph",
                    "Loading",
                    "moderators",
                    "developer",
                    "Dupin",
                    "Engine",
                    "pWeight",
                    "updateNgh",
                    "Dupin",
                    "API",
                    "Storage",
                    "System",
                    "(DFS)"
                ],
                "name": "3",
                "page": 4,
                "regionBoundary": {
                    "x1": 79.0,
                    "x2": 275.0,
                    "y1": 85.20561981201172,
                    "y2": 191.0
                }
            }
        ],
        "sections": [
            {
                "paragraphs": [
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02886962890625,
                            "y1": 185.05563354492188,
                            "y2": 198.05902099609375
                        },
                        "text": "tion networks is crucial, and one effective method for this is Densest Subgraph Discovery (DSD). However, deploying DSD methods in"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0276184082031,
                            "y1": 206.97366333007812,
                            "y2": 209.01800537109375
                        },
                        "text": "production systems faces substantial scalability challenges due to the"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02764892578125,
                            "y1": 217.93264770507812,
                            "y2": 219.97698974609375
                        },
                        "text": "predominantly sequential nature of existing methods, which impedes"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.0120544433594,
                            "y1": 228.89163208007812,
                            "y2": 263.81201171875
                        },
                        "text": "their ability to handle large-scale transaction networks and results in significant detection delays. In this paper, we introduce Dupin, a novel parallel processing framework designed for efficient DSD processing in billion-scale graphs. Dupin is powered by a processing"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.57400131225586,
                            "x2": 300.542724609375,
                            "y1": 272.7266540527344,
                            "y2": 296.6889953613281
                        },
                        "text": "engine that exploits the unique properties of the peeling process, with theoretical guarantees on detection quality and efficiency.Dupin provides user-friendly APIs for flexible customization of DSD objectives"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5404357910156,
                            "y1": 305.6036682128906,
                            "y2": 329.5660095214844
                        },
                        "text": "and ensures robust adaptability to diverse fraud detection scenarios. Empirical evaluations indicate that Dupin outperforms several existing DSD methods, with performance improvements observed"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0261535644531,
                            "y1": 338.48065185546875,
                            "y2": 351.4840087890625
                        },
                        "text": "in specific scenarios reaching up to two orders of magnitude. On billion-scale graphs, Dupin demonstrates the potential to enhance"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0276184082031,
                            "y1": 360.3986511230469,
                            "y2": 362.4429931640625
                        },
                        "text": "the prevention of fraudulent transactions by approximately 49.5 basis"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0270690917969,
                            "y1": 371.3566589355469,
                            "y2": 373.4010009765625
                        },
                        "text": "points and reduce density error from 30% to below 5%, as supported"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 156.45431518554688,
                            "y1": 382.3156433105469,
                            "y2": 384.3599853515625
                        },
                        "text": "by our experimental results."
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.50300216674805,
                            "x2": 299.82147216796875,
                            "y1": 394.3677673339844,
                            "y2": 429.260986328125
                        },
                        "text": "ACM Reference Format: Anonymous Author(s). 2024. Dupin: A Parallel Densest Subgraph Discovery Framework on Massive Graphs. In Proceedings of ACM Conference (Conference\u201917). ACM, New York, NY, USA, 14 pages. https://doi.org/10.1145/"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 116.0285415649414,
                            "y1": 437.40582275390625,
                            "y2": 439.2229919433594
                        },
                        "text": "nnnnnnn.nnnnnnn"
                    }
                ]
            },
            {
                "paragraphs": [
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.0101013183594,
                            "y1": 473.92864990234375,
                            "y2": 475.9729919433594
                        },
                        "text": "Graph structures pervade numerous contemporary applications,"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.54052734375,
                            "y1": 484.8876647949219,
                            "y2": 486.9320068359375
                        },
                        "text": "ranging from transaction and communication networks to expan-"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5381774902344,
                            "y1": 495.8466491699219,
                            "y2": 508.8500061035156
                        },
                        "text": "sive social media platforms. The study of densest subgraph discovery (DSD), first explored by [21], has since proven instrumental in"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.57400131225586,
                            "x2": 300.5412292480469,
                            "y1": 517.7646484375,
                            "y2": 519.8089599609375
                        },
                        "text": "various domains: link spam identification [4, 19], community de-"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02252197265625,
                            "y1": 528.7236938476562,
                            "y2": 530.7680053710938
                        },
                        "text": "tection [9, 17], and notably, fraud detection [8, 24, 42]. Central to"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.2574462890625,
                            "y1": 539.6826782226562,
                            "y2": 541.7269897460938
                        },
                        "text": "this domain is the peeling process [2, 5, 8, 24, 46], which operates by"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.238525390625,
                            "y1": 550.6417236328125,
                            "y2": 552.68603515625
                        },
                        "text": "iteratively removing vertices based on density metrics, such as vertex"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02764892578125,
                            "y1": 561.6007080078125,
                            "y2": 563.64501953125
                        },
                        "text": "degree or the cumulative weight of adjacent edges. Their widespread"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.53955078125,
                            "y1": 572.5596923828125,
                            "y2": 596.52099609375
                        },
                        "text": "adoption can be attributed to their inherent efficiency, robustness, and proven worst-case performance guarantees for DSD. In practice, business requirements demand the detection of fraud-"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02227783203125,
                            "y1": 605.4356689453125,
                            "y2": 607.47998046875
                        },
                        "text": "ulent communities on billion-scale graphs within seconds. Recent"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 53.31700134277344,
                            "x2": 299.79644775390625,
                            "y1": 624.4619750976562,
                            "y2": 707.3469848632812
                        },
                        "text": "Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. Conference\u201917, July 2017, Washington, DC, USA \u00a9 2024 Association for Computing Machinery. ACM ISBN 978-x-xxxx-xxxx-x/YY/MM. . . $15.00 https://doi.org/10.1145/nnnnnnn.nnnnnnn"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7182006835938,
                            "y1": 276.3676452636719,
                            "y2": 278.4119873046875
                        },
                        "text": "studies, including those by [1] and [47], have highlighted the perva-"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.3720703125,
                            "y1": 287.32666015625,
                            "y2": 289.3710021972656
                        },
                        "text": "sive issue of malicious bot activity in e-commerce, accounting for"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2013549804688,
                            "y1": 298.28466796875,
                            "y2": 300.3290100097656
                        },
                        "text": "a substantial 21.4% of all traffic in 2018. These fraudulent activities"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2061157226562,
                            "y1": 309.24365234375,
                            "y2": 311.2879943847656
                        },
                        "text": "often happen quickly, making them hard to detect. The inability to"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7199096679688,
                            "y1": 320.2026672363281,
                            "y2": 322.24700927734375
                        },
                        "text": "efficiently process and analyze such massive graphs not only ham-"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7156982421875,
                            "y1": 331.1616516113281,
                            "y2": 333.20599365234375
                        },
                        "text": "pers fraud detection efforts but also exposes businesses to substan-"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1978149414062,
                            "y1": 342.12066650390625,
                            "y2": 344.1650085449219
                        },
                        "text": "tial financial risks and reputational damage. Therefore, addressing"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7166137695312,
                            "y1": 353.07965087890625,
                            "y2": 355.1239929199219
                        },
                        "text": "these challenges is not merely an academic exercise; it is a press-"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2042236328125,
                            "y1": 364.0386657714844,
                            "y2": 366.0830078125
                        },
                        "text": "ing necessity for enhancing the integrity of digital transactions and"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 419.8894348144531,
                            "y1": 374.9976501464844,
                            "y2": 377.0419921875
                        },
                        "text": "safeguarding consumer trust."
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 322.9360046386719,
                            "x2": 559.1881713867188,
                            "y1": 382.7960205078125,
                            "y2": 388.0010070800781
                        },
                        "text": "Despite extensive research onDSD for static graphs [20\u201322, 30, 33,"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.1881713867188,
                            "y1": 396.9156494140625,
                            "y2": 398.9599914550781
                        },
                        "text": "34], dynamic graphs [2, 18, 26, 28, 43], and parallel approaches [14, 16,"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.76800537109375,
                            "x2": 559.7149658203125,
                            "y1": 407.8736572265625,
                            "y2": 409.9179992675781
                        },
                        "text": "41, 42], existing methods face significant challenges for practical de-"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7150268554688,
                            "y1": 418.8326721191406,
                            "y2": 442.7950134277344
                        },
                        "text": "ployment in real-world fraud detection systems. For instance, many existing algorithms primarily rely on static score functions for DSD, lacking the flexibility required for dynamic and evolving fraud detec-"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1987915039062,
                            "y1": 451.70965576171875,
                            "y2": 453.7539978027344
                        },
                        "text": "tion scenarios. Methods such as [4] and [27] are designed with fixed"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.71337890625,
                            "y1": 462.6686706542969,
                            "y2": 464.7130126953125
                        },
                        "text": "detection criteria, which can become less effective as fraudulent be-"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2034912109375,
                            "y1": 473.6276550292969,
                            "y2": 475.6719970703125
                        },
                        "text": "haviors adapt over time. Additionally, incremental algorithms remain"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7149658203125,
                            "y1": 484.586669921875,
                            "y2": 497.5899963378906
                        },
                        "text": "inefficient at handling billion-scale graphs with high transaction volumes, leading to increased latency. Parallel DSD frameworks often"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1984252929688,
                            "y1": 506.5046691894531,
                            "y2": 508.54901123046875
                        },
                        "text": "lack efficient pruning techniques, resulting in excessive iterations"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 489.72882080078125,
                            "y1": 517.462646484375,
                            "y2": 519.5069580078125
                        },
                        "text": "that degrade performance on large-scale graphs."
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7201538085938,
                            "y1": 525.063720703125,
                            "y2": 575.8410034179688
                        },
                        "text": "This paper addresses the following research question: How can we enhance the efficiency and scalability of DSD methods to effectively detect fraud in massive graphs? Challenges. We evaluated existing methods with our industry partner, Anon (anonymized for review). The following issues surfaced:"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.374267578125,
                            "y1": 581.397705078125,
                            "y2": 597.7579956054688
                        },
                        "text": "Firstly, existing algorithms focus on static score functions for DSD and lack flexible customization. While this may be adequate"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.3721313476562,
                            "y1": 606.6726684570312,
                            "y2": 608.7169799804688
                        },
                        "text": "for short-term detection, it becomes less effective over time. For"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7197875976562,
                            "y1": 617.6317138671875,
                            "y2": 619.676025390625
                        },
                        "text": "example, as shown in Figure 1a, graph density can accumulate sig-"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2056274414062,
                            "y1": 628.5906982421875,
                            "y2": 652.552978515625
                        },
                        "text": "nificant errors within a single day, highlighting the need for more adaptive and customizable detection methods. Secondly, existing incremental algorithms are still inefficient at handling billion-scale"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.5810546875,
                            "y1": 661.4676513671875,
                            "y2": 663.511962890625
                        },
                        "text": "graphs with high transaction volumes, leading to increased latency."
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.7049865722656,
                            "x2": 558.1981201171875,
                            "y1": 672.4266967773438,
                            "y2": 674.4710083007812
                        },
                        "text": "This limitation is evident in Figure 1b, which illustrates the system"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2048950195312,
                            "y1": 683.3856811523438,
                            "y2": 685.4299926757812
                        },
                        "text": "load distribution for a specific day\u2019s transactions, underscoring the"
                    },
                    {
                        "page": 0,
                        "region": {
                            "x1": 312.75,
                            "x2": 558.20556640625,
                            "y1": 694.3446655273438,
                            "y2": 707.3469848632812
                        },
                        "text": "inability of current methods to efficiently manage high transaction volumes without significant delays. Thirdly, existing parallel densest"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5390319824219,
                            "y1": 91.60464477539062,
                            "y2": 93.64898681640625
                        },
                        "text": "subgraph discovery frameworks lack efficient pruning techniques, re-"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.2561340332031,
                            "y1": 102.56362915039062,
                            "y2": 104.60797119140625
                        },
                        "text": "sulting in a large number of iterations. This inefficiency is especially"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02239990234375,
                            "y1": 113.52267456054688,
                            "y2": 115.5670166015625
                        },
                        "text": "problematic on billion-scale graphs, where performance degrades"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0223388671875,
                            "y1": 124.48165893554688,
                            "y2": 126.5260009765625
                        },
                        "text": "substantially due to the excessive computational overhead caused"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 299.0242614746094,
                            "y1": 135.43966674804688,
                            "y2": 149.98199462890625
                        },
                        "text": "by numerous iterations. Adapting to Evolving Research Needs. Recognizing the dynamic"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.0116882324219,
                            "y1": 158.89663696289062,
                            "y2": 160.94097900390625
                        },
                        "text": "nature of fraud detection and the rapid evolution of fraudulent tactics,"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 300.4106750488281,
                            "y1": 169.85568237304688,
                            "y2": 193.8179931640625
                        },
                        "text": "we have adapted our research focus to address these challenges. Our approach incorporates flexible customization options for DSD methods, allowing for adjustments based on the changing landscape"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0301208496094,
                            "y1": 202.73165893554688,
                            "y2": 204.7760009765625
                        },
                        "text": "of fraudulent activities. This adaptability is crucial for maintaining"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0276184082031,
                            "y1": 213.69064331054688,
                            "y2": 215.7349853515625
                        },
                        "text": "the effectiveness of fraud detection systems in an environment where"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.1939697265625,
                            "y1": 224.64962768554688,
                            "y2": 239.1920166015625
                        },
                        "text": "new threats continuously emerge. Contributions. In this work, we propose a DSD framework for"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 249.3462371826172,
                            "y1": 248.10665893554688,
                            "y2": 250.1510009765625
                        },
                        "text": "fraud detection. Our key contributions are as follows:"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.26068115234375,
                            "y1": 257.9417724609375,
                            "y2": 275.239990234375
                        },
                        "text": "\u2022 A DSD Parallelization Framework. We propose Dupin, a novel parallel processing framework for densest subgraph discovery"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 61.97100067138672,
                            "x2": 300.5386657714844,
                            "y1": 280.9940185546875,
                            "y2": 286.1990051269531
                        },
                        "text": "(DSD) that breaks the sequential dependencies inherent in tra-"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.0227966308594,
                            "y1": 295.1136474609375,
                            "y2": 297.1579895019531
                        },
                        "text": "ditional density metrics, significantly enhancing scalability and"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 300.54180908203125,
                            "y1": 306.0726623535156,
                            "y2": 319.07598876953125
                        },
                        "text": "efficiency on both weighted and unweighted graphs. Unlike existing methods that focus on specific density metrics, Dupin allows"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.02288818359375,
                            "y1": 327.99066162109375,
                            "y2": 330.0350036621094
                        },
                        "text": "developers to define custom fraud detection semantics through"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 300.541015625,
                            "y1": 338.94866943359375,
                            "y2": 362.9110107421875
                        },
                        "text": "flexible suspiciousness functions for edges and vertices. It supports a wide range of DSD semantics, including DG [6], DW [23], FD [24], TDS [46], and \ud835\udc58CLiDS [14]. Importantly, Dupin not only"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.0220947265625,
                            "y1": 371.8256530761719,
                            "y2": 373.8699951171875
                        },
                        "text": "leverages parallelism but also provides theoretical guarantees on"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.798004150390625,
                            "x2": 299.0262756347656,
                            "y1": 382.78466796875,
                            "y2": 428.6650085449219
                        },
                        "text": "approximation ratios for the supported density metrics. To the best of our knowledge, this is the first generic parallel processing framework that accommodates a broad class of density metrics in DSD, offering both flexibility and theoretical assurance. \u2022 Exploiting Long-Tail Properties.We identify and address the"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.0282897949219,
                            "y1": 434.22174072265625,
                            "y2": 439.6239929199219
                        },
                        "text": "long-tail problem in the peeling process of DSD algorithms, where"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 300.541015625,
                            "y1": 448.5386657714844,
                            "y2": 450.5830078125
                        },
                        "text": "late iterations remove only a small fraction of vertices and con-"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.0228271484375,
                            "y1": 459.49664306640625,
                            "y2": 461.5409851074219
                        },
                        "text": "tribute little to the quality of the densest subgraph, leading to"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 300.541015625,
                            "y1": 470.4556579589844,
                            "y2": 483.4590148925781
                        },
                        "text": "inefficiency. To tackle this, we introduce two novel optimizations: Global Pruning Optimization, which proactively removes"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.025390625,
                            "y1": 492.3736572265625,
                            "y2": 516.3359985351562
                        },
                        "text": "low-contribution vertices within each peeling iteration to reduce computational overhead, and Local Pruning Optimization, which eliminates disparate structures formed after vertex removal to"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.028076171875,
                            "y1": 525.250732421875,
                            "y2": 527.2950439453125
                        },
                        "text": "enhance the density and quality of the detected subgraph. These"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 300.5410461425781,
                            "y1": 536.209716796875,
                            "y2": 538.2540283203125
                        },
                        "text": "optimizations significantly reduce the number of iterations re-"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 263.9032897949219,
                            "y1": 547.168701171875,
                            "y2": 549.2130126953125
                        },
                        "text": "quired, improving both performance and result quality."
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0252685546875,
                            "y1": 553.832763671875,
                            "y2": 560.1719970703125
                        },
                        "text": "\u2022 Empirical Validation and Real-World Impact: We conduct"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.01499938964844,
                            "x2": 300.5446472167969,
                            "y1": 569.085693359375,
                            "y2": 614.9660034179688
                        },
                        "text": "comprehensive experiments on large-scale industry datasets to validate the effectiveness of Dupin. Our results show that Dupin achieves up to 100 times faster fraud detection compared to the state-of-the-art incremental method Spade [28] and parallel methods like PBBS [41]. Moreover,Dupin is capable of preventing up to"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 300.54180908203125,
                            "y1": 623.8806762695312,
                            "y2": 625.9249877929688
                        },
                        "text": "94.5% of potential fraud, demonstrating significant practical bene-"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 292.5688781738281,
                            "y1": 634.8397216796875,
                            "y2": 636.884033203125
                        },
                        "text": "fits and reinforcing system integrity in real-world applications."
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.0865478515625,
                            "y1": 646.9220581054688,
                            "y2": 652.552978515625
                        },
                        "text": "Organization. The remainder of this paper is structured as follows:"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0283203125,
                            "y1": 661.4676513671875,
                            "y2": 674.4710083007812
                        },
                        "text": "Section 2 presents the background and the literature review. Section 3 introduces the architecture of Dupin. In Section 4, we propose the"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.1961669921875,
                            "y1": 683.3856811523438,
                            "y2": 707.3469848632812
                        },
                        "text": "theoretical foundations for parallel peeling-based algorithms for DSD. Section 5 introduces long-tail pruning techniques to improve efficiency and effectiveness. The experimental evaluation of Dupin"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.200927734375,
                            "y1": 91.60464477539062,
                            "y2": 93.64898681640625
                        },
                        "text": "is presented in Section 6. Finally, Section 7 concludes the paper and"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 446.64532470703125,
                            "y1": 102.56362915039062,
                            "y2": 104.60797119140625
                        },
                        "text": "outlines avenues for future research."
                    }
                ],
                "title": {
                    "page": 0,
                    "region": {
                        "x1": 53.79800033569336,
                        "x2": 156.52899169921875,
                        "y1": 455.424072265625,
                        "y2": 462.2749938964844
                    },
                    "text": "1 INTRODUCTION"
                }
            },
            {
                "paragraphs": [],
                "title": {
                    "page": 1,
                    "region": {
                        "x1": 312.9739990234375,
                        "x2": 524.50146484375,
                        "y1": 119.77506256103516,
                        "y2": 126.6259765625
                    },
                    "text": "2 BACKGROUND AND RELATEDWORK"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.7049865722656,
                            "x2": 559.720458984375,
                            "y1": 153.97158813476562,
                            "y2": 156.01593017578125
                        },
                        "text": "This subsection presents the preliminary. Some frequently used no-"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 438.5575866699219,
                            "y1": 164.93057250976562,
                            "y2": 166.97491455078125
                        },
                        "text": "tations are summarized in Table 1."
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.5260009765625,
                            "x2": 558.7393798828125,
                            "y1": 288.4580993652344,
                            "y2": 384.8370056152344
                        },
                        "text": "Graph \ud835\udc3a . In this work, we operate on a weighted graph denoted as \ud835\udc3a = (\ud835\udc49 , \ud835\udc38), where \ud835\udc49 represents the set of vertices and \ud835\udc38 (\u2286 \ud835\udc49 \u00d7\ud835\udc49 ) represents the set of edges. Each edge (\ud835\udc62\ud835\udc56 , \ud835\udc62 \ud835\udc57 ) \u2208 \ud835\udc38 is assigned a nonnegative weight, expressed as \ud835\udc50\ud835\udc56 \ud835\udc57 . Additionally, \ud835\udc41 (\ud835\udc62) denotes the set of neighboring vertices connected to vertex \ud835\udc62. Induced Subgraph. For a given subset \ud835\udc46 of vertices in \ud835\udc49 , we define the induced subgraph as \ud835\udc3a[\ud835\udc46] = (\ud835\udc46, \ud835\udc38[\ud835\udc46]), where \ud835\udc38[\ud835\udc46] = {(\ud835\udc62, \ud835\udc63) | (\ud835\udc62, \ud835\udc63) \u2208 \ud835\udc38 \u2227 \ud835\udc62, \ud835\udc63 \u2208 \ud835\udc46}. The size of the subset \ud835\udc46 is denoted by |\ud835\udc46 |. Density Metrics \ud835\udc54 and Weight Function \ud835\udc53 . We utilize the class of"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.5830688476562,
                            "y1": 391.877685546875,
                            "y2": 421.1319885253906
                        },
                        "text": "metrics\ud835\udc54 as defined in prior works [6, 24, 28], where for a given subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the density metric is computed as: \ud835\udc54(\ud835\udc46) = \ud835\udc53 (\ud835\udc46) |\ud835\udc46 | . Here, \ud835\udc53 (\ud835\udc46) represents the total weight of the induced subgraph \ud835\udc3a[\ud835\udc46],"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 558.2040405273438,
                            "y1": 428.1726989746094,
                            "y2": 432.09100341796875
                        },
                        "text": "which is defined as the sum of the weights of vertices in \ud835\udc46 and the"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 460.57373046875,
                            "y1": 439.1316833496094,
                            "y2": 443.04998779296875
                        },
                        "text": "weights of edges in \ud835\udc38[\ud835\udc46]. More formally:"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 382.3079528808594,
                            "x2": 558.2012329101562,
                            "y1": 431.9579772949219,
                            "y2": 470.3299865722656
                        },
                        "text": "\ud835\udc53 (\ud835\udc46) = \u2211\ufe01 \ud835\udc62\ud835\udc56 \u2208\ud835\udc46 \ud835\udc4e\ud835\udc56 + \u2211\ufe01 (\ud835\udc62\ud835\udc56 ,\ud835\udc62 \ud835\udc57 )\u2208\ud835\udc38[\ud835\udc46] \ud835\udc50\ud835\udc56 \ud835\udc57 (1)"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.3723754882812,
                            "y1": 478.7527770996094,
                            "y2": 528.927978515625
                        },
                        "text": "The weight of a vertex \ud835\udc62\ud835\udc56 , denoted as \ud835\udc4e\ud835\udc56 (\ud835\udc4e\ud835\udc56 \u2265 0), quantifies the suspiciousness of user \ud835\udc62\ud835\udc56 . The weight of an edge (\ud835\udc62\ud835\udc56 , \ud835\udc62 \ud835\udc57 ), represented by \ud835\udc50\ud835\udc56 \ud835\udc57 (\ud835\udc50\ud835\udc56 \ud835\udc57 > 0), reflects the suspiciousness of the transaction between users \ud835\udc62\ud835\udc56 and \ud835\udc62 \ud835\udc57 . Intuitively, the density metric \ud835\udc54(\ud835\udc46) encapsulates the overall suspiciousness density of the induced subgraph\ud835\udc3a[\ud835\udc46]. A larger"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.7049865722656,
                            "x2": 559.7212524414062,
                            "y1": 535.9686279296875,
                            "y2": 596.219970703125
                        },
                        "text": "value of \ud835\udc54(\ud835\udc46) indicates a higher density of suspiciousness within\ud835\udc3a[\ud835\udc46]. The vertex set that maximizes the density metric \ud835\udc54 is denoted by \ud835\udc46\u2217. We next introduce five representative density metrics extensively employed in many fraud detection applications. The density metrics are mainly differed by how the weight function is defined. Dense Subgraphs (DG) [6]. The DG metric is employed to quan-"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.198486328125,
                            "y1": 605.1347045898438,
                            "y2": 607.1790161132812
                        },
                        "text": "tify the connectivity of substructures within a graph. It has found"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1985473632812,
                            "y1": 616.0936889648438,
                            "y2": 618.1380004882812
                        },
                        "text": "extensive applications in various domains, such as detecting fake"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7199096679688,
                            "y1": 627.0526733398438,
                            "y2": 674.4710083007812
                        },
                        "text": "comments in online platforms [29] and identifying fraudulent activities in social networks [3]. Given a subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of DG is defined as \ud835\udc53 (\ud835\udc46) = |\ud835\udc38[\ud835\udc46]|, where |\ud835\udc38[\ud835\udc46]| denotes the number of edges in the induced subgraph \ud835\udc3a[\ud835\udc46]. Dense Subgraph on Weighted Graphs (DW) [23]. In transac-"
                    },
                    {
                        "page": 1,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.186279296875,
                            "y1": 683.3856811523438,
                            "y2": 707.3469848632812
                        },
                        "text": "tion graphs, it is common to have weights assigned to the edges, representing quantities such as the transaction amount. The DW metric extends the concept of dense subgraphs to accommodate these"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 299.0278015136719,
                            "y1": 79.06293487548828,
                            "y2": 117.64697265625
                        },
                        "text": "weighted relationships. Given a subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of DW is defined as \ud835\udc53 (\ud835\udc46) = \u2211 (\ud835\udc62\ud835\udc56 ,\ud835\udc62 \ud835\udc57 )\u2208\ud835\udc38[\ud835\udc46] \ud835\udc50\ud835\udc56 \ud835\udc57 . Fraudar (FD) [24]. In order to mitigate the effects of fraudulent"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5388488769531,
                            "y1": 126.56167602539062,
                            "y2": 139.56402587890625
                        },
                        "text": "actors deliberately obfuscating their activities, Hooi et al. [24] introduced the FD algorithm. This approach innovatively incorporates"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 300.0146484375,
                            "y1": 148.47866821289062,
                            "y2": 150.52301025390625
                        },
                        "text": "weights for edges and assigns prior suspiciousness scores to vertices,"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.40753173828125,
                            "y1": 159.43765258789062,
                            "y2": 172.44097900390625
                        },
                        "text": "potentially utilizing side information to enhance detection accuracy. Given a subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of FD is defined"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.39500045776367,
                            "x2": 299.02655029296875,
                            "y1": 179.48170471191406,
                            "y2": 195.865966796875
                        },
                        "text": "as Equation 1 where \ud835\udc4e\ud835\udc56 denotes the suspicious score of vertex \ud835\udc62\ud835\udc56 and \ud835\udc50\ud835\udc56 \ud835\udc57 = 1"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 75.20700073242188,
                            "x2": 298.0157470703125,
                            "y1": 190.60267639160156,
                            "y2": 198.07000732421875
                        },
                        "text": "log(\ud835\udc65+\ud835\udc50) . Here \ud835\udc65 is the degree of the object vertex between \ud835\udc62\ud835\udc56"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.50199890136719,
                            "x2": 300.54302978515625,
                            "y1": 203.2046661376953,
                            "y2": 241.53900146484375
                        },
                        "text": "and \ud835\udc62 \ud835\udc57 , and \ud835\udc50 is a positive constant [24]. Triangle Densest Subgraph (TDS) [46]. Triangles serve as a crucial structural motif in graphs, providing valuable insights into the connectivity and cohesiveness of subgraphs. The TDS metric, in par-"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5398254394531,
                            "y1": 250.45266723632812,
                            "y2": 274.41497802734375
                        },
                        "text": "ticular, leverages the prevalence of triangles to quantify the density of a subgraph. Given a subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of TDS is defined as \ud835\udc53 (\ud835\udc46) = \ud835\udc61 (\ud835\udc46) where \ud835\udc61 (\ud835\udc46) represents the total"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.44001770019531,
                            "x2": 300.5397644042969,
                            "y1": 281.4556884765625,
                            "y2": 308.83099365234375
                        },
                        "text": "number of triangles within the induced subgraph \ud835\udc3a[\ud835\udc46]. \ud835\udc58-Clique Densest Subgraph (\ud835\udc58CLiDS) [14]. Extending the concept of triangle densest subgraphs, \ud835\udc58CLiDS focuses on identifying"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0268249511719,
                            "y1": 315.8706970214844,
                            "y2": 319.78900146484375
                        },
                        "text": "dense subgraphs based on the presence of \ud835\udc58-Cliques. A \ud835\udc58-Clique is a"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.57400131225586,
                            "x2": 299.1994323730469,
                            "y1": 326.8296813964844,
                            "y2": 352.6659851074219
                        },
                        "text": "complete subgraph of \ud835\udc58 vertices, representing a tightly-knit group of vertices. For a given subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of \ud835\udc58CLiDS is defined as \ud835\udc53 (\ud835\udc46) = \ud835\udc58(\ud835\udc46), where \ud835\udc58(\ud835\udc46) denotes the number"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 227.61563110351562,
                            "y1": 359.7066955566406,
                            "y2": 363.625
                        },
                        "text": "of \ud835\udc58-Cliques within the induced subgraph \ud835\udc3a[\ud835\udc46]."
                    }
                ],
                "title": {
                    "page": 1,
                    "region": {
                        "x1": 312.9739990234375,
                        "x2": 397.9776916503906,
                        "y1": 135.46603393554688,
                        "y2": 142.31695556640625
                    },
                    "text": "2.1 Preliminary"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5404968261719,
                            "y1": 403.2426452636719,
                            "y2": 405.2869873046875
                        },
                        "text": "Peeling algorithms have gained popularity for their efficiency, ro-"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5404968261719,
                            "y1": 414.20166015625,
                            "y2": 416.2460021972656
                        },
                        "text": "bustness, and proven worst-case performance in various applica-"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.03057861328125,
                            "y1": 425.16064453125,
                            "y2": 427.2049865722656
                        },
                        "text": "tions [6, 24, 46]. Next, we provide a concise overview of the typical"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.24029541015625,
                            "y1": 436.1196594238281,
                            "y2": 472.5790100097656
                        },
                        "text": "execution flow of these algorithms. Peeling Weight.We use\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46) to indicate the decrease in the value of the weight function \ud835\udc53 when the vertex\ud835\udc62\ud835\udc56 is removed from a vertex set \ud835\udc46 , i.e., the peeling weight. Formally,"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 74.77799224853516,
                            "x2": 299.02630615234375,
                            "y1": 472.9330139160156,
                            "y2": 511.3040771484375
                        },
                        "text": "\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46) = \ud835\udc4e\ud835\udc56 + \u2211\ufe01 (\ud835\udc62 \ud835\udc57 \u2208\ud835\udc46) \u2227 ((\ud835\udc62\ud835\udc56 ,\ud835\udc62 \ud835\udc57 )\u2208\ud835\udc38) \ud835\udc50\ud835\udc56 \ud835\udc57 + \u2211\ufe01 (\ud835\udc62 \ud835\udc57 \u2208\ud835\udc46) \u2227 ((\ud835\udc62 \ud835\udc57 ,\ud835\udc62\ud835\udc56 )\u2208\ud835\udc38) \ud835\udc50 \ud835\udc57\ud835\udc56 (2)"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 58.448001861572266,
                            "x2": 220.54251098632812,
                            "y1": 544.7820434570312,
                            "y2": 562.4290161132812
                        },
                        "text": "Algorithm 1: Sequential Peeling Algorithm Input: A graph\ud835\udc3a = (\ud835\udc49 , \ud835\udc38) and a density metric \ud835\udc54(\ud835\udc46)"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 63.76100158691406,
                            "x2": 263.3112487792969,
                            "y1": 566.0194702148438,
                            "y2": 570.3989868164062
                        },
                        "text": "Output: A subset of vertices \ud835\udc46 that maximizes the density metric \ud835\udc54(\ud835\udc46)"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 56.71697998046875,
                            "x2": 286.2738342285156,
                            "y1": 573.5311889648438,
                            "y2": 616.239013671875
                        },
                        "text": "1 \ud835\udc460 \u2190 \ud835\udc49 /* Initialize the subset with all vertices */ 2 for \ud835\udc56 \u2190 1 to |\ud835\udc49 | do 3 \ud835\udc62 \u2190 arg max\ud835\udc63\u2208\ud835\udc46\ud835\udc56\u22121 \ud835\udc54(\ud835\udc46\ud835\udc56\u22121 \\ {\ud835\udc63 }) /* The vertex to be peeled */ 4 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56\u22121 \\ {\ud835\udc62 } /* The selected vertex */ 5 return arg max\ud835\udc46\ud835\udc56 \ud835\udc54(\ud835\udc46\ud835\udc56 ) /* The subset that maximizes \ud835\udc54(\ud835\udc46) */"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 53.52899932861328,
                            "x2": 299.2589416503906,
                            "y1": 635.9630737304688,
                            "y2": 709.3300170898438
                        },
                        "text": "Sequential PeelingAlgorithm (Algorithm1).The peeling process starts with the full vertex set \ud835\udc460 = \ud835\udc49 (Line 1) and iteratively removes vertices to maximize the density metric \ud835\udc54. In each step \ud835\udc56 , a vertex\ud835\udc62\ud835\udc56 is removed from \ud835\udc46\ud835\udc56\u22121 to form \ud835\udc46\ud835\udc56 , such that \ud835\udc54(\ud835\udc46\ud835\udc56\u22121 \\ {\ud835\udc62\ud835\udc56 }) is maximized (Lines 3\u223c4). This process is repeated until \ud835\udc46\ud835\udc56 becomes empty, resulting in a sequence of nested sets \ud835\udc460, \ud835\udc461, . . . , \ud835\udc46 |\ud835\udc49 | . The algorithm ultimately returns the subset \ud835\udc46\ud835\udc56 \u2208 {\ud835\udc460, . . . , \ud835\udc46 |\ud835\udc49 |} that maximizes \ud835\udc54(\ud835\udc46\ud835\udc56 )."
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 322.4150085449219,
                            "x2": 549.337158203125,
                            "y1": 88.7467269897461,
                            "y2": 225.656005859375
                        },
                        "text": "Example 2.1 (Seqential Peeling Algorithm Process). Consider the graph \ud835\udc3a as shown in Figure 2. The process begins with an initial graph density of 2.33. In the first iteration, vertex \ud835\udc621 is peeled due to its smallest peeling weight among all vertices. Subsequently, vertices are peeled in the following order: \ud835\udc622, \ud835\udc623, \ud835\udc624, \ud835\udc625, and \ud835\udc626 based on the updated criteria after each peeling operation. Notably, after peeling \ud835\udc622, the graph density increases, which is a characteristic observation in the peeling process. The sequence of peeling continues until the last vertex, \ud835\udc626, is peeled, resulting in a final graph density of 0. The peeling sequence, therefore, is \ud835\udc42 = [\ud835\udc621, \ud835\udc622, \ud835\udc623, \ud835\udc624, \ud835\udc625, \ud835\udc626], completely disassembling the graph. The induced subgraph\ud835\udc3a[\ud835\udc46] of \ud835\udc46 = [\ud835\udc623, \ud835\udc624, \ud835\udc625, \ud835\udc626] has the greatest density of 2.75, thus \ud835\udc3a[\ud835\udc46] is returned."
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 558.4324340820312,
                            "y1": 241.02308654785156,
                            "y2": 257.61297607421875
                        },
                        "text": "Approximation. An algorithm \ud835\udc44 is defined as an \ud835\udefc-approximation for the Densest Subgraph Discovery (DSD), where \ud835\udefc \u2265 1, if for any"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 522.2989501953125,
                            "y1": 264.6537170410156,
                            "y2": 268.572021484375
                        },
                        "text": "given graph it returns a subset \ud835\udc46 satisfying the condition:"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 411.4019775390625,
                            "x2": 459.235595703125,
                            "y1": 273.68719482421875,
                            "y2": 294.3900146484375
                        },
                        "text": "\ud835\udc54(\ud835\udc46) \u2265 \ud835\udc54(\ud835\udc46\u2217) \ud835\udefc ,"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 558.7066040039062,
                            "y1": 297.51422119140625,
                            "y2": 305.9110107421875
                        },
                        "text": "where \ud835\udc46\u2217 is the optimal subset that maximizes the density metric \ud835\udc54."
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2012939453125,
                            "y1": 313.92034912109375,
                            "y2": 333.3580017089844
                        },
                        "text": "Theorem 2.1 ([24]). For the vertex set \ud835\udc46\ud835\udc5d returned by Algorithm 1 and the optimal vertex set \ud835\udc46\u2217, it holds that \ud835\udc54(\ud835\udc46\ud835\udc5d ) \u2265 \ud835\udc54(\ud835\udc46\u2217)"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 501.5610046386719,
                            "x2": 558.6319580078125,
                            "y1": 327.95574951171875,
                            "y2": 336.45098876953125
                        },
                        "text": "2 for DG, DW"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 420.1670837402344,
                            "y1": 338.9147644042969,
                            "y2": 344.3170166015625
                        },
                        "text": "and FD as the density metrics."
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 322.9360046386719,
                            "x2": 558.2008056640625,
                            "y1": 353.53900146484375,
                            "y2": 358.7439880371094
                        },
                        "text": "We extend the analysis to TDS and \ud835\udc58CLiDS. The proof of the"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 507.06988525390625,
                            "y1": 367.6586608886719,
                            "y2": 369.7030029296875
                        },
                        "text": "following theorem is omitted due to space limitation."
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1983032226562,
                            "y1": 377.7123718261719,
                            "y2": 397.1499938964844
                        },
                        "text": "Theorem 2.2. For the vertex set \ud835\udc46\ud835\udc5d returned by Algorithm 1 and the optimal vertex set \ud835\udc46\u2217, it holds that \ud835\udc54(\ud835\udc46\ud835\udc5d ) \u2265 \ud835\udc54(\ud835\udc46\u2217)"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 470.81201171875,
                            "x2": 558.2012939453125,
                            "y1": 391.74774169921875,
                            "y2": 400.72601318359375
                        },
                        "text": "\ud835\udc58 for TDS and \ud835\udc58CLiDS"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 466.047607421875,
                            "y1": 402.7067565917969,
                            "y2": 408.1090087890625
                        },
                        "text": "as the density metrics where \ud835\udc58 = 3 for TDS."
                    }
                ],
                "title": {
                    "page": 2,
                    "region": {
                        "x1": 53.79801940917969,
                        "x2": 229.8490753173828,
                        "y1": 384.7380676269531,
                        "y2": 391.5889892578125
                    },
                    "text": "2.2 Sequential Peeling Algorithms"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7194213867188,
                            "y1": 438.703125,
                            "y2": 444.3340148925781
                        },
                        "text": "Densest Subgraph Discovery (DSD). Densest subgraph discov-"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.4387817382812,
                            "y1": 453.2486572265625,
                            "y2": 455.2929992675781
                        },
                        "text": "ery represents a core area of research in graph theory, extensively"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.716064453125,
                            "y1": 464.2076721191406,
                            "y2": 466.25201416015625
                        },
                        "text": "explored in literature [7, 8, 20, 30, 39, 40]. The foundational max-flow-"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2017211914062,
                            "y1": 475.1656494140625,
                            "y2": 477.2099914550781
                        },
                        "text": "based algorithm by Goldberg et al. [21] set a benchmark for exact"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1983642578125,
                            "y1": 486.1246643066406,
                            "y2": 488.16900634765625
                        },
                        "text": "densest subgraph detection, with subsequent studies introducing"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2047729492188,
                            "y1": 497.0836486816406,
                            "y2": 499.12799072265625
                        },
                        "text": "more scalable exact solutions [33, 34]. While speed enhancements"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.1883544921875,
                            "y1": 508.04266357421875,
                            "y2": 510.0870056152344
                        },
                        "text": "have been achieved through various greedy approaches [6, 8, 24, 33],"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.5870361328125,
                            "y1": 519.001708984375,
                            "y2": 521.0460205078125
                        },
                        "text": "these methods are inherently sequential and difficult to parallelize."
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1983642578125,
                            "y1": 529.960693359375,
                            "y2": 532.0050048828125
                        },
                        "text": "For example, they often peel one vertex at a time, which results"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.3720703125,
                            "y1": 540.919677734375,
                            "y2": 542.9639892578125
                        },
                        "text": "in too many peeling iterations. This sequential nature limits their"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7149658203125,
                            "y1": 551.878662109375,
                            "y2": 553.9229736328125
                        },
                        "text": "scalability and efficiency on massive graphs. In graph-based fraud de-"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2013549804688,
                            "y1": 562.8377075195312,
                            "y2": 564.8820190429688
                        },
                        "text": "tection, techniques like COPYCATCH [4] and GETTHESCOOP [27]"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7166137695312,
                            "y1": 573.7966918945312,
                            "y2": 575.8410034179688
                        },
                        "text": "leverage local search heuristics to identify dense subgraphs in bi-"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.4393310546875,
                            "y1": 584.7556762695312,
                            "y2": 586.7999877929688
                        },
                        "text": "partite networks, frequently applied in fraud, spam, and community"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1976318359375,
                            "y1": 595.7136840820312,
                            "y2": 597.7579956054688
                        },
                        "text": "detection across social and review platforms [24, 37, 42]. Despite"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.198486328125,
                            "y1": 606.6726684570312,
                            "y2": 608.7169799804688
                        },
                        "text": "their widespread use, these methods suffer from efficiency issues"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7172241210938,
                            "y1": 617.6317138671875,
                            "y2": 619.676025390625
                        },
                        "text": "in very large graphs, often involving numerous iterations and lack-"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.198486328125,
                            "y1": 628.5906982421875,
                            "y2": 630.635009765625
                        },
                        "text": "ing effective pruning techniques, which exacerbates the long-tail"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2062377929688,
                            "y1": 639.5496826171875,
                            "y2": 652.552978515625
                        },
                        "text": "problem. Moreover, they are limited to specific definitions of dense subgraphs. Contrarily, Dupin offers a versatile, parallel approach to"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.20361328125,
                            "y1": 661.4676513671875,
                            "y2": 663.511962890625
                        },
                        "text": "densest subgraph detection. It facilitates the simultaneous peeling of"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.6600036621094,
                            "x2": 559.7149658203125,
                            "y1": 672.4266967773438,
                            "y2": 685.4299926757812
                        },
                        "text": "multiple vertices, drastically reducing the computational overhead. Additionally, Dupin provides APIs that allow users to customize defi-"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.4320068359375,
                            "y1": 694.3446655273438,
                            "y2": 696.3889770507812
                        },
                        "text": "nitions of dense subgraphs, ensuring that the resultant graph density"
                    },
                    {
                        "page": 2,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 423.0277099609375,
                            "y1": 705.3026733398438,
                            "y2": 707.3469848632812
                        },
                        "text": "adheres to theoretical bounds."
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.54241943359375,
                            "y1": 188.7221221923828,
                            "y2": 194.35302734375
                        },
                        "text": "DSD on Dynamic Graphs. To tackle real-time fraud detection, sev-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.0126647949219,
                            "y1": 203.26766967773438,
                            "y2": 205.31201171875
                        },
                        "text": "eral variants have been designed for dynamic graphs [10, 18, 26, 28,"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.59199905395508,
                            "x2": 299.02728271484375,
                            "y1": 214.22567749023438,
                            "y2": 216.27001953125
                        },
                        "text": "43]. [28] addresses real-time fraud community detection on evolving"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5395812988281,
                            "y1": 225.18466186523438,
                            "y2": 227.22900390625
                        },
                        "text": "graphs (edge insertions) using an incremental peeling sequence re-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0289306640625,
                            "y1": 236.14364624023438,
                            "y2": 238.18798828125
                        },
                        "text": "ordering method, while [26] extends this approach to fully dynamic"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0240478515625,
                            "y1": 247.10263061523438,
                            "y2": 249.14697265625
                        },
                        "text": "graphs (edge insertions and deletions). [43] proposes an incremental"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5404968261719,
                            "y1": 258.0616760253906,
                            "y2": 260.10601806640625
                        },
                        "text": "algorithm that maintains and updates a dense subtensor in a ten-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0263671875,
                            "y1": 269.0206604003906,
                            "y2": 271.06500244140625
                        },
                        "text": "sor stream. [12] and [36] utilize sliding windows to detect dense"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02960205078125,
                            "y1": 279.9796447753906,
                            "y2": 282.02398681640625
                        },
                        "text": "subgraphs and bursting cores within specific time windows. These"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5379333496094,
                            "y1": 290.93865966796875,
                            "y2": 292.9830017089844
                        },
                        "text": "methods have three limitations. First, response time is an issue. Al-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.022705078125,
                            "y1": 301.89764404296875,
                            "y2": 303.9419860839844
                        },
                        "text": "though they respond quickly to benign communities, the results can"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.53814697265625,
                            "y1": 312.8566589355469,
                            "y2": 314.9010009765625
                        },
                        "text": "change drastically for newly formed fraudulent communities, caus-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.40716552734375,
                            "y1": 323.8146667480469,
                            "y2": 325.8590087890625
                        },
                        "text": "ing significant delays in incremental calculations for fraud detection."
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0253601074219,
                            "y1": 334.7736511230469,
                            "y2": 336.8179931640625
                        },
                        "text": "Second, efficiency is problematic. While incremental processing is"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0222473144531,
                            "y1": 345.732666015625,
                            "y2": 347.7770080566406
                        },
                        "text": "faster than recomputation for a single transaction on billion-scale"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0254211425781,
                            "y1": 356.691650390625,
                            "y2": 358.7359924316406
                        },
                        "text": "graphs, frequent incremental evaluations can be slower than a full"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.53985595703125,
                            "y1": 367.6506652832031,
                            "y2": 426.02801513671875
                        },
                        "text": "recomputation. Third, in terms of flexibility, most methods support only a single semantic. In contrast, Dupin introduces a unified parallel framework for peeling-based dense subgraph detection.Dupin can respond within seconds on billion-scale graphs and defines multiple density metrics that can be used on the Dupin platform. Parallel DSD. Several parallel methods for DSD have been pro-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5444030761719,
                            "y1": 434.9426574707031,
                            "y2": 458.9049987792969
                        },
                        "text": "posed [2, 14, 16, 39, 41, 42]. Bahmani et al. [2] proposed a parallel algorithm for DG using the MapReduce framework. FWA [15] proposed a parallel algorithm for DW based on Frank-Wolfe algo-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0264587402344,
                            "y1": 465.9457092285156,
                            "y2": 469.864013671875
                        },
                        "text": "rithm [25] using OpenMP [13]. Some works propose parallel \ud835\udc58-core"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.541259765625,
                            "y1": 476.9046936035156,
                            "y2": 480.822998046875
                        },
                        "text": "algorithms [32, 41, 44]. Others introduce parallel algorithms for \ud835\udc58-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.4065246582031,
                            "y1": 487.86370849609375,
                            "y2": 502.7409973144531
                        },
                        "text": "Clique detection, with approaches offering a (1 + \ud835\udf16)-approximation ratio and parallel implementations for the \ud835\udc58CLiDS problem [16, 45]."
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.52899932861328,
                            "x2": 299.0301513671875,
                            "y1": 509.7806701660156,
                            "y2": 513.698974609375
                        },
                        "text": "There are also algorithms for \ud835\udc58-Clique densest subgraph detection"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.4073791503906,
                            "y1": 522.6136474609375,
                            "y2": 524.657958984375
                        },
                        "text": "using OpenMP [14], and methods for dense subtensor detection [42]."
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.539794921875,
                            "y1": 533.5726928710938,
                            "y2": 535.6170043945312
                        },
                        "text": "However, these systems have two main limitations. First, they typi-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02764892578125,
                            "y1": 544.5316772460938,
                            "y2": 546.5759887695312
                        },
                        "text": "cally support only a single-densitymetric and do not handle weighted"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0254821777344,
                            "y1": 555.49072265625,
                            "y2": 557.5350341796875
                        },
                        "text": "graphs. In real-world applications, transactions between users can"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5405578613281,
                            "y1": 566.44970703125,
                            "y2": 568.4940185546875
                        },
                        "text": "have varying degrees of importance based on amounts, frequen-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.1938171386719,
                            "y1": 577.40869140625,
                            "y2": 579.4530029296875
                        },
                        "text": "cies [28], and other factors. Extending these systems to support other"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.25604248046875,
                            "y1": 588.36767578125,
                            "y2": 590.4119873046875
                        },
                        "text": "dense metrics with theoretical guarantees is non-trivial. Second, they"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.54052734375,
                            "y1": 599.32666015625,
                            "y2": 601.3709716796875
                        },
                        "text": "often lack efficient pruning techniques, requiring numerous itera-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.2561340332031,
                            "y1": 610.2857055664062,
                            "y2": 623.2879638671875
                        },
                        "text": "tions and suffering from the long-tail issue, which hinders scalability on massive graphs. In contrast, Dupin defines the characteristics of"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5457763671875,
                            "y1": 632.2026977539062,
                            "y2": 634.2470092773438
                        },
                        "text": "a set of supported dense metrics and accommodates weighted sub-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.03070068359375,
                            "y1": 643.1616821289062,
                            "y2": 645.2059936523438
                        },
                        "text": "graphs, allowing for more nuanced analysis reflective of real-world"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0304260253906,
                            "y1": 654.1206665039062,
                            "y2": 656.1649780273438
                        },
                        "text": "data. Our method introduces efficient pruning strategies by peeling"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.53900146484375,
                            "y1": 665.0797119140625,
                            "y2": 667.1240234375
                        },
                        "text": "multiple vertices in parallel based on a threshold mechanism, signifi-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0276184082031,
                            "y1": 676.0386962890625,
                            "y2": 689.0419921875
                        },
                        "text": "cantly reducing the number of iterations and mitigating the long-tail problem. This makes Dupin more effective and scalable in diverse"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 255.60475158691406,
                            "y1": 697.9566650390625,
                            "y2": 700.0009765625
                        },
                        "text": "real-world scenarios compared to previous approaches."
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 458.56634521484375,
                            "y1": 187.50204467773438,
                            "y2": 194.35296630859375
                        },
                        "text": "3 THE Dupin FRAMEWORK"
                    }
                ],
                "title": {
                    "page": 2,
                    "region": {
                        "x1": 312.97393798828125,
                        "x2": 403.890380859375,
                        "y1": 422.24609375,
                        "y2": 429.0970153808594
                    },
                    "text": "2.3 Related work"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.6600036621094,
                            "x2": 558.2059326171875,
                            "y1": 218.53700256347656,
                            "y2": 234.70098876953125
                        },
                        "text": "A notable example of advanced fraud detection is seen in Anon, a prominent technology company in Southeast Asia known for its"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2000732421875,
                            "y1": 243.61563110351562,
                            "y2": 245.65997314453125
                        },
                        "text": "digital payment and food delivery services. As delineated in [28], the"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1973876953125,
                            "y1": 252.70069885253906,
                            "y2": 256.6190185546875
                        },
                        "text": "detection process begins with forming a transaction graph,\ud835\udc3a , derived"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7166137695312,
                            "y1": 265.5336608886719,
                            "y2": 278.5369873046875
                        },
                        "text": "from the platform\u2019s transactions. This graph is incrementally updated, represented as \ud835\udc3a = \ud835\udc3a \u2295 \u2206\ud835\udc3a . Subsequent stages utilize densest"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.5810546875,
                            "y1": 287.45166015625,
                            "y2": 289.4960021972656
                        },
                        "text": "subgraph discovery algorithms to uncover fraudulent communities."
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.6600036621094,
                            "x2": 558.2059326171875,
                            "y1": 298.41064453125,
                            "y2": 300.4549865722656
                        },
                        "text": "A typical fraud scenario on the platform involves customer-merchant"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1983032226562,
                            "y1": 309.3696594238281,
                            "y2": 311.41400146484375
                        },
                        "text": "collusion, where fake accounts are created to exploit promotional"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2036743164062,
                            "y1": 320.3286437988281,
                            "y2": 322.37298583984375
                        },
                        "text": "incentives. These fraudulent activities manifest as densest subgraphs"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 559.7184448242188,
                            "y1": 331.2866516113281,
                            "y2": 356.7879943847656
                        },
                        "text": "within the transaction graph. Efficiency. Our empirical findings reveal that the incremental execution of DSD algorithms, such as Spade [28], on a graph with 2 billion"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.2607421875,
                            "y1": 365.7026672363281,
                            "y2": 367.74700927734375
                        },
                        "text": "edges requires approximately 198 seconds per batch (default setting:"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7138061523438,
                            "y1": 376.6616516113281,
                            "y2": 378.70599365234375
                        },
                        "text": "one batch of 1K edge insertions). However, in practical business sce-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.5791625976562,
                            "y1": 387.62066650390625,
                            "y2": 389.6650085449219
                        },
                        "text": "narios, the number of incoming edges can peak at 400K per minute."
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2047729492188,
                            "y1": 398.5786437988281,
                            "y2": 400.62298583984375
                        },
                        "text": "Clearly, using incremental evaluation on billion-scale graphs does"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7201538085938,
                            "y1": 409.53765869140625,
                            "y2": 424.0799865722656
                        },
                        "text": "not provide sufficient throughput to meet business requirements. Latency and Prevention Ratio. Existing DSD systems face sig-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1983642578125,
                            "y1": 432.9946594238281,
                            "y2": 435.03900146484375
                        },
                        "text": "nificant challenges in terms of latency and prevention ratio. Upon"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.3704833984375,
                            "y1": 443.9536437988281,
                            "y2": 445.99798583984375
                        },
                        "text": "identification of fraudulent activities, actions such as account bans or"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.715087890625,
                            "y1": 454.91265869140625,
                            "y2": 456.9570007324219
                        },
                        "text": "freezes are implemented to prevent further losses. However, the aver-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2036743164062,
                            "y1": 465.87066650390625,
                            "y2": 467.9150085449219
                        },
                        "text": "age latency for these systems to detect fraud and take action is often"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2037353515625,
                            "y1": 476.82965087890625,
                            "y2": 478.8739929199219
                        },
                        "text": "high, typically around 200 to 300 seconds for incremental algorithms"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2035522460938,
                            "y1": 487.7886657714844,
                            "y2": 489.8330078125
                        },
                        "text": "and more than 1000 seconds for existing parallel algorithms, which is"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2035522460938,
                            "y1": 498.7476501464844,
                            "y2": 500.7919921875
                        },
                        "text": "insufficient for real-time requirements (operational demand requires"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2001953125,
                            "y1": 509.7066650390625,
                            "y2": 511.7510070800781
                        },
                        "text": "detection within seconds). Moreover, when the graph size increases"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1983642578125,
                            "y1": 520.6656494140625,
                            "y2": 522.7099609375
                        },
                        "text": "from million-scale to billion-scale, the prevention ratio decreases"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2044067382812,
                            "y1": 531.6246948242188,
                            "y2": 533.6690063476562
                        },
                        "text": "from 92.47% to 45%. These issues underscore the necessity for more"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1989135742188,
                            "y1": 542.5836791992188,
                            "y2": 544.6279907226562
                        },
                        "text": "efficient and scalable algorithms that can maintain low latency and"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 530.6963500976562,
                            "y1": 553.542724609375,
                            "y2": 555.5870361328125
                        },
                        "text": "high prevention ratios, even under heavy transaction loads."
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 322.9360046386719,
                            "x2": 559.7180786132812,
                            "y1": 564.501708984375,
                            "y2": 566.5460205078125
                        },
                        "text": "Parallelization offers a viable solution to these challenges by dis-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.716552734375,
                            "y1": 575.460693359375,
                            "y2": 577.5050048828125
                        },
                        "text": "tributing the computational load across multiple processors. Mod-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7161865234375,
                            "y1": 586.418701171875,
                            "y2": 599.4219970703125
                        },
                        "text": "ern CPUs are equipped with numerous cores that are cost-effective, enabling parallel processing. If the peeling process of DSD is paral-"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1983032226562,
                            "y1": 608.336669921875,
                            "y2": 610.3809814453125
                        },
                        "text": "lelized, different processors can simultaneously evaluate and peel"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.3720092773438,
                            "y1": 619.295654296875,
                            "y2": 621.3399658203125
                        },
                        "text": "different nodes, thereby increasing scalability and efficiency. For"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.203857421875,
                            "y1": 630.2546997070312,
                            "y2": 632.2990112304688
                        },
                        "text": "example, if we can improve processing speed by one to two orders of"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1987915039062,
                            "y1": 641.2136840820312,
                            "y2": 643.2579956054688
                        },
                        "text": "magnitude, the system would be able to meet industry requirements"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.4356079101562,
                            "y1": 652.1726684570312,
                            "y2": 666.7139892578125
                        },
                        "text": "for real-time fraud detection, completing detection within seconds. Problem Statement. Given a graph \ud835\udc3a = (\ud835\udc49 , \ud835\udc38) and a community"
                    },
                    {
                        "page": 3,
                        "region": {
                            "x1": 312.75,
                            "x2": 558.2041625976562,
                            "y1": 673.754638671875,
                            "y2": 688.6320190429688
                        },
                        "text": "detection semantic with density metric \ud835\udc54(\ud835\udc46), our goal is to find a vertex subset \ud835\udc46\u2217 \u2286 \ud835\udc49 that maximizes \ud835\udc54(\ud835\udc46\u2217)."
                    }
                ],
                "title": {
                    "page": 3,
                    "region": {
                        "x1": 312.9739990234375,
                        "x2": 397.0940246582031,
                        "y1": 203.19302368164062,
                        "y2": 210.0439453125
                    },
                    "text": "3.1 Motivations"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.52899932861328,
                            "x2": 300.5418395996094,
                            "y1": 254.04200744628906,
                            "y2": 270.20599365234375
                        },
                        "text": "To enable users to design complex DSD algorithms to detect fraudsters based on our framework, Dupin, we have introduced the archi-"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 300.5431823730469,
                            "y1": 279.12066650390625,
                            "y2": 326.53900146484375
                        },
                        "text": "tecture, APIs, and supported density metrics in this section. Architecture of Dupin. Figure 3 presents the architecture of Dupin with user-defined functions for detecting suspicious activities.Dupin enables users to define their fraud detection semantics through a set of provided APIs. Within Dupin\u2019s computational engine, we sup-"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.0100402832031,
                            "y1": 335.4536437988281,
                            "y2": 337.49798583984375
                        },
                        "text": "port both sequential and parallel peeling algorithms. Additionally,"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5435791015625,
                            "y1": 346.41265869140625,
                            "y2": 348.4570007324219
                        },
                        "text": "algorithms for long-tail pruning techniques are implemented to ac-"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0304870605469,
                            "y1": 357.37164306640625,
                            "y2": 370.375
                        },
                        "text": "celerate convergence and enhance the density of subgraphs in each iteration. Dupin identifies fraudulent communities, which are then"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 299.0220947265625,
                            "y1": 379.2896728515625,
                            "y2": 393.83099365234375
                        },
                        "text": "flagged for further investigation by moderators. APIs of Dupin (Figure 3). Dupin simplifies the process of defining"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5398254394531,
                            "y1": 402.74566650390625,
                            "y2": 415.7489929199219
                        },
                        "text": "detection semantics by allowing users to specify a few simple functions. Additionally, Dupin offers APIs that enable users to balance"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0227355957031,
                            "y1": 424.6636657714844,
                            "y2": 426.7080078125
                        },
                        "text": "detection speed and accuracy effectively. The key APIs encompass"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5450134277344,
                            "y1": 435.6226501464844,
                            "y2": 437.6669921875
                        },
                        "text": "several components designed to facilitate the customization and op-"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.027587890625,
                            "y1": 446.5816650390625,
                            "y2": 448.6260070800781
                        },
                        "text": "timization of fraud detection processes. These components provide a"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.53900146484375,
                            "y1": 457.5406494140625,
                            "y2": 459.5849914550781
                        },
                        "text": "robust framework for users to implement their fraud detection strate-"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02874755859375,
                            "y1": 468.4996643066406,
                            "y2": 470.54400634765625
                        },
                        "text": "gies, ensuring both high performance and precision in identifying"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 218.95013427734375,
                            "y1": 479.4576721191406,
                            "y2": 481.50201416015625
                        },
                        "text": "fraudulent activities. Details are listed below:"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0242919921875,
                            "y1": 522.2578125,
                            "y2": 528.5970458984375
                        },
                        "text": "\u2022 pWeight and updateNgh. These functions are designed for the"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.3568115234375,
                            "y1": 538.3447265625,
                            "y2": 540.3890380859375
                        },
                        "text": "dynamic adjustment of weights within the network. They allow"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.0242004394531,
                            "y1": 549.3037109375,
                            "y2": 551.3480224609375
                        },
                        "text": "the user to define the peeling weight of a vertex and specify the"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.0235595703125,
                            "y1": 560.2626953125,
                            "y2": 562.3070068359375
                        },
                        "text": "method for updating the peeling weight of neighboring vertices"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 173.10952758789062,
                            "y1": 571.2216796875,
                            "y2": 573.2659912109375
                        },
                        "text": "after a vertex has been peeled."
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5443420410156,
                            "y1": 577.8857421875,
                            "y2": 584.2249755859375
                        },
                        "text": "\u2022 VSusp and ESusp. Given a vertex/edge, these components are re-"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.02276611328125,
                            "y1": 593.9276733398438,
                            "y2": 595.9719848632812
                        },
                        "text": "sponsible for deciding the suspiciousness of the endpoint of the"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 229.34681701660156,
                            "y1": 604.88671875,
                            "y2": 606.9310302734375
                        },
                        "text": "edge or the edge with a user-defined strategy."
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0267028808594,
                            "y1": 611.5498046875,
                            "y2": 617.8890380859375
                        },
                        "text": "\u2022 isBenign. This component is used to decide whether a vertex is"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.23846435546875,
                            "y1": 627.8026733398438,
                            "y2": 629.8469848632812
                        },
                        "text": "benign during the whole peeling process (Section 5). If the vertex"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 244.141357421875,
                            "y1": 638.76171875,
                            "y2": 640.8060302734375
                        },
                        "text": "is benign, it is peeled within the current iteration."
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0238342285156,
                            "y1": 645.42578125,
                            "y2": 651.7650146484375
                        },
                        "text": "\u2022 setEpsilon. This function is utilized to control the precision of"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.0298767089844,
                            "y1": 661.4676513671875,
                            "y2": 663.511962890625
                        },
                        "text": "fraud detection. During periods of high system load, moderators"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 299.0245666503906,
                            "y1": 670.5526733398438,
                            "y2": 674.4710083007812
                        },
                        "text": "can increase \ud835\udf16 to achieve higher throughput. Conversely, when"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 293.5588073730469,
                            "y1": 681.5116577148438,
                            "y2": 685.4299926757812
                        },
                        "text": "the system load is low, \ud835\udf16 can be decreased to enhance accuracy."
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 53.797996520996094,
                            "x2": 299.0269775390625,
                            "y1": 690.0497436523438,
                            "y2": 696.3889770507812
                        },
                        "text": "\u2022 setK. This function specifies the \ud835\udc58-Clique parameter, enabling the"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 62.2400016784668,
                            "x2": 201.5547332763672,
                            "y1": 703.4286499023438,
                            "y2": 707.3469848632812
                        },
                        "text": "definition of the \ud835\udc58-Clique for analysis."
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 316.7049865722656,
                            "x2": 535.742431640625,
                            "y1": 89.43976593017578,
                            "y2": 164.83197021484375
                        },
                        "text": "1 double vsusp(const Vertex& v, const Graph& g) { 2 return g.weight[v]; // Side information on vertex 3 } 4 double esusp(const Edge& e, const Graph& g) { 5 return 1.0 / log(g.deg[e.src] + 5.0); 6 } 7 int main() { 8 Dupin dupin; 9 dupin.VSusp(vsusp); // Plug in vsusp"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 313.4620056152344,
                            "x2": 523.4334716796875,
                            "y1": 170.26922607421875,
                            "y2": 218.6300048828125
                        },
                        "text": "10 dupin.ESusp(esusp); // Plug in esusp 11 dupin.setEpsilon (0.1); 12 dupin.LoadGraph(\"graph_sample_path\"); 13 vector <Vertex > fraudsters = dupin.ParDetect (); 14 return 0; 15 }"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 361.7460021972656,
                            "x2": 529.3546752929688,
                            "y1": 225.97511291503906,
                            "y2": 231.60601806640625
                        },
                        "text": "Listing 1: Implementation of FD on Dupin"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.177001953125,
                            "y1": 251.9461212158203,
                            "y2": 313.8789978027344
                        },
                        "text": "Example (Listing 1). To implement FD [24] on Dupin, users simply need to plug in the suspiciousness function vsusp for the vertices by calling VSusp and the suspiciousness function esusp for the edges by calling ESusp. Specifically, 1) vsusp is a constant function, i.e., given a vertex \ud835\udc62, vsusp(\ud835\udc62) = \ud835\udc4e\ud835\udc56 and 2) esusp is a logarithmic function such that given an edge (\ud835\udc62\ud835\udc56 , \ud835\udc62 \ud835\udc57 ), esusp(\ud835\udc62\ud835\udc56 , \ud835\udc62 \ud835\udc57 ) = 1"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 488.947998046875,
                            "x2": 558.2013549804688,
                            "y1": 308.6156921386719,
                            "y2": 316.0830078125
                        },
                        "text": "log(\ud835\udc65+\ud835\udc50) , where \ud835\udc65 is"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2012329101562,
                            "y1": 321.05169677734375,
                            "y2": 326.31500244140625
                        },
                        "text": "the degree of the object vertex between \ud835\udc62\ud835\udc56 and \ud835\udc62 \ud835\udc57 , and \ud835\udc50 is a positive"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.720703125,
                            "y1": 333.8846435546875,
                            "y2": 403.22100830078125
                        },
                        "text": "constant [24]. Developers can easily implement customized peeling algorithms with Dupin, significantly reducing the engineering effort. Density Metrics Support in Dupin. To illustrate the versatility of Dupin in handling various density metrics, we establish comprehensive sufficient conditions. These conditions ensure Dupin\u2019s adaptability in integrating a wide range of metrics to assess graph density effectively. This foundational approach enablesDupin to sup-"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2036743164062,
                            "y1": 412.1356506347656,
                            "y2": 414.17999267578125
                        },
                        "text": "port diverse density calculations, crucial for nuanced fraud detection"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 413.9178161621094,
                            "y1": 423.09466552734375,
                            "y2": 425.1390075683594
                        },
                        "text": "and network analysis tasks."
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2000122070312,
                            "y1": 437.9367370605469,
                            "y2": 454.2980041503906
                        },
                        "text": "Property 3.1. Dupin supports a density metric \ud835\udc54(\ud835\udc46) if the following conditions are met:"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 323.8659973144531,
                            "x2": 375.41827392578125,
                            "y1": 460.79736328125,
                            "y2": 468.71600341796875
                        },
                        "text": "(1) \ud835\udc54(\ud835\udc46) = \ud835\udc53 (\ud835\udc46)"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 323.8659973144531,
                            "x2": 532.9423217773438,
                            "y1": 463.3137512207031,
                            "y2": 493.2850036621094
                        },
                        "text": "|\ud835\udc46 | , where \ud835\udc53 is a monotone increasing function. (2) \ud835\udc4e\ud835\udc56 \u2265 0, ensuring non-negative vertex weight function. (3) \ud835\udc50\ud835\udc56 \ud835\udc57 \u2265 0, ensuring non-negative edge weight function."
                    }
                ],
                "title": {
                    "page": 4,
                    "region": {
                        "x1": 53.79798889160156,
                        "x2": 179.19805908203125,
                        "y1": 238.69705200195312,
                        "y2": 245.5479736328125
                    },
                    "text": "3.2 System Architecture"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2063598632812,
                            "y1": 526.36669921875,
                            "y2": 528.4110107421875
                        },
                        "text": "For sequential peeling algorithms, only one vertex can be removed"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1983642578125,
                            "y1": 537.32568359375,
                            "y2": 539.3699951171875
                        },
                        "text": "at a time, with each vertex\u2019s removal depending on the removal"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2062377929688,
                            "y1": 548.28466796875,
                            "y2": 550.3289794921875
                        },
                        "text": "of previous vertices. This dependency prevents the algorithm from"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 501.3941345214844,
                            "y1": 559.24267578125,
                            "y2": 561.2869873046875
                        },
                        "text": "executing multiple vertex removals simultaneously."
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 322.9360046386719,
                            "x2": 558.4383544921875,
                            "y1": 570.20166015625,
                            "y2": 572.2459716796875
                        },
                        "text": "In this section, we introduce a parallel peeling paradigm to break"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2036743164062,
                            "y1": 581.1607055664062,
                            "y2": 583.2050170898438
                        },
                        "text": "this dependency chain. This new approach allowsmultiple vertices to"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.20361328125,
                            "y1": 592.1196899414062,
                            "y2": 605.1229858398438
                        },
                        "text": "be peeled in parallel without affecting the programming abstractions that Dupin provides to end users. We then demonstrate how this"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.71923828125,
                            "y1": 614.0377197265625,
                            "y2": 616.08203125
                        },
                        "text": "paradigm offers fine-grained trade-offs between parallelism and ap-"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 555.9659423828125,
                            "y1": 624.9967041015625,
                            "y2": 627.041015625
                        },
                        "text": "proximation guarantees for all density metrics studied in this work."
                    }
                ],
                "title": {
                    "page": 4,
                    "region": {
                        "x1": 312.97406005859375,
                        "x2": 538.8359375,
                        "y1": 507.8611145019531,
                        "y2": 514.7120361328125
                    },
                    "text": "4 PARALLELABLE PEELING ALGORITHMS"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.1862182617188,
                            "y1": 661.4676513671875,
                            "y2": 663.511962890625
                        },
                        "text": "Instead of peeling the vertex with the maximum peeling weight,"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 558.2047119140625,
                            "y1": 672.4266967773438,
                            "y2": 674.4710083007812
                        },
                        "text": "we can peel all vertices that lead to a significant decrease in the"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.4320678710938,
                            "y1": 683.3856811523438,
                            "y2": 685.4299926757812
                        },
                        "text": "density scores of the remaining graph. This decrease is controlled by"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2050170898438,
                            "y1": 692.4706420898438,
                            "y2": 696.3889770507812
                        },
                        "text": "a tunable parameter \ud835\udf16 . A larger \ud835\udf16 allows more vertices to be peeled"
                    },
                    {
                        "page": 4,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 557.0250244140625,
                            "y1": 703.4286499023438,
                            "y2": 707.3469848632812
                        },
                        "text": "in parallel, while a smaller \ud835\udf16 provides a better approximation ratio."
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 58.448001861572266,
                            "x2": 210.0728302001953,
                            "y1": 89.1621322631836,
                            "y2": 106.80902099609375
                        },
                        "text": "Algorithm 2: Dupin: Parallel Peeling Input:\ud835\udc3a = (\ud835\udc49 , \ud835\udc38), a density metric \ud835\udc54(\ud835\udc46), and \ud835\udf16 \u2265 0"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 63.76103210449219,
                            "x2": 263.311279296875,
                            "y1": 110.39944458007812,
                            "y2": 114.77899169921875
                        },
                        "text": "Output: A subset of vertices \ud835\udc46 that maximizes the density metric \ud835\udc54(\ud835\udc46)"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 56.71697998046875,
                            "x2": 286.2737731933594,
                            "y1": 117.91117858886719,
                            "y2": 187.3489990234375
                        },
                        "text": "1 \ud835\udc460 \u2190 \ud835\udc49 /* Initialize the subset with all vertices */ 2 \ud835\udc56 \u2190 1 /* Initialize the index */ 3 while \ud835\udc46\ud835\udc56\u22121 \u0338= \u2205 do 4 \ud835\udf0f = \ud835\udc58(1 + \ud835\udf16) \u00b7 \ud835\udc54(\ud835\udc46\ud835\udc56\u22121) /* The threshold for peeling */ 5 \ud835\udc48 \u2190 {\ud835\udc62 | \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 \ud835\udf0f } /* Vertices to be peeled */ 6 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56\u22121 \\\ud835\udc48 /* Update the subset */ 7 \ud835\udc56 \u2190 \ud835\udc56 + 1 /* Increment the index */ 8 return arg max\ud835\udc46\ud835\udc56 \ud835\udc54(\ud835\udc46\ud835\udc56 ) /* The subset that maximizes \ud835\udc54(\ud835\udc46) */"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 53.43998718261719,
                            "x2": 299.2005615234375,
                            "y1": 219.98109436035156,
                            "y2": 280.406005859375
                        },
                        "text": "Parallel Peeling (Algorithm 2). Let \ud835\udc46\ud835\udc56 denote the vertex set after the \ud835\udc56-th peeling iteration. Initially, \ud835\udc460 = \ud835\udc49 (Line 1). In each iteration, it removes a subset of vertices\ud835\udc48 from \ud835\udc46\ud835\udc56\u22121, where \u2200\ud835\udc62 \u2208 \ud835\udc48 ,\ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 \ud835\udc58(1 + \ud835\udf16)\ud835\udc54(\ud835\udc46\ud835\udc56\u22121). Parameter \ud835\udc58 is determined by the metric used. \ud835\udc58 = 2 works for DG, DW and FD. \ud835\udc58 = 3 works for TDS and \ud835\udc58 is the size of the cliques for \ud835\udc58CLiDS. This process is repeated recursively until no"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 53.529022216796875,
                            "x2": 299.0234069824219,
                            "y1": 287.4466857910156,
                            "y2": 314.6280212402344
                        },
                        "text": "vertices are left, resulting in a series of vertex sets \ud835\udc460, . . . , \ud835\udc46\ud835\udc45 , where \ud835\udc45 is the number of iterations. The algorithm then returns the set \ud835\udc46\ud835\udc56 (\ud835\udc56 \u2208 [0, \ud835\udc45]) that maximizes the density metric \ud835\udc54(\ud835\udc46\ud835\udc56 ), denoted as \ud835\udc46\ud835\udc5d ."
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.256591796875,
                            "y1": 691.1840209960938,
                            "y2": 707.3470458984375
                        },
                        "text": "In what follows, we also show a case where \ud835\udc58CLiDS is the density metric for DSD."
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 334.53271484375,
                            "x2": 363.485107421875,
                            "y1": 151.4757537841797,
                            "y2": 154.65093994140625
                        },
                        "text": "3 3"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 334.53271484375,
                            "x2": 363.485107421875,
                            "y1": 137.1033172607422,
                            "y2": 140.27850341796875
                        },
                        "text": "6 6"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 334.53271484375,
                            "x2": 363.485107421875,
                            "y1": 122.73081970214844,
                            "y2": 125.906005859375
                        },
                        "text": "5 4"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 334.5338134765625,
                            "x2": 363.4862060546875,
                            "y1": 108.35832214355469,
                            "y2": 111.53350830078125
                        },
                        "text": "21"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 323.75054931640625,
                            "x2": 363.4862060546875,
                            "y1": 93.98582458496094,
                            "y2": 100.754150390625
                        },
                        "text": "0 00"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 395.61578369140625,
                            "x2": 424.56817626953125,
                            "y1": 151.4757537841797,
                            "y2": 154.65093994140625
                        },
                        "text": "3 3"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 395.61578369140625,
                            "x2": 424.56817626953125,
                            "y1": 137.1033172607422,
                            "y2": 140.27850341796875
                        },
                        "text": "6 6"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 395.61578369140625,
                            "x2": 424.56817626953125,
                            "y1": 122.73081970214844,
                            "y2": 125.906005859375
                        },
                        "text": "3 3"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 456.69879150390625,
                            "x2": 485.65118408203125,
                            "y1": 137.1033172607422,
                            "y2": 140.27850341796875
                        },
                        "text": "0 0"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 323.75335693359375,
                            "x2": 491.2685852050781,
                            "y1": 162.2551727294922,
                            "y2": 165.43035888671875
                        },
                        "text": "Density: 0.91 Density: 1.33 Density: 0"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 323.75335693359375,
                            "x2": 558.271240234375,
                            "y1": 86.8537368774414,
                            "y2": 89.97479248046875
                        },
                        "text": "Iteration i Iteration i+1 Iteration i+2 Iteration i+3"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 514.1886596679688,
                            "x2": 548.7612915039062,
                            "y1": 162.2551727294922,
                            "y2": 165.43035888671875
                        },
                        "text": "Density: 0"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 312.97393798828125,
                            "x2": 535.9232177734375,
                            "y1": 173.03453063964844,
                            "y2": 176.209716796875
                        },
                        "text": "\u03c4 = 3\u00d7 0.91 = 2.73 \u03c4 = 3\u00d7 1.33 = 3.99 \u03c4 = 0 \u03c4 = 0"
                    }
                ],
                "title": {
                    "page": 4,
                    "region": {
                        "x1": 312.9739990234375,
                        "x2": 466.0941467285156,
                        "y1": 642.9620971679688,
                        "y2": 649.81298828125
                    },
                    "text": "4.1 Parallel Peeling Paradigm"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 5,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.204833984375,
                            "y1": 437.3696594238281,
                            "y2": 439.41400146484375
                        },
                        "text": "In this section, we analyze the theoretical properties of the parallel"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.198486328125,
                            "y1": 448.3276672363281,
                            "y2": 450.37200927734375
                        },
                        "text": "peeling process. We begin by examining the number of iterations"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2034912109375,
                            "y1": 459.2866516113281,
                            "y2": 461.33099365234375
                        },
                        "text": "required for parallel peeling. Built upon the result, we then determine"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1983642578125,
                            "y1": 470.24566650390625,
                            "y2": 472.2900085449219
                        },
                        "text": "the time complexity and the approximation ratio of the parallel"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 371.4619140625,
                            "y1": 481.20465087890625,
                            "y2": 483.2489929199219
                        },
                        "text": "peeling process."
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 322.93701171875,
                            "x2": 482.5676574707031,
                            "y1": 495.18475341796875,
                            "y2": 504.02197265625
                        },
                        "text": "Lemma 4.1. Given any \ud835\udf16 > 0, \ud835\udc45 < log 1+\ud835\udf16 |\ud835\udc49 |."
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 322.9360046386719,
                            "x2": 558.2017822265625,
                            "y1": 517.1317749023438,
                            "y2": 523.4710083007812
                        },
                        "text": "Proof. We prove that for any \ud835\udf16 \u2265 0, the size of the remaining"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 312.75,
                            "x2": 518.2936401367188,
                            "y1": 528.2528076171875,
                            "y2": 537.6849975585938
                        },
                        "text": "vertex set is bounded by |\ud835\udc46\ud835\udc56 |< 1 1+\ud835\udf16 |\ud835\udc46\ud835\udc56\u22121 | for all \ud835\udc56 \u2208 [1, \ud835\udc45]."
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2031860351562,
                            "y1": 541.6326904296875,
                            "y2": 556.510009765625
                        },
                        "text": "We first examine the peeling weights of the vertices in \ud835\udc46\ud835\udc56\u22121 for the density metrics DG. DW and FD where \ud835\udc58 = 2. As each edge weight"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 312.7049865722656,
                            "x2": 559.1605834960938,
                            "y1": 565.4246826171875,
                            "y2": 650.9329833984375
                        },
                        "text": "in the peeling weight calculation contributes twice (once for each endpoint), and the vertex weights contribute once, we have\u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56\u22121 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 2\ud835\udc53 (\ud835\udc46\ud835\udc56\u22121), (3) The peeling weights of the vertices in \ud835\udc46\ud835\udc56\u22121 are calculated as follows:\u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56\u22121 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) = \u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56\u22121\\\ud835\udc46\ud835\udc56 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) + \u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121)"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 398.4660339355469,
                            "x2": 529.5339965820312,
                            "y1": 636.1599731445312,
                            "y2": 674.2050170898438
                        },
                        "text": "\u2265 \u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) > 2(1 + \ud835\udf16)|\ud835\udc46\ud835\udc56 |\ud835\udc54(\ud835\udc46\ud835\udc56\u22121)"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 548.68798828125,
                            "x2": 558.2013549804688,
                            "y1": 653.9556884765625,
                            "y2": 656.0
                        },
                        "text": "(4)"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 489.4240417480469,
                            "y1": 687.293701171875,
                            "y2": 689.3380126953125
                        },
                        "text": "Combining Equation 3 and Equation 4, we have:"
                    },
                    {
                        "page": 5,
                        "region": {
                            "x1": 353.9679870605469,
                            "x2": 558.201416015625,
                            "y1": 701.0077514648438,
                            "y2": 708.6920166015625
                        },
                        "text": "2(1 + \ud835\udf16)|\ud835\udc46\ud835\udc56 |\ud835\udc54(\ud835\udc46\ud835\udc56\u22121) < 2\ud835\udc53 (\ud835\udc46\ud835\udc56\u22121) = 2|\ud835\udc46\ud835\udc56\u22121 |\ud835\udc54(\ud835\udc46\ud835\udc56\u22121) (5)"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 113.21161651611328,
                            "y1": 87.30973815917969,
                            "y2": 93.64898681640625
                        },
                        "text": "For all \ud835\udc56 \u2208 [1, \ud835\udc45],"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 146.5540008544922,
                            "x2": 299.0263671875,
                            "y1": 101.03561401367188,
                            "y2": 115.301025390625
                        },
                        "text": "|\ud835\udc46\ud835\udc56 |< 1 1 + \ud835\udf16 |\ud835\udc46\ud835\udc56\u22121 | (6)"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.52900695800781,
                            "x2": 107.12117004394531,
                            "y1": 123.56967163085938,
                            "y2": 125.614013671875
                        },
                        "text": "Then we have:"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 103.50100708007812,
                            "x2": 299.0263671875,
                            "y1": 135.21267700195312,
                            "y2": 149.47802734375
                        },
                        "text": "|\ud835\udc49 |= |\ud835\udc460 |> 1 1 + \ud835\udf16 |\ud835\udc461 |> . . . > ( 1 1 + \ud835\udf16 ) \ud835\udc45 |\ud835\udc46\ud835\udc45 | (7)"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.52900695800781,
                            "x2": 178.4145965576172,
                            "y1": 155.5537567138672,
                            "y2": 164.3900146484375
                        },
                        "text": "Therefore, we have \ud835\udc45 < log 1+\ud835\udf16 |\ud835\udc49 |."
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0266418457031,
                            "y1": 167.64698791503906,
                            "y2": 183.81097412109375
                        },
                        "text": "For the density metrics TDS and \ud835\udc58CLiDS, we use the fact that each edge contributes to the peeling weight calculation exactly \ud835\udc58 times"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.52899932861328,
                            "x2": 299.0294494628906,
                            "y1": 190.8506622314453,
                            "y2": 205.72802734375
                        },
                        "text": "due to the counting of each edge within every \ud835\udc58-Clique in the graph (\ud835\udc58 = 3 for TDS). This multiplicity of edge contributions leads to the"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0263977050781,
                            "y1": 201.3179931640625,
                            "y2": 239.364013671875
                        },
                        "text": "relationship: \u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56\u22121 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 \ud835\udc58 \ud835\udc53 (\ud835\udc46\ud835\udc56\u22121), (8)"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 56.04002380371094,
                            "x2": 299.02667236328125,
                            "y1": 245.99908447265625,
                            "y2": 250.55401611328125
                        },
                        "text": "We then adapt Equations 4-7 and the proof follows. \u25a1"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.50199890136719,
                            "x2": 299.5644226074219,
                            "y1": 264.54376220703125,
                            "y2": 292.8009948730469
                        },
                        "text": "Time Complexity. Algorithm 2 operates for at most \ud835\udc45 = log 1+\ud835\udf16 |\ud835\udc49 | iterations, with each iteration scanning all vertices, taking \ud835\udc42(|\ud835\udc49 |) time. As vertices are peeled, updates are necessitated for the peeling"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 300.5417175292969,
                            "y1": 299.8417053222656,
                            "y2": 325.6780090332031
                        },
                        "text": "weights of their neighboring vertices. Over the course of \ud835\udc45 iterations, there are no more than |\ud835\udc38 | such updates for DG, DW and FD. Consequently, Algorithm 3 incurs \ud835\udc42((|\ud835\udc38 |+|\ud835\udc49 |) log"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 299.1973876953125,
                            "y1": 319.3387756347656,
                            "y2": 359.0899963378906
                        },
                        "text": "1+\ud835\udf16 |\ud835\udc49 |) node/edge weight updates. For DG, DW and FD, the update costs are \ud835\udc42(1). For TDS and \ud835\udc58CLiDS, we follow previous studies [11, 14] to compute the peeling weights, and the complexity is \ud835\udc42(\ud835\udc58 |\ud835\udc38 |\ud835\udefc(\ud835\udc3a) \ud835\udc58\u22122 ), where"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.57400131225586,
                            "x2": 299.2603454589844,
                            "y1": 366.1307067871094,
                            "y2": 381.5429992675781
                        },
                        "text": "\ud835\udefc(\ud835\udc3a) is the arboricity of the graph. Hence, the overall complexity is \ud835\udc42(\ud835\udc58 |\ud835\udc38 |\ud835\udefc(\ud835\udc3a) \ud835\udc58\u22122"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 115.09700012207031,
                            "x2": 300.5458984375,
                            "y1": 375.2037658691406,
                            "y2": 384.0409851074219
                        },
                        "text": "(|\ud835\udc38 |+|\ud835\udc49 |) log 1+\ud835\udf16 |\ud835\udc49 |). The cost of peeling weight up-"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 299.1966247558594,
                            "y1": 387.2970275878906,
                            "y2": 450.17999267578125
                        },
                        "text": "dates is orthogonal to the Dupin framework. Approximation Ratio. Next, we are ready to show that Dupin provides a theoretical guarantee with a \ud835\udc58(1 + \ud835\udf16)-approximation for all density metrics studied in this work. We denote \ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\ud835\udc5d as the first vertex in \ud835\udc46\u2217 peeled by Dupin, and \ud835\udc46 \u2032 as the peeling subsequence starting from \ud835\udc62\ud835\udc56 ."
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02239990234375,
                            "y1": 459.5353698730469,
                            "y2": 478.93701171875
                        },
                        "text": "Theorem 4.2. For the vertex set \ud835\udc46\ud835\udc5d returned by Dupin and the optimal vertex set \ud835\udc46\u2217, the relationship \ud835\udc54(\ud835\udc46\ud835\udc5d ) \u2265 \ud835\udc54(\ud835\udc46\u2217)"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 219.9949951171875,
                            "x2": 263.6799621582031,
                            "y1": 473.5347595214844,
                            "y2": 482.51300048828125
                        },
                        "text": "\ud835\udc58(1+\ud835\udf16) holds."
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0287780761719,
                            "y1": 490.9772033691406,
                            "y2": 521.291015625
                        },
                        "text": "Proof. We first prove that \u2200\ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\u2217, \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2265 \ud835\udc54(\ud835\udc46\u2217). We prove it in contradiction. We assume that \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) < \ud835\udc54(\ud835\udc46\u2217). By peeling \ud835\udc62\ud835\udc56 from \ud835\udc46\u2217, we have the following."
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 82.04202270507812,
                            "x2": 131.68719482421875,
                            "y1": 533.6762084960938,
                            "y2": 543.8660278320312
                        },
                        "text": "\ud835\udc54(\ud835\udc46\u2217 \\ {\ud835\udc62\ud835\udc56 }) ="
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 135.8200225830078,
                            "x2": 191.11000061035156,
                            "y1": 527.5962524414062,
                            "y2": 538.4290161132812
                        },
                        "text": "\ud835\udc53 (\ud835\udc46\u2217) \u2212\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 )"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 151.92999267578125,
                            "x2": 174.91134643554688,
                            "y1": 540.938232421875,
                            "y2": 548.6719970703125
                        },
                        "text": "|\ud835\udc46\u2217 |\u22121"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 194.98497009277344,
                            "x2": 249.84994506835938,
                            "y1": 527.9682006835938,
                            "y2": 542.52099609375
                        },
                        "text": "> \ud835\udc53 (\ud835\udc46\u2217) \u2212 \ud835\udc54(\ud835\udc46\ud835\udc56 )"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 215.8990020751953,
                            "x2": 238.88037109375,
                            "y1": 540.938232421875,
                            "y2": 548.6719970703125
                        },
                        "text": "|\ud835\udc46\u2217 |\u22121"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 126.75399780273438,
                            "x2": 190.60250854492188,
                            "y1": 558.5912475585938,
                            "y2": 579.2940063476562
                        },
                        "text": "= \ud835\udc53 (\ud835\udc46\u2217) \u2212 \ud835\udc54(\ud835\udc46\u2217) |\ud835\udc46\u2217 |\u22121 ="
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 194.7369842529297,
                            "x2": 240.0332489013672,
                            "y1": 552.7889404296875,
                            "y2": 567.6530151367188
                        },
                        "text": "\ud835\udc53 (\ud835\udc46\u2217) \u2212 \ud835\udc53 (\ud835\udc46\u2217) |\ud835\udc46\u2217 |"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 206.44700622558594,
                            "x2": 229.42837524414062,
                            "y1": 571.5612182617188,
                            "y2": 579.2940063476562
                        },
                        "text": "|\ud835\udc46\u2217 |\u22121"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 244.91500854492188,
                            "x2": 270.3340148925781,
                            "y1": 564.2982177734375,
                            "y2": 573.1430053710938
                        },
                        "text": "= \ud835\udc54(\ud835\udc46\u2217)"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 289.5130310058594,
                            "x2": 299.0263977050781,
                            "y1": 555.502685546875,
                            "y2": 557.5469970703125
                        },
                        "text": "(9)"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 300.0121765136719,
                            "y1": 585.2451782226562,
                            "y2": 617.9949951171875
                        },
                        "text": "Therefore, a better solution can be obtained by removing \ud835\udc62\ud835\udc56 from \ud835\udc46\u2217, which contradicts the fact that \ud835\udc46\u2217 is the optimal solution. We can conclude that\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2265 \ud835\udc54(\ud835\udc46\u2217)."
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 63.76100158691406,
                            "x2": 299.2610168457031,
                            "y1": 618.1212158203125,
                            "y2": 627.863037109375
                        },
                        "text": "Next, we assume that \ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\ud835\udc5d is the first vertex in \ud835\udc46\u2217 peeled by"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 291.668212890625,
                            "y1": 629.0802001953125,
                            "y2": 637.4769897460938
                        },
                        "text": "the peeling algorithm. Since \ud835\udc46\u2217 is the optimal vertex set, we have"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 146.89698791503906,
                            "x2": 299.0257263183594,
                            "y1": 644.6162109375,
                            "y2": 655.89697265625
                        },
                        "text": "\ud835\udc54(\ud835\udc46\u2217) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ), (10)"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 299.0306396484375,
                            "y1": 661.0491943359375,
                            "y2": 691.3629760742188
                        },
                        "text": "because the optimal value \ud835\udc54(\ud835\udc46\u2217) must be less than or equal to the weight contribution of any single vertex in \ud835\udc46\u2217, in particular \ud835\udc62\ud835\udc56 . Since \ud835\udc46\u2217 \u2286 \ud835\udc46 \u2032, it is clear that"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 143.66299438476562,
                            "x2": 299.0267333984375,
                            "y1": 698.502197265625,
                            "y2": 709.7830200195312
                        },
                        "text": "\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) (11)"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 437.4188537597656,
                            "y1": 91.60470581054688,
                            "y2": 93.6490478515625
                        },
                        "text": "By the peeling condition, we have"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 394.2120056152344,
                            "x2": 558.2017822265625,
                            "y1": 99.62022399902344,
                            "y2": 110.9010009765625
                        },
                        "text": "\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) \u2264 \ud835\udc58(1 + \ud835\udf16)\ud835\udc54(\ud835\udc46 \u2032) (12)"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.7050476074219,
                            "x2": 383.0466003417969,
                            "y1": 121.23770141601562,
                            "y2": 123.28204345703125
                        },
                        "text": "Therefore, we have"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 324.96405029296875,
                            "x2": 558.2019653320312,
                            "y1": 129.25425720214844,
                            "y2": 140.5350341796875
                        },
                        "text": "\ud835\udc54(\ud835\udc46\u2217) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) \u2264 \ud835\udc58(1 + \ud835\udf16)\ud835\udc54(\ud835\udc46 \u2032) \u2264 \ud835\udc58(1 + \ud835\udf16)\ud835\udc54(\ud835\udc46\ud835\udc5d ) (13)"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9742431640625,
                            "x2": 558.20166015625,
                            "y1": 144.0380401611328,
                            "y2": 158.88397216796875
                        },
                        "text": "Hence, we can conclude that \ud835\udc54(\ud835\udc46\ud835\udc5d ) \u2265 \ud835\udc54(\ud835\udc46\u2217) \ud835\udc58(1+\ud835\udf16) . \u25a1"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.201904296875,
                            "y1": 169.42909240722656,
                            "y2": 175.05999755859375
                        },
                        "text": "Summary. Dupin can easily balance efficiency and the worst-case"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.20068359375,
                            "y1": 182.1006622314453,
                            "y2": 186.01898193359375
                        },
                        "text": "approximation ratio with a single parameter, \ud835\udf16 . A larger \ud835\udf16 allows"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2037353515625,
                            "y1": 194.93368530273438,
                            "y2": 196.97802734375
                        },
                        "text": "more vertices to be peeled in parallel, reducing the number of peeling"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2035522460938,
                            "y1": 205.89266967773438,
                            "y2": 207.93701171875
                        },
                        "text": "iterations. Meanwhile, the worst-case approximation ratio of parallel"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1998291015625,
                            "y1": 214.97767639160156,
                            "y2": 229.85400390625
                        },
                        "text": "peeling is only affected by a factor of (1 + \ud835\udf16) compared to the ratio for sequential peeling w.r.t. all density metrics studied in this work."
                    }
                ],
                "title": {
                    "page": 5,
                    "region": {
                        "x1": 312.9739990234375,
                        "x2": 439.9231872558594,
                        "y1": 418.86407470703125,
                        "y2": 425.7149963378906
                    },
                    "text": "4.2 Theoretical Analysis"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.5429992675781,
                            "x2": 559.7192993164062,
                            "y1": 262.6906433105469,
                            "y2": 264.7349853515625
                        },
                        "text": "We observe that the parallel peeling algorithm encounters two sig-"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2034301757812,
                            "y1": 273.6496276855469,
                            "y2": 275.6939697265625
                        },
                        "text": "nificant issues. First, there is a long-tail problem where subsequent"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1978149414062,
                            "y1": 284.6086730957031,
                            "y2": 286.65301513671875
                        },
                        "text": "iterations fail to produce denser subgraphs. Instead, each iteration"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.20361328125,
                            "y1": 295.5676574707031,
                            "y2": 297.61199951171875
                        },
                        "text": "only peels off a small fraction of vertices, which significantly impacts"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1983642578125,
                            "y1": 306.52667236328125,
                            "y2": 308.5710144042969
                        },
                        "text": "the overall runtime efficiency. Second, during batch peeling, each"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.715576171875,
                            "y1": 317.48565673828125,
                            "y2": 319.5299987792969
                        },
                        "text": "peeling iteration often results in disparate structures. These are pri-"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.3677368164062,
                            "y1": 328.4446716308594,
                            "y2": 330.489013671875
                        },
                        "text": "marily caused by the peeling of certain vertices, which leaves their"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7163696289062,
                            "y1": 339.4036560058594,
                            "y2": 341.447998046875
                        },
                        "text": "neighboring structure disconnected and fragmented. This phenome-"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 527.5133056640625,
                            "y1": 350.3616638183594,
                            "y2": 352.406005859375
                        },
                        "text": "non affects the continuity and coherence of the subgraphs."
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.43115234375,
                            "y1": 358.8280029296875,
                            "y2": 374.3240051269531
                        },
                        "text": "As shown in Table 2, on the la dataset (the largest social network dataset tested in our experiments), DG, DW, and FD experience"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.1878662109375,
                            "y1": 383.2386474609375,
                            "y2": 385.2829895019531
                        },
                        "text": "24.67%, 46.84%, and 3.01% of rounds as ineffective long-tail iterations,"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1984252929688,
                            "y1": 394.1976623535156,
                            "y2": 396.24200439453125
                        },
                        "text": "severely limiting response time. Additionally, during the peeling"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.1839599609375,
                            "y1": 403.2826843261719,
                            "y2": 407.20098876953125
                        },
                        "text": "process, if the batch size is large (e.g., \ud835\udf16 = 0.5), approximately 25.34%,"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7206420898438,
                            "y1": 416.11566162109375,
                            "y2": 418.1600036621094
                        },
                        "text": "29.46%, and 7.16% of nodes become disconnected and sparse, signifi-"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 514.5029296875,
                            "y1": 427.07464599609375,
                            "y2": 429.1189880371094
                        },
                        "text": "cantly impacting the quality of the detected subgraphs."
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7213134765625,
                            "y1": 584.7556762695312,
                            "y2": 619.676025390625
                        },
                        "text": "To address the challenges of high iteration counts in peeling algorithms, Dupin introduces two long-tail pruning techniques: Global Peeling Optimization (GPO) to maintain a global peeling threshold, and Local Peeling Optimization (LPO) to improve the density of the"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2001342773438,
                            "y1": 628.5906982421875,
                            "y2": 641.593994140625
                        },
                        "text": "current peeling iteration\u2019s subgraph, thereby increasing the peeling threshold. We tested three algorithms, DG, DW, and FD, and found"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.187744140625,
                            "y1": 650.5086669921875,
                            "y2": 652.552978515625
                        },
                        "text": "that they required 17,637, 150,223, and 112,074 iterations respectively,"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 559.7138061523438,
                            "y1": 661.4676513671875,
                            "y2": 663.511962890625
                        },
                        "text": "which is significantly high. By strategically pruning long-tail ver-"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.4320678710938,
                            "y1": 672.4266967773438,
                            "y2": 685.4299926757812
                        },
                        "text": "tices and sparse vertices, the number of iterations can be reduced by up to 46.84%. Additionally, LPO can further reduce the number of"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2034301757812,
                            "y1": 694.3446655273438,
                            "y2": 696.3889770507812
                        },
                        "text": "iterations by up to 92.79%. These optimizations significantly enhance"
                    },
                    {
                        "page": 6,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 548.44970703125,
                            "y1": 705.3026733398438,
                            "y2": 707.3469848632812
                        },
                        "text": "the efficiency of the peeling process, as discussed in this section."
                    }
                ],
                "title": {
                    "page": 6,
                    "region": {
                        "x1": 312.9739990234375,
                        "x2": 441.483154296875,
                        "y1": 244.18606567382812,
                        "y2": 251.0369873046875
                    },
                    "text": "5 LONG-TAIL PRUNING"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 7,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02593994140625,
                            "y1": 273.2087707519531,
                            "y2": 278.61102294921875
                        },
                        "text": "Initially, we define what constitutes a long-tail vertex during the"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0262145996094,
                            "y1": 287.5256652832031,
                            "y2": 289.57000732421875
                        },
                        "text": "peeling process. Peeling these long-tail vertices results in ineffective"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0251770019531,
                            "y1": 298.4846496582031,
                            "y2": 300.52899169921875
                        },
                        "text": "peeling iterations. To address this, we maintain a global maximum"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.4072570800781,
                            "y1": 309.44366455078125,
                            "y2": 311.4880065917969
                        },
                        "text": "peeling threshold to determine which vertices can be peeled directly."
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 53.36800003051758,
                            "x2": 300.5406494140625,
                            "y1": 320.40264892578125,
                            "y2": 322.4469909667969
                        },
                        "text": "When the global peeling threshold is greater than the current itera-"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 289.13018798828125,
                            "y1": 331.3616638183594,
                            "y2": 333.406005859375
                        },
                        "text": "tion\u2019s threshold, we use the global peeling threshold for peeling."
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 58.448001861572266,
                            "x2": 261.8049621582031,
                            "y1": 345.47210693359375,
                            "y2": 351.1029968261719
                        },
                        "text": "Algorithm 3: DupinGPO: Global Peeling Optimization"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 63.76100158691406,
                            "x2": 267.3793029785156,
                            "y1": 357.9772033691406,
                            "y2": 371.18499755859375
                        },
                        "text": "Input:\ud835\udc3a = (\ud835\udc49 , \ud835\udc38), a density metric \ud835\udc54(\ud835\udc46), and \ud835\udf16 \u2265 0 Output: A subset of vertices \ud835\udc46\ud835\udc5d that maximizes the density metric \ud835\udc54(\ud835\udc46)"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 56.717041015625,
                            "x2": 286.2723388671875,
                            "y1": 374.31622314453125,
                            "y2": 400.72802734375
                        },
                        "text": "1 \ud835\udc460 \u2190 \ud835\udc49 /* Initialize the subset with all vertices */ 2 \ud835\udc56 \u2190 1 3 \ud835\udf0fmax \u2190 \ud835\udc54(\ud835\udc46 0 )"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 89.28800201416016,
                            "x2": 286.2729187011719,
                            "y1": 396.1082458496094,
                            "y2": 402.22100830078125
                        },
                        "text": "\ud835\udc58(1+\ud835\udf16) /* Initialize the threshold */"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 56.717002868652344,
                            "x2": 286.2737121582031,
                            "y1": 404.7611999511719,
                            "y2": 457.24896240234375
                        },
                        "text": "4 while \ud835\udc46\ud835\udc56\u22121 \u0338= \u2205 do 5 \ud835\udf0f \u2190 max{\ud835\udf0fmax, \ud835\udc58(1 + \ud835\udf16) \u00b7 \ud835\udc54(\ud835\udc46\ud835\udc56\u22121)} /* Peeling threshold */ 6 \ud835\udc48 \u2190 {\ud835\udc62 | \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 \ud835\udf0f } /* Vertices to be peeled */ 7 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56\u22121 \\\ud835\udc48 /* Update the subset */ 8 \ud835\udf0fmax = max{\ud835\udf0fmax, \ud835\udc54(\ud835\udc46\ud835\udc56 ) \ud835\udc58(1+\ud835\udf16) } /* Refine the threshold */ 9 \ud835\udc56 \u2190 \ud835\udc56 + 1"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 54.15700912475586,
                            "x2": 286.2738037109375,
                            "y1": 461.83642578125,
                            "y2": 468.74298095703125
                        },
                        "text": "10 return arg max\ud835\udc46\ud835\udc56 \ud835\udc54(\ud835\udc46\ud835\udc56 ) /* The subset that maximizes \ud835\udc54(\ud835\udc46) */"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0259704589844,
                            "y1": 487.05474853515625,
                            "y2": 516.39404296875
                        },
                        "text": "Definition 5.1 (Long-Tail vertex). Given an \ud835\udefc-\ud835\udc4e\ud835\udc5d\ud835\udc5d\ud835\udc5f\ud835\udc5c\ud835\udc65\ud835\udc56\ud835\udc5a\ud835\udc4e\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b DSD algorithm and a set of vertices \ud835\udc46 \u2286 \ud835\udc49 , if\ud835\udc64\ud835\udc62 (\ud835\udc46) < \ud835\udc54(\ud835\udc46\u2217) \ud835\udefc and \ud835\udc46\u2217 is the optimal vertex set, then \ud835\udc62 is a long-tail vertex."
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 63.76100158691406,
                            "x2": 264.9716491699219,
                            "y1": 526.7953491210938,
                            "y2": 534.5590209960938
                        },
                        "text": "Lemma 5.1. If \u2203\ud835\udc62 \u2208 \ud835\udc46\ud835\udc56 is a long-tail vertex, then \ud835\udc46\ud835\udc56 \u0338= \ud835\udc46\ud835\udc43 ."
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 53.2599983215332,
                            "x2": 300.40704345703125,
                            "y1": 544.4243774414062,
                            "y2": 576.0650024414062
                        },
                        "text": "Proof. We prove it in contradiction by assuming that \ud835\udc46\ud835\udc56 = \ud835\udc46\ud835\udc43 . Since \ud835\udc62 is a long-tail vertex in \ud835\udc46\ud835\udc56 ,\ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56 ) < \ud835\udc54(\ud835\udc46\u2217) \ud835\udefc < \ud835\udc54(\ud835\udc46\ud835\udc43 ). By peeling \ud835\udc62 from \ud835\udc46\ud835\udc43 , we have the following."
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 90.7909927368164,
                            "x2": 138.83615112304688,
                            "y1": 590.6463623046875,
                            "y2": 597.5130004882812
                        },
                        "text": "\ud835\udc54(\ud835\udc46\ud835\udc43 \\ {\ud835\udc62}) ="
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 142.968994140625,
                            "x2": 198.06898498535156,
                            "y1": 584.9393920898438,
                            "y2": 592.7030029296875
                        },
                        "text": "\ud835\udc53 (\ud835\udc46\ud835\udc43 ) \u2212\ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc43 )"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 158.42100524902344,
                            "x2": 182.52638244628906,
                            "y1": 597.9927978515625,
                            "y2": 604.33203125
                        },
                        "text": "|\ud835\udc46\ud835\udc43 |\u22121"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 201.94300842285156,
                            "x2": 260.3890075683594,
                            "y1": 584.9393920898438,
                            "y2": 597.5130004882812
                        },
                        "text": "> \ud835\udc53 (\ud835\udc46\ud835\udc43 ) \u2212 \ud835\udc54(\ud835\udc46\ud835\udc43 )"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 224.08599853515625,
                            "x2": 248.1913604736328,
                            "y1": 597.9927978515625,
                            "y2": 604.33203125
                        },
                        "text": "|\ud835\udc46\ud835\udc43 |\u22121"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 133.90298461914062,
                            "x2": 138.83450317382812,
                            "y1": 628.4166870117188,
                            "y2": 630.4609985351562
                        },
                        "text": "="
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 142.96897888183594,
                            "x2": 190.6882781982422,
                            "y1": 611.0433959960938,
                            "y2": 620.822998046875
                        },
                        "text": "\ud835\udc53 (\ud835\udc46\ud835\udc43 ) \u2212 \ud835\udc53 (\ud835\udc46\ud835\udc43 )"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 155.32899475097656,
                            "x2": 222.11196899414062,
                            "y1": 619.8281860351562,
                            "y2": 637.280029296875
                        },
                        "text": "|\ud835\udc46\ud835\udc43 | |\ud835\udc46\ud835\udc43 |\u22121 = \ud835\udc54(\ud835\udc46\ud835\udc43 )"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 285.343994140625,
                            "x2": 299.0267333984375,
                            "y1": 611.4447021484375,
                            "y2": 613.489013671875
                        },
                        "text": "(14)"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 53.48400115966797,
                            "x2": 300.5442199707031,
                            "y1": 645.8003540039062,
                            "y2": 664.7050170898438
                        },
                        "text": "A denser subgraph can be obtained by peeling \ud835\udc62 from \ud835\udc46\ud835\udc43 . This contradicts that \ud835\udc46\ud835\udc43 is the optimal solution. Hence, \ud835\udc46\ud835\udc56 \u0338= \ud835\udc46\ud835\udc43 . \u25a1"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0233459472656,
                            "y1": 676.6961059570312,
                            "y2": 682.3270263671875
                        },
                        "text": "Identifying Long-Tail Vertices. Based on Lemma 5.2, we can also"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 53.36800003051758,
                            "x2": 299.0294189453125,
                            "y1": 689.36767578125,
                            "y2": 709.8629760742188
                        },
                        "text": "establish that a vertex\ud835\udc62 in set \ud835\udc46 can be classified as a long-tail vertex if \ud835\udc64\ud835\udc62 (\ud835\udc46) < \ud835\udc54(\ud835\udc46\u2217) \ud835\udc58(1+\ud835\udf16) . This insight allows us to implement a global peeling"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 554.38525390625,
                            "y1": 85.72937774658203,
                            "y2": 94.99395751953125
                        },
                        "text": "threshold, denoted as \ud835\udf0fmax. During each iteration, we compare \ud835\udc54(\ud835\udc46\ud835\udc56 )"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 537.3189697265625,
                            "x2": 557.0061645507812,
                            "y1": 94.06134796142578,
                            "y2": 97.2249755859375
                        },
                        "text": "\ud835\udc58(1+\ud835\udf16)"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 558.2015380859375,
                            "y1": 100.64498138427734,
                            "y2": 107.1949462890625
                        },
                        "text": "with \ud835\udf0fmax. If the former exceeds the latter, Dupin updates \ud835\udf0fmax to"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 316.427001953125,
                            "x2": 330.94427490234375,
                            "y1": 110.89838409423828,
                            "y2": 115.15301513671875
                        },
                        "text": "\ud835\udc54(\ud835\udc46\ud835\udc56 )"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2049560546875,
                            "y1": 116.77365112304688,
                            "y2": 132.7979736328125
                        },
                        "text": "\ud835\udc58(1+\ud835\udf16) , thereby enhancing the efficiency of the peeling. Peeling with Global Threshold (Algorithm 3). Using FD as an"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 312.7049865722656,
                            "x2": 558.2048950195312,
                            "y1": 139.8386993408203,
                            "y2": 189.60198974609375
                        },
                        "text": "example, we can set \ud835\udc58 to 2. In Lemma 5.2, we recognize that long-tail vertices in set \ud835\udc46\ud835\udc56 can be peeled directly during iteration \ud835\udc56 for FD. To facilitate this, Dupin initiates with a global peeling threshold \ud835\udf0fmax (Line 3). After identifying a denser subgraph post-peeling, \ud835\udf0fmax is updated to \ud835\udc54(\ud835\udc46\ud835\udc56 )"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 355.5580139160156,
                            "x2": 513.2818603515625,
                            "y1": 187.55770874023438,
                            "y2": 193.1500244140625
                        },
                        "text": "2(1+\ud835\udf16) , refining the peeling process (Line 8)."
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 322.61199951171875,
                            "x2": 548.3616333007812,
                            "y1": 212.19174194335938,
                            "y2": 360.05902099609375
                        },
                        "text": "Example 5.1. In the initial depiction provided in the leftmost panel of Figure 6 (the \ud835\udc56-th iteration), the density of the graph is 4.28. Traditionally, this scenario would necessitate two additional iterations to complete the peeling process, which could notably increase computational time. As illustrated, vertex \ud835\udc62 cannot be peeled in the (\ud835\udc56 + 1)-th iteration and would typically require an extra iteration, the (\ud835\udc56 + 2)-th, for its removal. However, Dupin can promptly peel vertices that fall below this threshold by employing our algorithm\u2019s global peeling threshold, which is calculated as half of the current density (\ud835\udf0fmax = 4.28/2 = 2.14). This approach enables the simultaneous peeling of three nodes in the (\ud835\udc56 + 1)-th iteration. Without this pruning strategy, an additional iteration would be essential to peel vertex \ud835\udc62, underscoring our method\u2019s enhanced efficiency in the peeling process."
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 322.9360046386719,
                            "x2": 558.200439453125,
                            "y1": 384.54864501953125,
                            "y2": 386.5929870605469
                        },
                        "text": "This optimization obviates the necessity for a prolonged iterative"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7147216796875,
                            "y1": 395.5076599121094,
                            "y2": 397.552001953125
                        },
                        "text": "sequence. The example herein substantiates the efficacy of our tai-"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2034912109375,
                            "y1": 406.4666442871094,
                            "y2": 408.510986328125
                        },
                        "text": "lored optimization for long-tail distribution, substantially enhancing"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 426.0672607421875,
                            "y1": 417.4256591796875,
                            "y2": 419.4700012207031
                        },
                        "text": "the algorithm\u2019s time efficiency."
                    }
                ],
                "title": {
                    "page": 7,
                    "region": {
                        "x1": 53.79800033569336,
                        "x2": 219.16900634765625,
                        "y1": 258.0621032714844,
                        "y2": 264.91302490234375
                    },
                    "text": "5.1 Global Peeling Optimization"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 7,
                        "region": {
                            "x1": 317.62298583984375,
                            "x2": 514.8751220703125,
                            "y1": 466.8021240234375,
                            "y2": 472.4330139160156
                        },
                        "text": "Algorithm 4: DupinLPO: Local Peeling Optimization"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 322.93597412109375,
                            "x2": 514.1571655273438,
                            "y1": 479.3072204589844,
                            "y2": 492.5150146484375
                        },
                        "text": "Input: A graph\ud835\udc3a = (\ud835\udc49 , \ud835\udc38), a density metric \ud835\udc54(\ud835\udc46), and \ud835\udf16 \u2265 0 Output: A subset of vertices \ud835\udc46\ud835\udc5d representing the densest subgraph"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 315.8929748535156,
                            "x2": 545.4485473632812,
                            "y1": 495.59423828125,
                            "y2": 513.0390625
                        },
                        "text": "1 \ud835\udc460 \u2190 \ud835\udc49 /* Initialize the subset with all vertices */ 2 \ud835\udf0fmax \u2190 \ud835\udc54(\ud835\udc46 0 )"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 348.4639892578125,
                            "x2": 545.4489135742188,
                            "y1": 508.42022705078125,
                            "y2": 514.532958984375
                        },
                        "text": "\ud835\udc58(1+\ud835\udf16) /* Initialize the threshold */"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 313.3329772949219,
                            "x2": 545.4497680664062,
                            "y1": 517.0731811523438,
                            "y2": 606.9580078125
                        },
                        "text": "3 while \ud835\udc46\ud835\udc56\u22121 \u0338= \u2205 do 4 \ud835\udf0f1 \u2190 max{\ud835\udf0fmax, \ud835\udc58(1 + \ud835\udf16) \u00b7 \ud835\udc54(\ud835\udc46\ud835\udc56\u22121)} /* Peeling threshold */ 5 \ud835\udc481 \u2190 {\ud835\udc62 \u2208 \ud835\udc46 | \ud835\udc64\ud835\udc62 (\ud835\udc46) \u2264 \ud835\udf0f1 } 6 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56\u22121 \\\ud835\udc481 7 while \u2203\ud835\udc62 \u2208 \ud835\udc46\ud835\udc56 , \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56 ) < \ud835\udc54(\ud835\udc46\ud835\udc56 ) do 8 \ud835\udf0f2 \u2190 max{\ud835\udf0fmax, \ud835\udc54(\ud835\udc46\ud835\udc56 )} /* Update the threshold */ 9 \ud835\udc482 \u2190 {\ud835\udc62 | \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56 ) < \ud835\udf0f2 } 10 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56 \\\ud835\udc482 11 \ud835\udf0fmax = max{\ud835\udf0fmax, \ud835\udc54(\ud835\udc46\ud835\udc56 ) \ud835\udc58(1+\ud835\udf16) } /* Update the threshold */ 12 return arg max\ud835\udc46\ud835\udc56 \ud835\udc54(\ud835\udc46\ud835\udc56 ) /* The subset that maximizes \ud835\udc54(\ud835\udc46) */"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 322.9360046386719,
                            "x2": 558.201904296875,
                            "y1": 626.2886962890625,
                            "y2": 628.3330078125
                        },
                        "text": "It is important to note that each peeling iteration often results in"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7154541015625,
                            "y1": 637.2476806640625,
                            "y2": 639.2919921875
                        },
                        "text": "disparate structures. This is primarily caused by the peeling of cer-"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2034912109375,
                            "y1": 648.2056884765625,
                            "y2": 650.25
                        },
                        "text": "tain vertices, which leaves their neighboring structures disconnected"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.71484375,
                            "y1": 659.1646728515625,
                            "y2": 661.208984375
                        },
                        "text": "and fragmented. This not only affects the density of the detected sub-"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2035522460938,
                            "y1": 670.1236572265625,
                            "y2": 672.16796875
                        },
                        "text": "graph but also lowers the peeling threshold. Lemma 5.2 establishes a"
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 515.3548583984375,
                            "y1": 681.0827026367188,
                            "y2": 683.1270141601562
                        },
                        "text": "foundational property of vertices within a dense graph."
                    },
                    {
                        "page": 7,
                        "region": {
                            "x1": 322.93701171875,
                            "x2": 516.2286987304688,
                            "y1": 701.0077514648438,
                            "y2": 708.6920166015625
                        },
                        "text": "Lemma 5.2. \u2200\ud835\udc62 \u2208 \ud835\udc46 , if\ud835\udc64\ud835\udc62 (\ud835\udc46) < \ud835\udc54(\ud835\udc46), \ud835\udc54(\ud835\udc46 \\ {\ud835\udc62}) > \ud835\udc54(\ud835\udc46)."
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 63.76100158691406,
                            "x2": 253.4752197265625,
                            "y1": 89.73066711425781,
                            "y2": 93.64898681640625
                        },
                        "text": "Proof. By peeling \ud835\udc62 from \ud835\udc46 , we have the following."
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 94.75302124023438,
                            "x2": 137.75018310546875,
                            "y1": 108.52372741699219,
                            "y2": 114.86297607421875
                        },
                        "text": "\ud835\udc54(\ud835\udc46 \\ {\ud835\udc62}) ="
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 141.88302612304688,
                            "x2": 186.8880157470703,
                            "y1": 102.36869812011719,
                            "y2": 110.05291748046875
                        },
                        "text": "\ud835\udc53 (\ud835\udc46) \u2212\ud835\udc64\ud835\udc62 (\ud835\udc46)"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 154.81199645996094,
                            "x2": 173.86936950683594,
                            "y1": 114.67472839355469,
                            "y2": 121.01397705078125
                        },
                        "text": "|\ud835\udc46 |\u22121"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 190.76300048828125,
                            "x2": 241.70399475097656,
                            "y1": 102.36869812011719,
                            "y2": 114.86297607421875
                        },
                        "text": "> \ud835\udc53 (\ud835\udc46) \u2212 \ud835\udc54(\ud835\udc46\ud835\udc56 )"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 211.677001953125,
                            "x2": 230.734375,
                            "y1": 114.67472839355469,
                            "y2": 121.01397705078125
                        },
                        "text": "|\ud835\udc46 |\u22121"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 132.81700134277344,
                            "x2": 137.74851989746094,
                            "y1": 143.43563842773438,
                            "y2": 145.47998046875
                        },
                        "text": "="
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 141.88299560546875,
                            "x2": 180.19996643066406,
                            "y1": 132.98570251464844,
                            "y2": 139.324951171875
                        },
                        "text": "\ud835\udc53 (\ud835\udc46) \u2212 \ud835\udc54(\ud835\udc46)"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 149.50599670410156,
                            "x2": 172.4873809814453,
                            "y1": 143.89817810058594,
                            "y2": 151.6309814453125
                        },
                        "text": "|\ud835\udc46\u2217 |\u22121"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 183.88600158691406,
                            "x2": 188.81752014160156,
                            "y1": 143.43563842773438,
                            "y2": 145.47998046875
                        },
                        "text": "="
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 192.95199584960938,
                            "x2": 231.2472686767578,
                            "y1": 128.47535705566406,
                            "y2": 136.39495849609375
                        },
                        "text": "\ud835\udc53 (\ud835\udc46) \u2212 \ud835\udc53 (\ud835\udc46)"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 203.1230010986328,
                            "x2": 257.6230163574219,
                            "y1": 134.8472137451172,
                            "y2": 151.6309814453125
                        },
                        "text": "|\ud835\udc46 | |\ud835\udc46 |\u22121 = \ud835\udc54(\ud835\udc46)"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 285.343017578125,
                            "x2": 299.0257568359375,
                            "y1": 128.14962768554688,
                            "y2": 130.1939697265625
                        },
                        "text": "(15)"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.529022216796875,
                            "x2": 299.025634765625,
                            "y1": 161.6190185546875,
                            "y2": 166.1739501953125
                        },
                        "text": "Therefore, a denser graph can be obtained by peeling \ud835\udc62 from \ud835\udc46 . \u25a1"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 63.76100158691406,
                            "x2": 299.0246887207031,
                            "y1": 183.85568237304688,
                            "y2": 185.9000244140625
                        },
                        "text": "According to Lemma 5.2, we introduce local peeling optimization"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 300.40643310546875,
                            "y1": 194.81466674804688,
                            "y2": 207.8179931640625
                        },
                        "text": "within the iteration. After each peeling iteration, if the peeling weight of a vertex is smaller than the current density, Dupin will trim it."
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.36800003051758,
                            "x2": 300.409912109375,
                            "y1": 216.73165893554688,
                            "y2": 240.6939697265625
                        },
                        "text": "We implement a local peeling optimization (Lines 7-10, Algorithm 4) before the next iteration. After a vertex \ud835\udc62 is peeled, Dupin invokes updateNgh to update the peeling weights of \ud835\udc62\u2019s neighboring nodes."
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02764892578125,
                            "y1": 249.60867309570312,
                            "y2": 251.65301513671875
                        },
                        "text": "If any of these neighbors have a peeling weight less than the current"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.03057861328125,
                            "y1": 260.5676574707031,
                            "y2": 262.61199951171875
                        },
                        "text": "density, they are also peeled, thereby increasing the density of the"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.2601318359375,
                            "y1": 271.5266418457031,
                            "y2": 273.57098388671875
                        },
                        "text": "current iteration. Consequently, when an iteration yields globally"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.03057861328125,
                            "y1": 282.48565673828125,
                            "y2": 284.5299987792969
                        },
                        "text": "optimal results, a denser structure is obtained. The benefits of this"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0226745605469,
                            "y1": 293.4446716308594,
                            "y2": 295.489013671875
                        },
                        "text": "approach extend beyond density improvements; performance is also"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02227783203125,
                            "y1": 304.4036560058594,
                            "y2": 306.447998046875
                        },
                        "text": "enhanced. By trimming these vertices, we reduce the number of"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.57400131225586,
                            "x2": 299.2556457519531,
                            "y1": 315.3626708984375,
                            "y2": 317.4070129394531
                        },
                        "text": "vertices to traverse in subsequent iterations, and a higher density"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.1945495605469,
                            "y1": 326.3206481933594,
                            "y2": 328.364990234375
                        },
                        "text": "enables more efficient iterations due to the possibility of using larger"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 123.11721801757812,
                            "y1": 337.2796630859375,
                            "y2": 339.3240051269531
                        },
                        "text": "peeling thresholds."
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.2599983215332,
                            "x2": 300.00390625,
                            "y1": 348.38922119140625,
                            "y2": 369.0889892578125
                        },
                        "text": "Lemma 5.3. If \ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\ud835\udc5d is the first vertex in \ud835\udc46\u2217 removed by Dupin, \ud835\udc62\ud835\udc56 will not be removed during the local peeling optimization process."
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.57400131225586,
                            "x2": 299.02789306640625,
                            "y1": 383.55169677734375,
                            "y2": 410.7330017089844
                        },
                        "text": "Proof. Assume, for the sake of contradiction, that \ud835\udc62\ud835\udc56 is trimmed during the local peeling optimization process. Let \ud835\udc46 \u2032 be the set of vertices left before \ud835\udc62\ud835\udc56 is trimmed. By definition, we have:"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 147.1680145263672,
                            "x2": 205.07362365722656,
                            "y1": 417.127197265625,
                            "y2": 428.4079895019531
                        },
                        "text": "\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) < \ud835\udc54(\ud835\udc46\u2217)."
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 63.76100158691406,
                            "x2": 300.08575439453125,
                            "y1": 434.1592102050781,
                            "y2": 443.9010009765625
                        },
                        "text": "Since \ud835\udc62\ud835\udc56 is the first vertex in \ud835\udc46\u2217 to be removed, \ud835\udc46\u2217 \u2286 \ud835\udc46 \u2032, therefore:"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 127.99600219726562,
                            "x2": 224.24559020996094,
                            "y1": 450.29522705078125,
                            "y2": 461.5760192871094
                        },
                        "text": "\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) < \ud835\udc54(\ud835\udc46\u2217)."
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 63.760986328125,
                            "x2": 266.445068359375,
                            "y1": 467.32720947265625,
                            "y2": 477.0690002441406
                        },
                        "text": "This contradicts Lemma 5.2, which states that \u2200\ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\u2217:"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 146.677001953125,
                            "x2": 205.56460571289062,
                            "y1": 483.46319580078125,
                            "y2": 494.7439880371094
                        },
                        "text": "\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2265 \ud835\udc54(\ud835\udc46\u2217)."
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.52899932861328,
                            "x2": 300.0152893066406,
                            "y1": 504.9747009277344,
                            "y2": 519.8510131835938
                        },
                        "text": "Otherwise, a better solution can be obtained by removing \ud835\udc62 from \ud835\udc46\u2217, which contradicts the fact that \ud835\udc46\u2217 is the optimal solution. Thus,"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.2599983215332,
                            "x2": 299.0301513671875,
                            "y1": 526.8916625976562,
                            "y2": 541.7689819335938
                        },
                        "text": "\ud835\udc62\ud835\udc56 cannot be trimmed. Hence,\ud835\udc62\ud835\udc56 will not be removed during the local peeling optimization process. \u25a1"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 63.76100158691406,
                            "x2": 299.0260925292969,
                            "y1": 557.57666015625,
                            "y2": 562.8399658203125
                        },
                        "text": "Due to Lemma 5.3, \ud835\udc62\ud835\udc56 will only be removed during the peeling"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0290832519531,
                            "y1": 570.40966796875,
                            "y2": 572.4539794921875
                        },
                        "text": "process. Hence, the approximation ratios (Theorem 4.2) for different"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 163.5646514892578,
                            "y1": 581.36865234375,
                            "y2": 583.4129638671875
                        },
                        "text": "density metrics are preserved."
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 193.9908447265625,
                            "y1": 598.662109375,
                            "y2": 605.5130004882812
                        },
                        "text": "6 EXPERIMENTAL STUDY"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 322.9360046386719,
                            "x2": 559.1883544921875,
                            "y1": 91.60464477539062,
                            "y2": 93.64898681640625
                        },
                        "text": "Our experiments are run on a machine that has an X5650 CPU,"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2057495117188,
                            "y1": 102.56362915039062,
                            "y2": 104.60797119140625
                        },
                        "text": "512 GB RAM. The implementation is made memory-resident and"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 559.7203979492188,
                            "y1": 111.64869689941406,
                            "y2": 337.8219909667969
                        },
                        "text": "implemented in C++. All codes are compiled by GCC-9.3.0 with -\ud835\udc423. Datasets. We report the datasets used in our experiment in Table 3. One industrial dataset is from Anon (gfg). Datasets links-anon(la) and Twitter-rv (rv)were obtained from Stanford NetworkDataset Collection [31]. Datasets kron-logn21(kron), soc-twitter(soc), Web-uk-2005(uk) and Web-sk-2005(sk) were obtained from Network Data Repository [38]. Dataset bio was from the BIOMINE [35]. Baseline Methods.We evaluate five commonly used density metrics pivotal in network structure analysis: DG [6], DW [23], FD [24], TDS [46], and \ud835\udc58CLiDS [14]. These metrics are implemented within our framework, Dupin, and their performance is compared against several existing frameworks: Spade [28], kCLIST [14], GBBS [16], PBBS [41], PKMC [32], FWA [15], and ALENEX [44]. Specifically, kCLIST and PBBS are parallel algorithms for \ud835\udc58CLiDS. Since GBBS does not natively support weighted graphs, we precompute the peeling weights offline and import them into GBBS to enable support for DW and FD; the reported runtime excludes this preprocessing time. Additionally, FWA, ALENEX, and PKMC support the DGmetric, and we have extended their algorithms to support DW and FD by modifying their codebases accordingly. For TDS and \ud835\udc58CLiDS, we adapted the API of Spade for implementation. To standardize the compari-"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 312.6780090332031,
                            "x2": 559.7184448242188,
                            "y1": 346.7366638183594,
                            "y2": 370.6990051269531
                        },
                        "text": "son, we denote the incremental peeling process\u2014which iteratively removes graph elements based on density scores\u2014as Spade-X, where X corresponds to each metric. This follows the experimental condi-"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 559.7161865234375,
                            "y1": 379.6136474609375,
                            "y2": 427.0320129394531
                        },
                        "text": "tions in [28], with the batch size set to 1K as per their default setting; we report the average runtime per batch for Spade. Our parallel peeling algorithms, incorporating global and local peeling optimizations, are denoted as DupinGPO-X and DupinLPO-X, respectively. Default Settings. In our experiments, the parameter \ud835\udf16 is set to 0.1"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2006225585938,
                            "y1": 434.07269287109375,
                            "y2": 437.9909973144531
                        },
                        "text": "by default, and the number of threads \ud835\udc61 is configured to 128. These"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 520.6897583007812,
                            "y1": 446.9056701660156,
                            "y2": 448.95001220703125
                        },
                        "text": "settings are used consistently unless otherwise specified."
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2000732421875,
                            "y1": 484.88409423828125,
                            "y2": 506.9730224609375
                        },
                        "text": "6.1 Efficiency of Dupin Spade vs Dupin. Our initial comparison focuses on the performance"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 559.7172241210938,
                            "y1": 516.6746826171875,
                            "y2": 617.3499755859375
                        },
                        "text": "disparity between the incremental and parallel peeling algorithms. Specifically, Dupin-DG (resp. Dupin-DW, Dupin-FD, Dupin-TDS, and Dupin-\ud835\udc58CLiDS) demonstrates a speedup factor of 6.97 (resp. 7.71, 7.71, 7.65, and 8.46) over Spade-DG (resp. Spade-DW, SpadeFD, Spade-TDS, and Spade-\ud835\udc58CLiDS) as shown in Table 4 and Table 5. Notably, Spade-TDS and Spade-\ud835\udc58CLiDS only complete computations within 7,200 seconds on gfg. The bottleneck for Spade arises in larger graphs where initial calculations of the triangle and \ud835\udc58-Clique counting are unable to finish. Dupin outpaces Spade primarily because Spade suffers from the frequent reordering of peeling sequences"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 558.204833984375,
                            "y1": 626.2647094726562,
                            "y2": 628.3090209960938
                        },
                        "text": "when there are many increments, which proves to be slower than"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 559.7175903320312,
                            "y1": 637.22265625,
                            "y2": 696.3889770507812
                        },
                        "text": "recalculating. GBBS vs Dupin. Among the parallel methods for DG, DW, and FD, FWA, ALENEX, and PKMC are several to dozens of times slower than GBBS. Therefore, we selectGBBS as a representative for comparison withDupin. The runtimes of the other three methods are provided in Table 4. On average, Dupin-DG, Dupin-DW, and Dupin-FD demon-"
                    },
                    {
                        "page": 8,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.1893920898438,
                            "y1": 703.4286499023438,
                            "y2": 707.3469848632812
                        },
                        "text": "strated speedup factors of 6.33, 12.51, and 17.07 times, respectively,"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5405578613281,
                            "y1": 273.5010070800781,
                            "y2": 278.70599365234375
                        },
                        "text": "over GBBS-DG, GBBS-DW, and GBBS-FD. This performance ad-"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 53.57400131225586,
                            "x2": 299.0269775390625,
                            "y1": 287.62066650390625,
                            "y2": 300.6239929199219
                        },
                        "text": "vantage is attributed to the fundamental difference in the peeling process between the two frameworks. In GBBS, the basic unit of"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.02471923828125,
                            "y1": 309.5386657714844,
                            "y2": 311.5830078125
                        },
                        "text": "peeling is a bucket, where all nodes within the same bucket have an"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.2638244628906,
                            "y1": 320.4976501464844,
                            "y2": 344.4590148925781
                        },
                        "text": "identical peeling weight. This design limits parallelism in weighted graphs, such as those using DW and FD, where many buckets may contain only a single node. In contrast, Dupin peels batches of nodes"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0223083496094,
                            "y1": 353.3736572265625,
                            "y2": 355.4179992675781
                        },
                        "text": "at each step and maintains a global peeling threshold to enhance"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.54150390625,
                            "y1": 364.3326721191406,
                            "y2": 366.37701416015625
                        },
                        "text": "the efficiency of each peeling iteration and eliminate long-tail iter-"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.2586364746094,
                            "y1": 375.2916564941406,
                            "y2": 388.2950134277344
                        },
                        "text": "ations. This approach achieves higher parallelism and consistently outperforms GBBS, particularly in weighted graph scenarios where"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 53.439998626708984,
                            "x2": 300.5416564941406,
                            "y1": 397.20965576171875,
                            "y2": 489.4129943847656
                        },
                        "text": "the speedup is even more pronounced. kCLIST vs PBBS vs Dupin. Both kCLIST and PBBS support the density metrics TDS and \ud835\udc58CLiDS. In our comparisons, Dupin demonstrates notable performance advantages. Specifically, Dupin-TDS is faster than kCLIST-TDS and PBBS-TDS by 39.85 and 62.71 times, respectively. Furthermore, Dupin-\ud835\udc58CLiDS also outperforms kCLIST\ud835\udc58CLiDS by 4.16 times. A significant finding is that PBBS-\ud835\udc58CLiDS fails to complete computations within 7200 seconds on most datasets, highlighting the efficiency of Dupin in handling more complex met-"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 53.439998626708984,
                            "x2": 301.05303955078125,
                            "y1": 498.3276672363281,
                            "y2": 601.3380126953125
                        },
                        "text": "rics under stringent time constraints. Impact of DupinGPO. Next, we evaluate the acceleration effect of DupinGPO, using Dupin as a baseline for comparison. Notably, DupinGPO-DG is found to be 1.14 times faster, DupinGPO-DW is 1.11 times faster,DupinGPO-TDS is 1.10 times faster, andDupinGPO\ud835\udc58CLiDS is 1.35 times faster than their respective Dupin implementations. The acceleration is particularly significant for \ud835\udc58CLiDS on larger datasets, such as soc, rv, kron, and sk. DupinGPO-\ud835\udc58CLiDS is 1.40, 1.54, 1.51, and 1.61 times faster than Dupin-\ud835\udc58CLiDS on soc, rv, kron, and sk, respectively. This is attributed to the greater number"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.1926574707031,
                            "y1": 610.252685546875,
                            "y2": 612.2969970703125
                        },
                        "text": "of iterations required due to the larger dataset sizes and the higher"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5394287109375,
                            "y1": 619.337646484375,
                            "y2": 634.2139892578125
                        },
                        "text": "count of \ud835\udc58-Cliques, necessitating more peeling iterations. In such scenarios,DupinGPO effectively prunes the tail iterations early, thereby"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 303.3229064941406,
                            "y1": 643.128662109375,
                            "y2": 702.302978515625
                        },
                        "text": "reducing the number of rounds needed. Impact of DupinLPO. We next compared the efficiency of Dupin andDupinLPO. On average, thoughDupinLPO-DGwas 10.09% slower than Dupin-DG, the speed is still comparable. For example, on the soc dataset, DupinLPO-DG was 5.94% faster than Dupin-DG. This is because DupinLPO requires some lock operations to update the"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7166137695312,
                            "y1": 549.542724609375,
                            "y2": 562.5460205078125
                        },
                        "text": "peeling weights of neighboring vertices during local peeling optimization. However, the advantage is that DupinLPO can detect up"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.3722534179688,
                            "y1": 571.460693359375,
                            "y2": 584.4639892578125
                        },
                        "text": "to 26.26% denser subgraphs, as detailed in Section 6.2. On larger datasets, such as soc, rv, and la, the vertices being trimmed have"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.3734741210938,
                            "y1": 593.378662109375,
                            "y2": 652.552978515625
                        },
                        "text": "relatively low correlations with each other, so the impact of locks is minimal. For example, on the soc (resp. rv), DupinLPO-DG was 5.94% (resp. 9.94%) faster than Dupin-DG. In contrast, on smaller datasets, such as bio and kron, the extra cost of locks is higher. Impact of the Number of Threads \ud835\udc61 . All methods are influenced by the concurrency level, i.e., the number of threads. Generally, the"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.3746337890625,
                            "y1": 661.4676513671875,
                            "y2": 674.4710083007812
                        },
                        "text": "greater the number of threads, the faster the execution speed. In our experiments, using the la dataset as a benchmark, we varied the"
                    },
                    {
                        "page": 9,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.1881103515625,
                            "y1": 681.5116577148438,
                            "y2": 707.3469848632812
                        },
                        "text": "number of threads \ud835\udc61 from 2 to 128 to observe the impact on runtime performance. For GBBS-DG, runtime stabilizes and accelerates by 3.33 times as thread count increases from 2 to 8. For GBBS-DW,"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.03057861328125,
                            "y1": 650.5086669921875,
                            "y2": 707.3469848632812
                        },
                        "text": "performance deteriorates when the thread count exceeds 32, but from 2 to 32 threads, it accelerates by 3.50 times. Similarly, GBBS-FD shows no significant change in runtime beyond 32 threads, with an acceleration of 3.09 times from 2 to 32 threads. GBBS-TDS and GBBS-\ud835\udc58CLiDS fail to complete computations on the la dataset. In contrast, all five methods tested onDupin exhibit good scalability. As"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.1878662109375,
                            "y1": 88.4439926147461,
                            "y2": 115.5670166015625
                        },
                        "text": "the number of threads increases from 2 to 128,Dupin-DG accelerates by 9.91 times, Dupin-DW by 12.69 times, Dupin-FD by 13.03 times, and Dupin-TDS by 28.06 times. Although Dupin-\ud835\udc58CLiDS fails to"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.76800537109375,
                            "x2": 558.4351806640625,
                            "y1": 124.48165893554688,
                            "y2": 148.4429931640625
                        },
                        "text": "produce results when the thread count is below 16, it accelerates by 1.32 times from 32 to 128 threads. These results demonstrate Dupin\u2019s strong scalability across varied threading levels."
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7191772460938,
                            "y1": 173.19808959960938,
                            "y2": 193.74798583984375
                        },
                        "text": "6.2 Effectiveness of Dupin In addition to assessing performance speedup, we evaluate the den-"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7147827148438,
                            "y1": 202.66262817382812,
                            "y2": 215.66497802734375
                        },
                        "text": "sity of the subgraphs detected by different frameworks. For parallel methods, we consider GBBS, PBBS, and kCLIST, because they gen-"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.4318237304688,
                            "y1": 224.57968139648438,
                            "y2": 226.6240234375
                        },
                        "text": "erally detect subgraphs with higher density than those detected by"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.19970703125,
                            "y1": 235.53866577148438,
                            "y2": 248.5419921875
                        },
                        "text": "other methods across most datasets. For incremental methods, we use Spade as a representative. Detailed density comparisons are"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7144775390625,
                            "y1": 257.4566345214844,
                            "y2": 316.7879943847656
                        },
                        "text": "presented in Table 6 and Table 7. GBBS vs Spade vs Dupin. Firstly, we compare the densities of the subgraphs identified by GBBS-DG (respectively GBBS-DW, and GBBS-FD) to those detected by Dupin in parallel execution. Our experimental results indicate that Dupin maintains comparable subgraph densities with GBBS, signifying that the increase in com-"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7164306640625,
                            "y1": 325.7026672363281,
                            "y2": 327.74700927734375
                        },
                        "text": "putational efficiency does not compromise the accuracy of the de-"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7178344726562,
                            "y1": 336.6616516113281,
                            "y2": 382.5409851074219
                        },
                        "text": "tected subgraphs. Specifically, the density of the subgraph detected byGBBS-DG (respectivelyGBBS-DW, andGBBS-FD) is 7.08% (resp. 6.48% and 7.43%) greater than that detected by Dupin-DG (respectively Dupin-DW, and Dupin-FD) on average. Spade shares similar densities with GBBS. Due to Spade\u2019s tendency to accumulate er-"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1984252929688,
                            "y1": 391.4556579589844,
                            "y2": 393.5
                        },
                        "text": "rors over time, its density can become inflated. We will explain its"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.5789794921875,
                            "y1": 402.4146728515625,
                            "y2": 416.9570007324219
                        },
                        "text": "limitations in practical applications in more detail in the case study. kCLIST vs PBBS vs Dupin. a) For \ud835\udc58CLiDS, PBBS-\ud835\udc58CLiDS could not"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.614990234375,
                            "x2": 561.89404296875,
                            "y1": 426.65966796875,
                            "y2": 516.375
                        },
                        "text": "complete on most of our test datasets, so we did not compare their densities. kCLIST-\ud835\udc58CLiDS could not complete on the sk dataset. On the other datasets, Dupin-\ud835\udc58CLiDS\u2019s density was only 6.97% smaller than kCLIST-\ud835\udc58CLiDS. On some datasets, such as bio and kron,Dupin\ud835\udc58CLiDS even detected subgraphs with greater density. b) For TDS, PBBS-TDS could detect subgraphs on smaller graphs but failed on billion-scale graphs such as rv, sk, and la. Dupin-TDS\u2019s density was 2.03% greater than kCLIST-TDS. Therefore, we conclude that Dupin is comparable to existing parallel methods in terms of the density of"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7181396484375,
                            "y1": 525.2896728515625,
                            "y2": 584.4639892578125
                        },
                        "text": "the detected dense subgraphs. Ablation Study of Dupin. This experiment delves into the effectiveness of our optimizations, DupinGPO and DupinLPO. Our analysis primarily focuses on comparing the densities of dense subgraphs detected by both DupinGPO and DupinLPO in various settings. DupinGPO achieves the same density as Dupin across five den-"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.73199462890625,
                            "x2": 559.7172241210938,
                            "y1": 593.378662109375,
                            "y2": 617.3410034179688
                        },
                        "text": "sity metrics because it trims the long tail, enhancing efficiency. For DupinLPO-DG (resp. DupinLPO-DW, DupinLPO-FD, DupinLPOTDS, and DupinGPO-\ud835\udc58CLiDS), we observe that the detected sub-"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7185668945312,
                            "y1": 626.2556762695312,
                            "y2": 684.6329956054688
                        },
                        "text": "graphs exhibit densities 11.09% (resp. 7.32%, 8.00%, 1.01%, and 26.26%) greater than those detected by Dupin-DG, Dupin-DW, Dupin-FD, Dupin-TDS, andDupin-\ud835\udc58CLiDS, respectively, demonstrating notable outcomes. This is because DupinLPO trims the graph in each iteration, resulting in denser subgraphs compared to Dupin. Impact of the Approximation Ratio \ud835\udf16. The approximation ratio"
                    },
                    {
                        "page": 10,
                        "region": {
                            "x1": 312.6600036621094,
                            "x2": 558.2035522460938,
                            "y1": 692.4706420898438,
                            "y2": 707.3469848632812
                        },
                        "text": "\ud835\udf16 serves to control accuracy. In our experiment, we vary \ud835\udf16 from 0.1 to 1 to investigate its influence on the accuracy of Dupin. We"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 53.48400115966797,
                            "x2": 300.5410461425781,
                            "y1": 420.8417053222656,
                            "y2": 490.51300048828125
                        },
                        "text": "observe that as \ud835\udf16 increases from 0.1 to 1, the density of subgraphs detected by Dupin, DupinGPO, and DupinLPO generally decreases. ForDG, the densities ofDupin-DG,DupinGPO-DG, andDupinLPODG decrease by 22.71%, 22.71%, and 11.99%, respectively. The trends for DW and DG are similar, with the worst performance observed at \ud835\udf16 = 0.6 for both density metrics. The trends for FD, TDS, and \ud835\udc58CLiDS are also similar. DupinLPO detects denser subgraphs across most"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 300.41119384765625,
                            "y1": 497.5536804199219,
                            "y2": 523.3900146484375
                        },
                        "text": "density metrics and is less affected by \ud835\udf16 , due to its iterative trimming. For example, for FD, DupinLPO\u2019s density decreases by only 6.23%, while DupinGPO and Dupin\u2019s densities decrease by 17.37%."
                    }
                ],
                "title": {
                    "page": 7,
                    "region": {
                        "x1": 312.9739990234375,
                        "x2": 472.24688720703125,
                        "y1": 440.86407470703125,
                        "y2": 447.7149963378906
                    },
                    "text": "5.2 Local Peeling Optimization"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 11,
                        "region": {
                            "x1": 53.36800003051758,
                            "x2": 299.0291442871094,
                            "y1": 560.501708984375,
                            "y2": 562.5460205078125
                        },
                        "text": "We also compare the performance in real-world scenarios, focusing"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.26031494140625,
                            "y1": 571.460693359375,
                            "y2": 586.0029907226562
                        },
                        "text": "on three key aspects: accuracy, latency, and prevention ratio. Accuracy. As discussed in Section 1, although Spade can quickly"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.53985595703125,
                            "y1": 595.7136840820312,
                            "y2": 630.635009765625
                        },
                        "text": "respond to new transactions, it tends to accumulate errors over time. Our analysis utilizes transaction data from Anon, with the transaction network comprising |\ud835\udc38 |= 2 billion edges. Under the incremental computation framework of Spade, the assumption is made that the"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 53.46699905395508,
                            "x2": 299.02972412109375,
                            "y1": 639.5496826171875,
                            "y2": 641.593994140625
                        },
                        "text": "weights of existing edges remain constant, thereby neglecting the"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.19610595703125,
                            "y1": 650.5086669921875,
                            "y2": 663.511962890625
                        },
                        "text": "impact of newly inserted edges on these weights, leading to error accumulation. For instance, using FD density metric, we observe that"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.3150329589844,
                            "y1": 672.4266967773438,
                            "y2": 685.4299926757812
                        },
                        "text": "errors accumulate up to 24.4% within a day and increase to 30.3% over a week, as illustrated in Figure 9. Although Dupin sacrifices"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5390319824219,
                            "y1": 694.3446655273438,
                            "y2": 707.3469848632812
                        },
                        "text": "some accuracy to achieve parallel computational efficiency, our experiments show that Dupin\u2019s errors remain relatively stable between"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1975708007812,
                            "y1": 260.6990051269531,
                            "y2": 276.86297607421875
                        },
                        "text": "3% and 5%. Hence, the detection precision of Spade declines from 87.9% to 68.3%, while Dupin\u2019s precision remains above 86%."
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.201904296875,
                            "y1": 406.8611145019531,
                            "y2": 412.49200439453125
                        },
                        "text": "Latency and Prevention Ratio. If a transaction is identified as"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2051391601562,
                            "y1": 422.2036437988281,
                            "y2": 424.24798583984375
                        },
                        "text": "fraudulent, subsequent related transactions are blocked to mitigate"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.71630859375,
                            "y1": 433.16265869140625,
                            "y2": 435.2070007324219
                        },
                        "text": "potential losses. We define the ratio of successfully prevented sus-"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.75,
                            "x2": 559.7144165039062,
                            "y1": 444.12164306640625,
                            "y2": 511.9200134277344
                        },
                        "text": "picious transactions to the total number of suspicious transactions as R. As shown in Figure 8, the prevention ratio R continues to decrease as latency increases on Anon\u2019s datasets. Using the default density metric, FD, in Anon, our results show thatDupin-FD can prevent 94.5% of fraudulent activities, GBBS-FD can prevent 3.0%, and Spade-FD can prevent 45.3%. The reason for the lower performance of GBBS-FD is its low parallelism in the peeling process, which"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.4086303710938,
                            "y1": 520.8336791992188,
                            "y2": 522.8779907226562
                        },
                        "text": "results in long peeling times and thus an average latency of 6,014"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.715087890625,
                            "y1": 531.792724609375,
                            "y2": 544.7960205078125
                        },
                        "text": "seconds, delaying the prevention of many fraudulent activities. Although Spade-FD performs well in reordering techniques on smaller"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.43603515625,
                            "y1": 553.710693359375,
                            "y2": 555.7550048828125
                        },
                        "text": "datasets, in industrial scenarios with billion-scale graphs, latency"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.20361328125,
                            "y1": 564.669677734375,
                            "y2": 566.7139892578125
                        },
                        "text": "significantly worsens due to the extensive reordering range required"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.1862182617188,
                            "y1": 575.628662109375,
                            "y2": 577.6729736328125
                        },
                        "text": "in the peeling sequences as normal users transition to fraudsters,"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.6419982910156,
                            "x2": 558.2015991210938,
                            "y1": 586.5877075195312,
                            "y2": 599.5910034179688
                        },
                        "text": "increasing the cost of incremental computations. Additional tests were conducted with other density metrics; for DG, Dupin-DG can"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.72119140625,
                            "y1": 608.5056762695312,
                            "y2": 621.509033203125
                        },
                        "text": "prevent 78.8%, while other methods prevent varying amounts. Similarly, for DW, Dupin-DW can prevent 86.1%, while other methods"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 479.30096435546875,
                            "y1": 630.4237060546875,
                            "y2": 632.468017578125
                        },
                        "text": "demonstrate different prevention capabilities."
                    }
                ],
                "title": {
                    "page": 11,
                    "region": {
                        "x1": 53.798004150390625,
                        "x2": 131.81988525390625,
                        "y1": 541.9961547851562,
                        "y2": 548.8470458984375
                    },
                    "text": "6.3 Case study"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.1987915039062,
                            "y1": 669.2659912109375,
                            "y2": 674.4710083007812
                        },
                        "text": "In this paper, we presented Dupin, a novel parallel fraud detection"
                    },
                    {
                        "page": 11,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.7166137695312,
                            "y1": 683.3856811523438,
                            "y2": 707.3469848632812
                        },
                        "text": "framework tailored for massive graphs. Our experiments demonstrated that Dupin\u2019s advanced peeling algorithms and long-tail pruning techniques, DupinGPO and DupinLPO, significantly enhance"
                    },
                    {
                        "page": 12,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.5405578613281,
                            "y1": 91.60464477539062,
                            "y2": 115.5670166015625
                        },
                        "text": "the detection efficiency of dense subgraphs without sacrificing accuracy. Comparative studies with GBBS, PBBS, kCLIST, Spade, and Dupin highlighted Dupin\u2019s superior performance in terms of com-"
                    },
                    {
                        "page": 12,
                        "region": {
                            "x1": 53.57400131225586,
                            "x2": 300.54425048828125,
                            "y1": 124.48165893554688,
                            "y2": 137.4840087890625
                        },
                        "text": "putational efficiency and accuracy. Through case studies, we also validated that Dupin achieves lower latency and higher detection ac-"
                    },
                    {
                        "page": 12,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0276184082031,
                            "y1": 146.39865112304688,
                            "y2": 148.4429931640625
                        },
                        "text": "curacy compared to existing fraud detection systems on billion-scale"
                    },
                    {
                        "page": 12,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 80.66133880615234,
                            "y1": 157.35763549804688,
                            "y2": 159.4019775390625
                        },
                        "text": "graphs."
                    },
                    {
                        "page": 12,
                        "region": {
                            "x1": 63.76100158691406,
                            "x2": 299.02777099609375,
                            "y1": 165.15602111816406,
                            "y2": 170.36102294921875
                        },
                        "text": "Overall, Dupinproves to be a powerful tool for large-scale fraud"
                    },
                    {
                        "page": 12,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0223693847656,
                            "y1": 179.27566528320312,
                            "y2": 181.32000732421875
                        },
                        "text": "detection, providing a scalable and efficient solution for real-time"
                    },
                    {
                        "page": 12,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0272521972656,
                            "y1": 190.23464965820312,
                            "y2": 192.27899169921875
                        },
                        "text": "applications. Future work will explore the integration of additional"
                    },
                    {
                        "page": 12,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.0223693847656,
                            "y1": 201.19363403320312,
                            "y2": 203.23797607421875
                        },
                        "text": "suspiciousness functions and further optimization to handle even"
                    },
                    {
                        "page": 12,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 237.0084228515625,
                            "y1": 212.15267944335938,
                            "y2": 214.197021484375
                        },
                        "text": "larger datasets and more complex fraud scenarios."
                    }
                ],
                "title": {
                    "page": 11,
                    "region": {
                        "x1": 312.9739990234375,
                        "x2": 518.0541381835938,
                        "y1": 653.9210815429688,
                        "y2": 660.77197265625
                    },
                    "text": "7 CONCLUSION AND FUTUREWORKS"
                }
            },
            {
                "paragraphs": [
                    {
                        "page": 13,
                        "region": {
                            "x1": 57.0410041809082,
                            "x2": 299.7077331542969,
                            "y1": 102.76898193359375,
                            "y2": 104.3590087890625
                        },
                        "text": "[1] Distil networks: The 2019 bad bot report. https://www.bluecubesecurity.com/wp-"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 69.23400115966797,
                            "x2": 196.7847900390625,
                            "y1": 110.73895263671875,
                            "y2": 112.3289794921875
                        },
                        "text": "content/uploads/bad-bot-report-2019LR.pdf."
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 57.04100036621094,
                            "x2": 299.0284423828125,
                            "y1": 118.70892333984375,
                            "y2": 120.29901123046875
                        },
                        "text": "[2] B. Bahmani, R. Kumar, and S. Vassilvitskii. Densest subgraph in streaming and"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 57.04100036621094,
                            "x2": 299.0245666503906,
                            "y1": 124.06726837158203,
                            "y2": 136.239013671875
                        },
                        "text": "mapreduce. Proceedings of the VLDB Endowment, 5(5), 2012. [3] Y. Ban, X. Liu, T. Zhang, L. Huang, Y. Duan, X. Liu, and W. Xu. Badlink: Combining"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 57.04100036621094,
                            "x2": 299.0263366699219,
                            "y1": 140.00726318359375,
                            "y2": 160.14898681640625
                        },
                        "text": "graph and information-theoretical features for online fraud group detection. arXiv preprint arXiv:1805.10053, 2018. [4] A. Beutel, W. Xu, V. Guruswami, C. Palow, and C. Faloutsos. Copycatch: stopping"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 57.041015625,
                            "x2": 299.8513488769531,
                            "y1": 163.91827392578125,
                            "y2": 184.05999755859375
                        },
                        "text": "group attacks by spotting lockstep behavior in social networks. In Proceedings of the 22nd international conference on World Wide Web, pages 119\u2013130, 2013. [5] D. Boob, Y. Gao, R. Peng, S. Sawlani, C. Tsourakakis, D.Wang, and J.Wang. Flowless:"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 57.040992736816406,
                            "x2": 299.026611328125,
                            "y1": 187.82830810546875,
                            "y2": 207.969970703125
                        },
                        "text": "Extracting densest subgraphs without flow computations. In Proceedings of The Web Conference 2020, pages 573\u2013583, 2020. [6] M. Charikar. Greedy approximation algorithms for finding dense components in a"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 57.0410041809082,
                            "x2": 299.0263977050781,
                            "y1": 211.73828125,
                            "y2": 231.8800048828125
                        },
                        "text": "graph. In International Workshop on Approximation Algorithms for Combinatorial Optimization, pages 84\u201395. Springer, 2000. [7] M. Charikar. Greedy approximation algorithms for finding dense components in a"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 57.04100036621094,
                            "x2": 299.7966613769531,
                            "y1": 235.6492919921875,
                            "y2": 271.73101806640625
                        },
                        "text": "graph. In Approximation Algorithms for Combinatorial Optimization, Third International Workshop, APPROX 2000, Saarbr\u00fccken, Germany, September 5-8, 2000, Proceedings, volume 1913 of Lecture Notes in Computer Science, pages 84\u201395. Springer, 2000. [8] C. Chekuri, K. Quanrud, and M. R. Torres. Densest subgraph: Supermodularity,"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 57.04100036621094,
                            "x2": 299.2063293457031,
                            "y1": 275.499267578125,
                            "y2": 295.6409912109375
                        },
                        "text": "iterative peeling, and flow. In Proceedings of the 2022 Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 1531\u20131555. SIAM, 2022. [9] J. Chen and Y. Saad. Dense subgraph extraction with application to community"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.7943115234375,
                            "y1": 299.4092712402344,
                            "y2": 319.552001953125
                        },
                        "text": "detection. IEEE Transactions on knowledge and data engineering, 24(7):1216\u20131230, 2010. [10] Y. Chen, J. Jiang, S. Sun, B. He, and M. Chen. Rush: Real-time burst subgraph"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.7919616699219,
                            "y1": 323.3202819824219,
                            "y2": 359.4020080566406
                        },
                        "text": "detection in dynamic graphs. Proceedings of the VLDB Endowment, 17(11):3657\u2013 3665, 2024. [11] N. Chiba and T. Nishizeki. Arboricity and subgraph listing algorithms. SIAM Journal on computing, 14(1):210\u2013223, 1985. [12] L. Chu, Y. Zhang, Y. Yang, L. Wang, and J. Pei. Online density bursting subgraph"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.7957458496094,
                            "y1": 363.1702880859375,
                            "y2": 383.3130187988281
                        },
                        "text": "detection from temporal graphs. Proceedings of the VLDB Endowment, 12(13):2353\u2013 2365, 2019. [13] L. Dagum and R. Menon. Openmp: an industry standard api for shared-memory"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.798004150390625,
                            "x2": 300.0975036621094,
                            "y1": 387.0812683105469,
                            "y2": 399.25299072265625
                        },
                        "text": "programming. IEEE computational science and engineering, 5(1):46\u201355, 1998. [14] M. Danisch, O. Balalau, and M. Sozio. Listing k-cliques in sparse real-world graphs."
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.79801940917969,
                            "x2": 299.0284118652344,
                            "y1": 403.0212707519531,
                            "y2": 415.1929931640625
                        },
                        "text": "In Proceedings of the 2018 World Wide Web Conference, pages 589\u2013598, 2018. [15] M. Danisch, T.-H. H. Chan, and M. Sozio. Large scale density-friendly graph"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.79798889160156,
                            "x2": 299.2090148925781,
                            "y1": 418.9612731933594,
                            "y2": 439.1029968261719
                        },
                        "text": "decomposition via convex programming. In Proceedings of the 26th International Conference on World Wide Web, pages 233\u2013242, 2017. [16] L. Dhulipala, J. Shi, T. Tseng, G. E. Blelloch, and J. Shun. The graph based benchmark"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.79296875,
                            "y1": 442.87127685546875,
                            "y2": 470.9840087890625
                        },
                        "text": "suite (gbbs). In Proceedings of the 3rd Joint International Workshop on Graph Data Management Experiences & Systems (GRADES) and Network Data Analytics (NDA), pages 1\u20138, 2020. [17] Y. Dourisboure, F. Geraci, and M. Pellegrini. Extraction and classification of dense"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.797996520996094,
                            "x2": 299.02850341796875,
                            "y1": 474.7522888183594,
                            "y2": 494.8940124511719
                        },
                        "text": "communities in the web. In Proceedings of the 16th international conference on World Wide Web, pages 461\u2013470, 2007. [18] A. Epasto, S. Lattanzi, and M. Sozio. Efficient densest subgraph computation in"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.798004150390625,
                            "x2": 299.0284729003906,
                            "y1": 498.66229248046875,
                            "y2": 518.8040161132812
                        },
                        "text": "evolving graphs. In Proceedings of the 24th international conference on world wide web, pages 300\u2013310, 2015. [19] D. Gibson, R. Kumar, and A. Tomkins. Discovering large dense subgraphs in"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 300.1025695800781,
                            "y1": 522.5733032226562,
                            "y2": 542.7149658203125
                        },
                        "text": "massive graphs. In Proceedings of the 31st international conference on Very large data bases, pages 721\u2013732. Citeseer, 2005. [20] A. Gionis and C. E. Tsourakakis. Dense subgraph discovery: Kdd 2015 tutorial."
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 69.23400115966797,
                            "x2": 299.0292663574219,
                            "y1": 546.4832763671875,
                            "y2": 558.655029296875
                        },
                        "text": "In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 2313\u20132314, 2015."
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.797996520996094,
                            "x2": 300.0994567871094,
                            "y1": 565.0349731445312,
                            "y2": 574.594970703125
                        },
                        "text": "[21] A. V. Goldberg. Finding a maximum density subgraph. 1984. [22] A. V. Goldberg and R. E. Tarjan. A new approach to the maximum-flow problem."
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.79798889160156,
                            "x2": 299.2816162109375,
                            "y1": 578.36328125,
                            "y2": 590.5360107421875
                        },
                        "text": "Journal of the ACM (JACM), pages 921\u2013940, 1988. [23] N. V. Gudapati, E. Malaguti, and M. Monaci. In search of dense subgraphs: How"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.797996520996094,
                            "x2": 299.0245056152344,
                            "y1": 594.3042602539062,
                            "y2": 606.4760131835938
                        },
                        "text": "good is greedy peeling? Networks, 77(4):572\u2013586, 2021. [24] B. Hooi, H. A. Song, A. Beutel, N. Shah, K. Shin, and C. Faloutsos. Fraudar: Bounding"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.79800033569336,
                            "x2": 299.7902526855469,
                            "y1": 610.2442626953125,
                            "y2": 638.3560180664062
                        },
                        "text": "graph fraud in the face of camouflage. In Proceedings of the 22nd ACM SIGKDD international conference on knowledge discovery and data mining, pages 895\u2013904, 2016. [25] M. Jaggi. Revisiting frank-wolfe: Projection-free sparse convex optimization. In"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 69.23400115966797,
                            "x2": 277.1656188964844,
                            "y1": 642.124267578125,
                            "y2": 646.3259887695312
                        },
                        "text": "International conference on machine learning, pages 427\u2013435. PMLR, 2013."
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.79798889160156,
                            "x2": 299.0242919921875,
                            "y1": 652.7059936523438,
                            "y2": 654.2960205078125
                        },
                        "text": "[26] J. Jiang, Y. Chen, B. He, M. Chen, and J. Chen. Spade+: A generic real-time fraud"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 53.798004150390625,
                            "x2": 299.0245361328125,
                            "y1": 658.0652465820312,
                            "y2": 678.20703125
                        },
                        "text": "detection framework on dynamic graphs. IEEE Transactions on Knowledge and Data Engineering, 2024. [27] M. Jiang, P. Cui, A. Beutel, C. Faloutsos, and S. Yang. Inferring strange behavior from"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 69.23400115966797,
                            "x2": 299.0282897949219,
                            "y1": 681.9752807617188,
                            "y2": 694.14697265625
                        },
                        "text": "connectivity pattern in social networks. In Pacific-Asia conference on knowledge discovery and data mining, pages 126\u2013138. Springer, 2014."
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2042236328125,
                            "y1": 92.0589599609375,
                            "y2": 93.6490478515625
                        },
                        "text": "[28] J. Jiaxin, L. Yuan, H. Bingsheng, H. Bryan, C. Jia, and J. K. Z. Kang. A real-time"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9740295410156,
                            "x2": 558.2042236328125,
                            "y1": 97.41730499267578,
                            "y2": 109.5889892578125
                        },
                        "text": "fraud detection framework on evolving graphs. PVLDB, 2023. [29] S. Kumar, W. L. Hamilton, J. Leskovec, and D. Jurafsky. Community interaction"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2042236328125,
                            "y1": 113.35730743408203,
                            "y2": 133.4990234375
                        },
                        "text": "and conflict on the web. In Proceedings of the 2018 world wide web conference, pages 933\u2013943, 2018. [30] V. E. Lee, N. Ruan, R. Jin, and C. Aggarwal. A survey of algorithms for dense"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.273193359375,
                            "y1": 137.26824951171875,
                            "y2": 157.40997314453125
                        },
                        "text": "subgraph discovery. In Managing and mining graph data, pages 303\u2013336. Springer, 2010. [31] J. Leskovec and A. Krevl. SNAP Datasets: Stanford large network dataset collection."
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 328.4100036621094,
                            "x2": 443.40802001953125,
                            "y1": 163.78997802734375,
                            "y2": 165.3800048828125
                        },
                        "text": "http://snap.stanford.edu/data, June 2014."
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2044067382812,
                            "y1": 171.75994873046875,
                            "y2": 173.3499755859375
                        },
                        "text": "[32] W. Luo, Z. Tang, Y. Fang, C. Ma, and X. Zhou. Scalable algorithms for densest"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.201904296875,
                            "y1": 177.1182861328125,
                            "y2": 197.260009765625
                        },
                        "text": "subgraph discovery. In 2023 IEEE 39th International Conference on Data Engineering (ICDE), pages 287\u2013300. IEEE, 2023. [33] C. Ma, Y. Fang, R. Cheng, L. V. Lakshmanan, and X. Han. A convex-programming"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.2046508789062,
                            "y1": 201.02825927734375,
                            "y2": 221.1710205078125
                        },
                        "text": "approach for efficient directed densest subgraph discovery. In Proceedings of the 2022 International Conference on Management of Data, pages 845\u2013859, 2022. [34] M. Mitzenmacher, J. Pachocki, R. Peng, C. Tsourakakis, and S. C. Xu. Scalable"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.3826293945312,
                            "y1": 224.93927001953125,
                            "y2": 253.3790283203125
                        },
                        "text": "large near-clique detection in large-scale networks via sampling. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 815\u2013824, 2015. [35] V. Podpe\u010dan, \u017d. Ram\u0161ak, K. Gruden, H. Toivonen, and N. Lavra\u010d. Interactive explo-"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.9685668945312,
                            "y1": 257.14727783203125,
                            "y2": 277.28900146484375
                        },
                        "text": "ration of heterogeneous biological networks with biomine explorer. Bioinformatics, 06 2019. [36] H. Qin, R.-H. Li, Y. Yuan, G. Wang, L. Qin, and Z. Zhang. Mining bursting core in"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.203125,
                            "y1": 281.0572814941406,
                            "y2": 293.22900390625
                        },
                        "text": "large temporal graphs. Proceedings of the VLDB Endowment, 2022. [37] Y. Ren, H. Zhu, J. Zhang, P. Dai, and L. Bo. Ensemfdet: An ensemble approach to"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.20361328125,
                            "y1": 296.9972839355469,
                            "y2": 317.1400146484375
                        },
                        "text": "fraud detection based on bipartite graph. In 2021 IEEE 37th International Conference on Data Engineering (ICDE), pages 2039\u20132044. IEEE, 2021. [38] R. A. Rossi and N. K. Ahmed. The network data repository with interactive graph"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.2733154296875,
                            "y1": 320.90826416015625,
                            "y2": 333.0799865722656
                        },
                        "text": "analytics and visualization. In AAAI, 2015. [39] A. E. Sar\u0131y\u00fcce andA. Pinar. Peeling bipartite networks for dense subgraph discovery."
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.279052734375,
                            "y1": 336.8482666015625,
                            "y2": 372.9309997558594
                        },
                        "text": "In Proceedings of the Eleventh ACM International Conference on Web Search and Data Mining, pages 504\u2013512, 2018. [40] S. B. Seidman. Network structure and minimum degree. Social networks, 5(3):269\u2013 287, 1983. [41] J. Shi, L. Dhulipala, and J. Shun. Parallel clique counting and peeling algorithms."
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.9683227539062,
                            "y1": 376.69927978515625,
                            "y2": 396.84100341796875
                        },
                        "text": "In SIAM Conference on Applied and Computational Discrete Algorithms (ACDA21), pages 135\u2013146. SIAM, 2021. [42] K. Shin, T. Eliassi-Rad, and C. Faloutsos. Corescope: Graph mining using k-core"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.3369750976562,
                            "y1": 400.6092834472656,
                            "y2": 420.7510070800781
                        },
                        "text": "analysis\u2014patterns, anomalies and algorithms. In 2016 IEEE 16th international conference on data mining (ICDM), pages 469\u2013478. IEEE, 2016. [43] K. Shin, B. Hooi, J. Kim, and C. Faloutsos. Densealert: Incremental dense-subtensor"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9740295410156,
                            "x2": 558.20458984375,
                            "y1": 424.519287109375,
                            "y2": 444.6620178222656
                        },
                        "text": "detection in tensor streams. In Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 1057\u20131066, 2017. [44] P. Sukprasert, Q. C. Liu, L. Dhulipala, and J. Shun. Practical parallel algorithms"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 559.2731323242188,
                            "y1": 448.4302673339844,
                            "y2": 476.5419921875
                        },
                        "text": "for near-optimal densest subgraphs on massive graphs. In 2024 Proceedings of the Symposium on Algorithm Engineering and Experiments (ALENEX), pages 59\u201373. SIAM, 2024. [45] B. Sun, M. Danisch, T. H. Chan, and M. Sozio. Kclist++: A simple algorithm"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 312.9739990234375,
                            "x2": 558.3358764648438,
                            "y1": 480.3102722167969,
                            "y2": 516.3930053710938
                        },
                        "text": "for finding k-clique densest subgraphs in large graphs. Proceedings of the VLDB Endowment (PVLDB), 2020. [46] C. Tsourakakis. The k-clique densest subgraph problem. In Proceedings of the 24th international conference on world wide web, pages 1122\u20131132, 2015. [47] C. Ye, Y. Li, B. He, Z. Li, and J. Sun. Gpu-accelerated graph label propagation for"
                    },
                    {
                        "page": 13,
                        "region": {
                            "x1": 328.4100036621094,
                            "x2": 558.202880859375,
                            "y1": 520.1613159179688,
                            "y2": 532.3330078125
                        },
                        "text": "real-time fraud detection. In Proceedings of the 2021 International Conference on Management of Data, pages 2348\u20132356, 2021."
                    }
                ],
                "title": {
                    "page": 13,
                    "region": {
                        "x1": 53.798004150390625,
                        "x2": 123.21259307861328,
                        "y1": 86.7980728149414,
                        "y2": 93.64898681640625
                    },
                    "text": "REFERENCES"
                }
            }
        ]
    },
    "structured_data": {
        "abstract": "ABSTRACT Detecting fraudulent activities in financial and e-commerce transac- tion networks is crucial, and one effective method for this is Densest Subgraph Discovery (DSD). However, deploying DSD methods in production systems faces substantial scalability challenges due to the predominantly sequential nature of existing methods, which impedes their ability to handle large-scale transaction networks and results in significant detection delays. In this paper, we introduce Dupin, a novel parallel processing framework designed for efficient DSD processing in billion-scale graphs. Dupin is powered by a processing engine that exploits the unique properties of the peeling process, with theoretical guarantees on detection quality and efficiency.Dupin provides user-friendly APIs for flexible customization of DSD objectives and ensures robust adaptability to diverse fraud detection scenarios. Empirical evaluations indicate that Dupin outperforms several existing DSD methods, with performance improvements observed in specific scenarios reaching up to two orders of magnitude. On billion-scale graphs, Dupin demonstrates the potential to enhance the prevention of fraudulent transactions by approximately 49.5 basis points and reduce density error from 30% to below 5%, as supported by our experimental results. ACM Reference Format: Anonymous Author(s). 2024. Dupin: A Parallel Densest Subgraph Discovery Framework on Massive Graphs. In Proceedings of ACM Conference (Conference\u201917). ACM, New York, NY, USA, 14 pages. https://doi.org/10.1145/ nnnnnnn.nnnnnnn",
        "introduction": "Graph structures pervade numerous contemporary applications, ranging from transaction and communication networks to expan- sive social media platforms. The study of densest subgraph discovery (DSD), first explored by [21], has since proven instrumental in various domains: link spam identification [4, 19], community de- tection [9, 17], and notably, fraud detection [8, 24, 42]. Central to this domain is the peeling process [2, 5, 8, 24, 46], which operates by iteratively removing vertices based on density metrics, such as vertex degree or the cumulative weight of adjacent edges. Their widespread adoption can be attributed to their inherent efficiency, robustness, and proven worst-case performance guarantees for DSD. In practice, business requirements demand the detection of fraud- ulent communities on billion-scale graphs within seconds. Recent Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. Conference\u201917, July 2017, Washington, DC, USA \u00a9 2024 Association for Computing Machinery. ACM ISBN 978-x-xxxx-xxxx-x/YY/MM. . . $15.00 https://doi.org/10.1145/nnnnnnn.nnnnnnn studies, including those by [1] and [47], have highlighted the perva- sive issue of malicious bot activity in e-commerce, accounting for a substantial 21.4% of all traffic in 2018. These fraudulent activities often happen quickly, making them hard to detect. The inability to efficiently process and analyze such massive graphs not only ham- pers fraud detection efforts but also exposes businesses to substan- tial financial risks and reputational damage. Therefore, addressing these challenges is not merely an academic exercise; it is a press- ing necessity for enhancing the integrity of digital transactions and safeguarding consumer trust. Despite extensive research onDSD for static graphs [20\u201322, 30, 33, 34], dynamic graphs [2, 18, 26, 28, 43], and parallel approaches [14, 16, 41, 42], existing methods face significant challenges for practical de- ployment in real-world fraud detection systems. For instance, many existing algorithms primarily rely on static score functions for DSD, lacking the flexibility required for dynamic and evolving fraud detec- tion scenarios. Methods such as [4] and [27] are designed with fixed detection criteria, which can become less effective as fraudulent be- haviors adapt over time. Additionally, incremental algorithms remain inefficient at handling billion-scale graphs with high transaction volumes, leading to increased latency. Parallel DSD frameworks often lack efficient pruning techniques, resulting in excessive iterations that degrade performance on large-scale graphs. This paper addresses the following research question: How can we enhance the efficiency and scalability of DSD methods to effectively detect fraud in massive graphs? Challenges. We evaluated existing methods with our industry partner, Anon (anonymized for review). The following issues surfaced: Firstly, existing algorithms focus on static score functions for DSD and lack flexible customization. While this may be adequate for short-term detection, it becomes less effective over time. For example, as shown in Figure 1a, graph density can accumulate sig- nificant errors within a single day, highlighting the need for more adaptive and customizable detection methods. Secondly, existing incremental algorithms are still inefficient at handling billion-scale graphs with high transaction volumes, leading to increased latency. This limitation is evident in Figure 1b, which illustrates the system load distribution for a specific day\u2019s transactions, underscoring the inability of current methods to efficiently manage high transaction volumes without significant delays. Thirdly, existing parallel densest subgraph discovery frameworks lack efficient pruning techniques, re- sulting in a large number of iterations. This inefficiency is especially problematic on billion-scale graphs, where performance degrades substantially due to the excessive computational overhead caused by numerous iterations. Adapting to Evolving Research Needs. Recognizing the dynamic nature of fraud detection and the rapid evolution of fraudulent tactics, we have adapted our research focus to address these challenges. Our approach incorporates flexible customization options for DSD methods, allowing for adjustments based on the changing landscape of fraudulent activities. This adaptability is crucial for maintaining the effectiveness of fraud detection systems in an environment where new threats continuously emerge. Contributions. In this work, we propose a DSD framework for fraud detection. Our key contributions are as follows: \u2022 A DSD Parallelization Framework. We propose Dupin, a novel parallel processing framework for densest subgraph discovery (DSD) that breaks the sequential dependencies inherent in tra- ditional density metrics, significantly enhancing scalability and efficiency on both weighted and unweighted graphs. Unlike existing methods that focus on specific density metrics, Dupin allows developers to define custom fraud detection semantics through flexible suspiciousness functions for edges and vertices. It supports a wide range of DSD semantics, including DG [6], DW [23], FD [24], TDS [46], and \ud835\udc58CLiDS [14]. Importantly, Dupin not only leverages parallelism but also provides theoretical guarantees on approximation ratios for the supported density metrics. To the best of our knowledge, this is the first generic parallel processing framework that accommodates a broad class of density metrics in DSD, offering both flexibility and theoretical assurance. \u2022 Exploiting Long-Tail Properties.We identify and address the long-tail problem in the peeling process of DSD algorithms, where late iterations remove only a small fraction of vertices and con- tribute little to the quality of the densest subgraph, leading to inefficiency. To tackle this, we introduce two novel optimizations: Global Pruning Optimization, which proactively removes low-contribution vertices within each peeling iteration to reduce computational overhead, and Local Pruning Optimization, which eliminates disparate structures formed after vertex removal to enhance the density and quality of the detected subgraph. These optimizations significantly reduce the number of iterations re- quired, improving both performance and result quality. \u2022 Empirical Validation and Real-World Impact: We conduct comprehensive experiments on large-scale industry datasets to validate the effectiveness of Dupin. Our results show that Dupin achieves up to 100 times faster fraud detection compared to the state-of-the-art incremental method Spade [28] and parallel methods like PBBS [41]. Moreover,Dupin is capable of preventing up to 94.5% of potential fraud, demonstrating significant practical bene- fits and reinforcing system integrity in real-world applications. Organization. The remainder of this paper is structured as follows: Section 2 presents the background and the literature review. Section 3 introduces the architecture of Dupin. In Section 4, we propose the theoretical foundations for parallel peeling-based algorithms for DSD. Section 5 introduces long-tail pruning techniques to improve efficiency and effectiveness. The experimental evaluation of Dupin is presented in Section 6. Finally, Section 7 concludes the paper and outlines avenues for future research.",
        "background and relatedwork": "2.1 Preliminary This subsection presents the preliminary. Some frequently used no- tations are summarized in Table 1. Graph \ud835\udc3a . In this work, we operate on a weighted graph denoted as \ud835\udc3a = (\ud835\udc49 , \ud835\udc38), where \ud835\udc49 represents the set of vertices and \ud835\udc38 (\u2286 \ud835\udc49 \u00d7\ud835\udc49 ) represents the set of edges. Each edge (\ud835\udc62\ud835\udc56 , \ud835\udc62 \ud835\udc57 ) \u2208 \ud835\udc38 is assigned a nonnegative weight, expressed as \ud835\udc50\ud835\udc56 \ud835\udc57 . Additionally, \ud835\udc41 (\ud835\udc62) denotes the set of neighboring vertices connected to vertex \ud835\udc62. Induced Subgraph. For a given subset \ud835\udc46 of vertices in \ud835\udc49 , we define the induced subgraph as \ud835\udc3a[\ud835\udc46] = (\ud835\udc46, \ud835\udc38[\ud835\udc46]), where \ud835\udc38[\ud835\udc46] = {(\ud835\udc62, \ud835\udc63) | (\ud835\udc62, \ud835\udc63) \u2208 \ud835\udc38 \u2227 \ud835\udc62, \ud835\udc63 \u2208 \ud835\udc46}. The size of the subset \ud835\udc46 is denoted by |\ud835\udc46 |. Density Metrics \ud835\udc54 and Weight Function \ud835\udc53 . We utilize the class of metrics\ud835\udc54 as defined in prior works [6, 24, 28], where for a given subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the density metric is computed as: \ud835\udc54(\ud835\udc46) = \ud835\udc53 (\ud835\udc46) |\ud835\udc46 | . Here, \ud835\udc53 (\ud835\udc46) represents the total weight of the induced subgraph \ud835\udc3a[\ud835\udc46], which is defined as the sum of the weights of vertices in \ud835\udc46 and the weights of edges in \ud835\udc38[\ud835\udc46]. More formally: \ud835\udc53 (\ud835\udc46) = \u2211\ufe01 \ud835\udc62\ud835\udc56 \u2208\ud835\udc46 \ud835\udc4e\ud835\udc56 + \u2211\ufe01 (\ud835\udc62\ud835\udc56 ,\ud835\udc62 \ud835\udc57 )\u2208\ud835\udc38[\ud835\udc46] \ud835\udc50\ud835\udc56 \ud835\udc57 (1) The weight of a vertex \ud835\udc62\ud835\udc56 , denoted as \ud835\udc4e\ud835\udc56 (\ud835\udc4e\ud835\udc56 \u2265 0), quantifies the suspiciousness of user \ud835\udc62\ud835\udc56 . The weight of an edge (\ud835\udc62\ud835\udc56 , \ud835\udc62 \ud835\udc57 ), represented by \ud835\udc50\ud835\udc56 \ud835\udc57 (\ud835\udc50\ud835\udc56 \ud835\udc57 > 0), reflects the suspiciousness of the transaction between users \ud835\udc62\ud835\udc56 and \ud835\udc62 \ud835\udc57 . Intuitively, the density metric \ud835\udc54(\ud835\udc46) encapsulates the overall suspiciousness density of the induced subgraph\ud835\udc3a[\ud835\udc46]. A larger value of \ud835\udc54(\ud835\udc46) indicates a higher density of suspiciousness within\ud835\udc3a[\ud835\udc46]. The vertex set that maximizes the density metric \ud835\udc54 is denoted by \ud835\udc46\u2217. We next introduce five representative density metrics extensively employed in many fraud detection applications. The density metrics are mainly differed by how the weight function is defined. Dense Subgraphs (DG) [6]. The DG metric is employed to quan- tify the connectivity of substructures within a graph. It has found extensive applications in various domains, such as detecting fake comments in online platforms [29] and identifying fraudulent activities in social networks [3]. Given a subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of DG is defined as \ud835\udc53 (\ud835\udc46) = |\ud835\udc38[\ud835\udc46]|, where |\ud835\udc38[\ud835\udc46]| denotes the number of edges in the induced subgraph \ud835\udc3a[\ud835\udc46]. Dense Subgraph on Weighted Graphs (DW) [23]. In transac- tion graphs, it is common to have weights assigned to the edges, representing quantities such as the transaction amount. The DW metric extends the concept of dense subgraphs to accommodate these weighted relationships. Given a subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of DW is defined as \ud835\udc53 (\ud835\udc46) = \u2211 (\ud835\udc62\ud835\udc56 ,\ud835\udc62 \ud835\udc57 )\u2208\ud835\udc38[\ud835\udc46] \ud835\udc50\ud835\udc56 \ud835\udc57 . Fraudar (FD) [24]. In order to mitigate the effects of fraudulent actors deliberately obfuscating their activities, Hooi et al. [24] introduced the FD algorithm. This approach innovatively incorporates weights for edges and assigns prior suspiciousness scores to vertices, potentially utilizing side information to enhance detection accuracy. Given a subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of FD is defined as Equation 1 where \ud835\udc4e\ud835\udc56 denotes the suspicious score of vertex \ud835\udc62\ud835\udc56 and \ud835\udc50\ud835\udc56 \ud835\udc57 = 1 log(\ud835\udc65+\ud835\udc50) . Here \ud835\udc65 is the degree of the object vertex between \ud835\udc62\ud835\udc56 and \ud835\udc62 \ud835\udc57 , and \ud835\udc50 is a positive constant [24]. Triangle Densest Subgraph (TDS) [46]. Triangles serve as a crucial structural motif in graphs, providing valuable insights into the connectivity and cohesiveness of subgraphs. The TDS metric, in par- ticular, leverages the prevalence of triangles to quantify the density of a subgraph. Given a subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of TDS is defined as \ud835\udc53 (\ud835\udc46) = \ud835\udc61 (\ud835\udc46) where \ud835\udc61 (\ud835\udc46) represents the total number of triangles within the induced subgraph \ud835\udc3a[\ud835\udc46]. \ud835\udc58-Clique Densest Subgraph (\ud835\udc58CLiDS) [14]. Extending the concept of triangle densest subgraphs, \ud835\udc58CLiDS focuses on identifying dense subgraphs based on the presence of \ud835\udc58-Cliques. A \ud835\udc58-Clique is a complete subgraph of \ud835\udc58 vertices, representing a tightly-knit group of vertices. For a given subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of \ud835\udc58CLiDS is defined as \ud835\udc53 (\ud835\udc46) = \ud835\udc58(\ud835\udc46), where \ud835\udc58(\ud835\udc46) denotes the number of \ud835\udc58-Cliques within the induced subgraph \ud835\udc3a[\ud835\udc46]. 2.2 Sequential Peeling Algorithms Peeling algorithms have gained popularity for their efficiency, ro- bustness, and proven worst-case performance in various applica- tions [6, 24, 46]. Next, we provide a concise overview of the typical execution flow of these algorithms. Peeling Weight.We use\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46) to indicate the decrease in the value of the weight function \ud835\udc53 when the vertex\ud835\udc62\ud835\udc56 is removed from a vertex set \ud835\udc46 , i.e., the peeling weight. Formally, \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46) = \ud835\udc4e\ud835\udc56 + \u2211\ufe01 (\ud835\udc62 \ud835\udc57 \u2208\ud835\udc46) \u2227 ((\ud835\udc62\ud835\udc56 ,\ud835\udc62 \ud835\udc57 )\u2208\ud835\udc38) \ud835\udc50\ud835\udc56 \ud835\udc57 + \u2211\ufe01 (\ud835\udc62 \ud835\udc57 \u2208\ud835\udc46) \u2227 ((\ud835\udc62 \ud835\udc57 ,\ud835\udc62\ud835\udc56 )\u2208\ud835\udc38) \ud835\udc50 \ud835\udc57\ud835\udc56 (2) Algorithm 1: Sequential Peeling Algorithm Input: A graph\ud835\udc3a = (\ud835\udc49 , \ud835\udc38) and a density metric \ud835\udc54(\ud835\udc46) Output: A subset of vertices \ud835\udc46 that maximizes the density metric \ud835\udc54(\ud835\udc46) 1 \ud835\udc460 \u2190 \ud835\udc49 /* Initialize the subset with all vertices */ 2 for \ud835\udc56 \u2190 1 to |\ud835\udc49 | do 3 \ud835\udc62 \u2190 arg max\ud835\udc63\u2208\ud835\udc46\ud835\udc56\u22121 \ud835\udc54(\ud835\udc46\ud835\udc56\u22121 \\ {\ud835\udc63 }) /* The vertex to be peeled */ 4 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56\u22121 \\ {\ud835\udc62 } /* The selected vertex */ 5 return arg max\ud835\udc46\ud835\udc56 \ud835\udc54(\ud835\udc46\ud835\udc56 ) /* The subset that maximizes \ud835\udc54(\ud835\udc46) */ Sequential PeelingAlgorithm (Algorithm1).The peeling process starts with the full vertex set \ud835\udc460 = \ud835\udc49 (Line 1) and iteratively removes vertices to maximize the density metric \ud835\udc54. In each step \ud835\udc56 , a vertex\ud835\udc62\ud835\udc56 is removed from \ud835\udc46\ud835\udc56\u22121 to form \ud835\udc46\ud835\udc56 , such that \ud835\udc54(\ud835\udc46\ud835\udc56\u22121 \\ {\ud835\udc62\ud835\udc56 }) is maximized (Lines 3\u223c4). This process is repeated until \ud835\udc46\ud835\udc56 becomes empty, resulting in a sequence of nested sets \ud835\udc460, \ud835\udc461, . . . , \ud835\udc46 |\ud835\udc49 | . The algorithm ultimately returns the subset \ud835\udc46\ud835\udc56 \u2208 {\ud835\udc460, . . . , \ud835\udc46 |\ud835\udc49 |} that maximizes \ud835\udc54(\ud835\udc46\ud835\udc56 ). Example 2.1 (Seqential Peeling Algorithm Process). Consider the graph \ud835\udc3a as shown in Figure 2. The process begins with an initial graph density of 2.33. In the first iteration, vertex \ud835\udc621 is peeled due to its smallest peeling weight among all vertices. Subsequently, vertices are peeled in the following order: \ud835\udc622, \ud835\udc623, \ud835\udc624, \ud835\udc625, and \ud835\udc626 based on the updated criteria after each peeling operation. Notably, after peeling \ud835\udc622, the graph density increases, which is a characteristic observation in the peeling process. The sequence of peeling continues until the last vertex, \ud835\udc626, is peeled, resulting in a final graph density of 0. The peeling sequence, therefore, is \ud835\udc42 = [\ud835\udc621, \ud835\udc622, \ud835\udc623, \ud835\udc624, \ud835\udc625, \ud835\udc626], completely disassembling the graph. The induced subgraph\ud835\udc3a[\ud835\udc46] of \ud835\udc46 = [\ud835\udc623, \ud835\udc624, \ud835\udc625, \ud835\udc626] has the greatest density of 2.75, thus \ud835\udc3a[\ud835\udc46] is returned. Approximation. An algorithm \ud835\udc44 is defined as an \ud835\udefc-approximation for the Densest Subgraph Discovery (DSD), where \ud835\udefc \u2265 1, if for any given graph it returns a subset \ud835\udc46 satisfying the condition: \ud835\udc54(\ud835\udc46) \u2265 \ud835\udc54(\ud835\udc46\u2217) \ud835\udefc , where \ud835\udc46\u2217 is the optimal subset that maximizes the density metric \ud835\udc54. Theorem 2.1 ([24]). For the vertex set \ud835\udc46\ud835\udc5d returned by Algorithm 1 and the optimal vertex set \ud835\udc46\u2217, it holds that \ud835\udc54(\ud835\udc46\ud835\udc5d ) \u2265 \ud835\udc54(\ud835\udc46\u2217) 2 for DG, DW and FD as the density metrics. We extend the analysis to TDS and \ud835\udc58CLiDS. The proof of the following theorem is omitted due to space limitation. Theorem 2.2. For the vertex set \ud835\udc46\ud835\udc5d returned by Algorithm 1 and the optimal vertex set \ud835\udc46\u2217, it holds that \ud835\udc54(\ud835\udc46\ud835\udc5d ) \u2265 \ud835\udc54(\ud835\udc46\u2217) \ud835\udc58 for TDS and \ud835\udc58CLiDS as the density metrics where \ud835\udc58 = 3 for TDS. 2.3 Related work Densest Subgraph Discovery (DSD). Densest subgraph discov- ery represents a core area of research in graph theory, extensively explored in literature [7, 8, 20, 30, 39, 40]. The foundational max-flow- based algorithm by Goldberg et al. [21] set a benchmark for exact densest subgraph detection, with subsequent studies introducing more scalable exact solutions [33, 34]. While speed enhancements have been achieved through various greedy approaches [6, 8, 24, 33], these methods are inherently sequential and difficult to parallelize. For example, they often peel one vertex at a time, which results in too many peeling iterations. This sequential nature limits their scalability and efficiency on massive graphs. In graph-based fraud de- tection, techniques like COPYCATCH [4] and GETTHESCOOP [27] leverage local search heuristics to identify dense subgraphs in bi- partite networks, frequently applied in fraud, spam, and community detection across social and review platforms [24, 37, 42]. Despite their widespread use, these methods suffer from efficiency issues in very large graphs, often involving numerous iterations and lack- ing effective pruning techniques, which exacerbates the long-tail problem. Moreover, they are limited to specific definitions of dense subgraphs. Contrarily, Dupin offers a versatile, parallel approach to densest subgraph detection. It facilitates the simultaneous peeling of multiple vertices, drastically reducing the computational overhead. Additionally, Dupin provides APIs that allow users to customize defi- nitions of dense subgraphs, ensuring that the resultant graph density adheres to theoretical bounds. DSD on Dynamic Graphs. To tackle real-time fraud detection, sev- eral variants have been designed for dynamic graphs [10, 18, 26, 28, 43]. [28] addresses real-time fraud community detection on evolving graphs (edge insertions) using an incremental peeling sequence re- ordering method, while [26] extends this approach to fully dynamic graphs (edge insertions and deletions). [43] proposes an incremental algorithm that maintains and updates a dense subtensor in a ten- sor stream. [12] and [36] utilize sliding windows to detect dense subgraphs and bursting cores within specific time windows. These methods have three limitations. First, response time is an issue. Al- though they respond quickly to benign communities, the results can change drastically for newly formed fraudulent communities, caus- ing significant delays in incremental calculations for fraud detection. Second, efficiency is problematic. While incremental processing is faster than recomputation for a single transaction on billion-scale graphs, frequent incremental evaluations can be slower than a full recomputation. Third, in terms of flexibility, most methods support only a single semantic. In contrast, Dupin introduces a unified parallel framework for peeling-based dense subgraph detection.Dupin can respond within seconds on billion-scale graphs and defines multiple density metrics that can be used on the Dupin platform. Parallel DSD. Several parallel methods for DSD have been pro- posed [2, 14, 16, 39, 41, 42]. Bahmani et al. [2] proposed a parallel algorithm for DG using the MapReduce framework. FWA [15] proposed a parallel algorithm for DW based on Frank-Wolfe algo- rithm [25] using OpenMP [13]. Some works propose parallel \ud835\udc58-core algorithms [32, 41, 44]. Others introduce parallel algorithms for \ud835\udc58- Clique detection, with approaches offering a (1 + \ud835\udf16)-approximation ratio and parallel implementations for the \ud835\udc58CLiDS problem [16, 45]. There are also algorithms for \ud835\udc58-Clique densest subgraph detection using OpenMP [14], and methods for dense subtensor detection [42]. However, these systems have two main limitations. First, they typi- cally support only a single-densitymetric and do not handle weighted graphs. In real-world applications, transactions between users can have varying degrees of importance based on amounts, frequen- cies [28], and other factors. Extending these systems to support other dense metrics with theoretical guarantees is non-trivial. Second, they often lack efficient pruning techniques, requiring numerous itera- tions and suffering from the long-tail issue, which hinders scalability on massive graphs. In contrast, Dupin defines the characteristics of a set of supported dense metrics and accommodates weighted sub- graphs, allowing for more nuanced analysis reflective of real-world data. Our method introduces efficient pruning strategies by peeling multiple vertices in parallel based on a threshold mechanism, signifi- cantly reducing the number of iterations and mitigating the long-tail problem. This makes Dupin more effective and scalable in diverse real-world scenarios compared to previous approaches. 3 THE Dupin FRAMEWORK 3.1 Motivations A notable example of advanced fraud detection is seen in Anon, a prominent technology company in Southeast Asia known for its digital payment and food delivery services. As delineated in [28], the detection process begins with forming a transaction graph,\ud835\udc3a , derived from the platform\u2019s transactions. This graph is incrementally updated, represented as \ud835\udc3a = \ud835\udc3a \u2295 \u2206\ud835\udc3a . Subsequent stages utilize densest subgraph discovery algorithms to uncover fraudulent communities. A typical fraud scenario on the platform involves customer-merchant collusion, where fake accounts are created to exploit promotional incentives. These fraudulent activities manifest as densest subgraphs within the transaction graph. Efficiency. Our empirical findings reveal that the incremental execution of DSD algorithms, such as Spade [28], on a graph with 2 billion edges requires approximately 198 seconds per batch (default setting: one batch of 1K edge insertions). However, in practical business sce- narios, the number of incoming edges can peak at 400K per minute. Clearly, using incremental evaluation on billion-scale graphs does not provide sufficient throughput to meet business requirements. Latency and Prevention Ratio. Existing DSD systems face sig- nificant challenges in terms of latency and prevention ratio. Upon identification of fraudulent activities, actions such as account bans or freezes are implemented to prevent further losses. However, the aver- age latency for these systems to detect fraud and take action is often high, typically around 200 to 300 seconds for incremental algorithms and more than 1000 seconds for existing parallel algorithms, which is insufficient for real-time requirements (operational demand requires detection within seconds). Moreover, when the graph size increases from million-scale to billion-scale, the prevention ratio decreases from 92.47% to 45%. These issues underscore the necessity for more efficient and scalable algorithms that can maintain low latency and high prevention ratios, even under heavy transaction loads. Parallelization offers a viable solution to these challenges by dis- tributing the computational load across multiple processors. Mod- ern CPUs are equipped with numerous cores that are cost-effective, enabling parallel processing. If the peeling process of DSD is paral- lelized, different processors can simultaneously evaluate and peel different nodes, thereby increasing scalability and efficiency. For example, if we can improve processing speed by one to two orders of magnitude, the system would be able to meet industry requirements for real-time fraud detection, completing detection within seconds. Problem Statement. Given a graph \ud835\udc3a = (\ud835\udc49 , \ud835\udc38) and a community detection semantic with density metric \ud835\udc54(\ud835\udc46), our goal is to find a vertex subset \ud835\udc46\u2217 \u2286 \ud835\udc49 that maximizes \ud835\udc54(\ud835\udc46\u2217). 3.2 System Architecture To enable users to design complex DSD algorithms to detect fraudsters based on our framework, Dupin, we have introduced the archi- tecture, APIs, and supported density metrics in this section. Architecture of Dupin. Figure 3 presents the architecture of Dupin with user-defined functions for detecting suspicious activities.Dupin enables users to define their fraud detection semantics through a set of provided APIs. Within Dupin\u2019s computational engine, we sup- port both sequential and parallel peeling algorithms. Additionally, algorithms for long-tail pruning techniques are implemented to ac- celerate convergence and enhance the density of subgraphs in each iteration. Dupin identifies fraudulent communities, which are then flagged for further investigation by moderators. APIs of Dupin (Figure 3). Dupin simplifies the process of defining detection semantics by allowing users to specify a few simple functions. Additionally, Dupin offers APIs that enable users to balance detection speed and accuracy effectively. The key APIs encompass several components designed to facilitate the customization and op- timization of fraud detection processes. These components provide a robust framework for users to implement their fraud detection strate- gies, ensuring both high performance and precision in identifying fraudulent activities. Details are listed below: \u2022 pWeight and updateNgh. These functions are designed for the dynamic adjustment of weights within the network. They allow the user to define the peeling weight of a vertex and specify the method for updating the peeling weight of neighboring vertices after a vertex has been peeled. \u2022 VSusp and ESusp. Given a vertex/edge, these components are re- sponsible for deciding the suspiciousness of the endpoint of the edge or the edge with a user-defined strategy. \u2022 isBenign. This component is used to decide whether a vertex is benign during the whole peeling process (Section 5). If the vertex is benign, it is peeled within the current iteration. \u2022 setEpsilon. This function is utilized to control the precision of fraud detection. During periods of high system load, moderators can increase \ud835\udf16 to achieve higher throughput. Conversely, when the system load is low, \ud835\udf16 can be decreased to enhance accuracy. \u2022 setK. This function specifies the \ud835\udc58-Clique parameter, enabling the definition of the \ud835\udc58-Clique for analysis. 1 double vsusp(const Vertex& v, const Graph& g) { 2 return g.weight[v]; // Side information on vertex 3 } 4 double esusp(const Edge& e, const Graph& g) { 5 return 1.0 / log(g.deg[e.src] + 5.0); 6 } 7 int main() { 8 Dupin dupin; 9 dupin.VSusp(vsusp); // Plug in vsusp 10 dupin.ESusp(esusp); // Plug in esusp 11 dupin.setEpsilon (0.1); 12 dupin.LoadGraph(\"graph_sample_path\"); 13 vector <Vertex > fraudsters = dupin.ParDetect (); 14 return 0; 15 } Listing 1: Implementation of FD on Dupin Example (Listing 1). To implement FD [24] on Dupin, users simply need to plug in the suspiciousness function vsusp for the vertices by calling VSusp and the suspiciousness function esusp for the edges by calling ESusp. Specifically, 1) vsusp is a constant function, i.e., given a vertex \ud835\udc62, vsusp(\ud835\udc62) = \ud835\udc4e\ud835\udc56 and 2) esusp is a logarithmic function such that given an edge (\ud835\udc62\ud835\udc56 , \ud835\udc62 \ud835\udc57 ), esusp(\ud835\udc62\ud835\udc56 , \ud835\udc62 \ud835\udc57 ) = 1 log(\ud835\udc65+\ud835\udc50) , where \ud835\udc65 is the degree of the object vertex between \ud835\udc62\ud835\udc56 and \ud835\udc62 \ud835\udc57 , and \ud835\udc50 is a positive constant [24]. Developers can easily implement customized peeling algorithms with Dupin, significantly reducing the engineering effort. Density Metrics Support in Dupin. To illustrate the versatility of Dupin in handling various density metrics, we establish comprehensive sufficient conditions. These conditions ensure Dupin\u2019s adaptability in integrating a wide range of metrics to assess graph density effectively. This foundational approach enablesDupin to sup- port diverse density calculations, crucial for nuanced fraud detection and network analysis tasks. Property 3.1. Dupin supports a density metric \ud835\udc54(\ud835\udc46) if the following conditions are met: (1) \ud835\udc54(\ud835\udc46) = \ud835\udc53 (\ud835\udc46) |\ud835\udc46 | , where \ud835\udc53 is a monotone increasing function. (2) \ud835\udc4e\ud835\udc56 \u2265 0, ensuring non-negative vertex weight function. (3) \ud835\udc50\ud835\udc56 \ud835\udc57 \u2265 0, ensuring non-negative edge weight function.",
        "parallelable peeling algorithms": "For sequential peeling algorithms, only one vertex can be removed at a time, with each vertex\u2019s removal depending on the removal of previous vertices. This dependency prevents the algorithm from executing multiple vertex removals simultaneously. In this section, we introduce a parallel peeling paradigm to break this dependency chain. This new approach allowsmultiple vertices to be peeled in parallel without affecting the programming abstractions that Dupin provides to end users. We then demonstrate how this paradigm offers fine-grained trade-offs between parallelism and ap- proximation guarantees for all density metrics studied in this work. 4.1 Parallel Peeling Paradigm Instead of peeling the vertex with the maximum peeling weight, we can peel all vertices that lead to a significant decrease in the density scores of the remaining graph. This decrease is controlled by a tunable parameter \ud835\udf16 . A larger \ud835\udf16 allows more vertices to be peeled in parallel, while a smaller \ud835\udf16 provides a better approximation ratio. Algorithm 2: Dupin: Parallel Peeling Input:\ud835\udc3a = (\ud835\udc49 , \ud835\udc38), a density metric \ud835\udc54(\ud835\udc46), and \ud835\udf16 \u2265 0 Output: A subset of vertices \ud835\udc46 that maximizes the density metric \ud835\udc54(\ud835\udc46) 1 \ud835\udc460 \u2190 \ud835\udc49 /* Initialize the subset with all vertices */ 2 \ud835\udc56 \u2190 1 /* Initialize the index */ 3 while \ud835\udc46\ud835\udc56\u22121 \u0338= \u2205 do 4 \ud835\udf0f = \ud835\udc58(1 + \ud835\udf16) \u00b7 \ud835\udc54(\ud835\udc46\ud835\udc56\u22121) /* The threshold for peeling */ 5 \ud835\udc48 \u2190 {\ud835\udc62 | \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 \ud835\udf0f } /* Vertices to be peeled */ 6 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56\u22121 \\\ud835\udc48 /* Update the subset */ 7 \ud835\udc56 \u2190 \ud835\udc56 + 1 /* Increment the index */ 8 return arg max\ud835\udc46\ud835\udc56 \ud835\udc54(\ud835\udc46\ud835\udc56 ) /* The subset that maximizes \ud835\udc54(\ud835\udc46) */ Parallel Peeling (Algorithm 2). Let \ud835\udc46\ud835\udc56 denote the vertex set after the \ud835\udc56-th peeling iteration. Initially, \ud835\udc460 = \ud835\udc49 (Line 1). In each iteration, it removes a subset of vertices\ud835\udc48 from \ud835\udc46\ud835\udc56\u22121, where \u2200\ud835\udc62 \u2208 \ud835\udc48 ,\ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 \ud835\udc58(1 + \ud835\udf16)\ud835\udc54(\ud835\udc46\ud835\udc56\u22121). Parameter \ud835\udc58 is determined by the metric used. \ud835\udc58 = 2 works for DG, DW and FD. \ud835\udc58 = 3 works for TDS and \ud835\udc58 is the size of the cliques for \ud835\udc58CLiDS. This process is repeated recursively until no vertices are left, resulting in a series of vertex sets \ud835\udc460, . . . , \ud835\udc46\ud835\udc45 , where \ud835\udc45 is the number of iterations. The algorithm then returns the set \ud835\udc46\ud835\udc56 (\ud835\udc56 \u2208 [0, \ud835\udc45]) that maximizes the density metric \ud835\udc54(\ud835\udc46\ud835\udc56 ), denoted as \ud835\udc46\ud835\udc5d . In what follows, we also show a case where \ud835\udc58CLiDS is the density metric for DSD. 3 3 6 6 5 4 21 0 00 3 3 6 6 3 3 0 0 Density: 0.91 Density: 1.33 Density: 0 Iteration i Iteration i+1 Iteration i+2 Iteration i+3 Density: 0 \u03c4 = 3\u00d7 0.91 = 2.73 \u03c4 = 3\u00d7 1.33 = 3.99 \u03c4 = 0 \u03c4 = 0 4.2 Theoretical Analysis In this section, we analyze the theoretical properties of the parallel peeling process. We begin by examining the number of iterations required for parallel peeling. Built upon the result, we then determine the time complexity and the approximation ratio of the parallel peeling process. Lemma 4.1. Given any \ud835\udf16 > 0, \ud835\udc45 < log 1+\ud835\udf16 |\ud835\udc49 |. Proof. We prove that for any \ud835\udf16 \u2265 0, the size of the remaining vertex set is bounded by |\ud835\udc46\ud835\udc56 |< 1 1+\ud835\udf16 |\ud835\udc46\ud835\udc56\u22121 | for all \ud835\udc56 \u2208 [1, \ud835\udc45]. We first examine the peeling weights of the vertices in \ud835\udc46\ud835\udc56\u22121 for the density metrics DG. DW and FD where \ud835\udc58 = 2. As each edge weight in the peeling weight calculation contributes twice (once for each endpoint), and the vertex weights contribute once, we have\u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56\u22121 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 2\ud835\udc53 (\ud835\udc46\ud835\udc56\u22121), (3) The peeling weights of the vertices in \ud835\udc46\ud835\udc56\u22121 are calculated as follows:\u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56\u22121 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) = \u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56\u22121\\\ud835\udc46\ud835\udc56 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) + \u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2265 \u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) > 2(1 + \ud835\udf16)|\ud835\udc46\ud835\udc56 |\ud835\udc54(\ud835\udc46\ud835\udc56\u22121) (4) Combining Equation 3 and Equation 4, we have: 2(1 + \ud835\udf16)|\ud835\udc46\ud835\udc56 |\ud835\udc54(\ud835\udc46\ud835\udc56\u22121) < 2\ud835\udc53 (\ud835\udc46\ud835\udc56\u22121) = 2|\ud835\udc46\ud835\udc56\u22121 |\ud835\udc54(\ud835\udc46\ud835\udc56\u22121) (5) For all \ud835\udc56 \u2208 [1, \ud835\udc45], |\ud835\udc46\ud835\udc56 |< 1 1 + \ud835\udf16 |\ud835\udc46\ud835\udc56\u22121 | (6) Then we have: |\ud835\udc49 |= |\ud835\udc460 |> 1 1 + \ud835\udf16 |\ud835\udc461 |> . . . > ( 1 1 + \ud835\udf16 ) \ud835\udc45 |\ud835\udc46\ud835\udc45 | (7) Therefore, we have \ud835\udc45 < log 1+\ud835\udf16 |\ud835\udc49 |. For the density metrics TDS and \ud835\udc58CLiDS, we use the fact that each edge contributes to the peeling weight calculation exactly \ud835\udc58 times due to the counting of each edge within every \ud835\udc58-Clique in the graph (\ud835\udc58 = 3 for TDS). This multiplicity of edge contributions leads to the relationship: \u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56\u22121 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 \ud835\udc58 \ud835\udc53 (\ud835\udc46\ud835\udc56\u22121), (8) We then adapt Equations 4-7 and the proof follows. \u25a1 Time Complexity. Algorithm 2 operates for at most \ud835\udc45 = log 1+\ud835\udf16 |\ud835\udc49 | iterations, with each iteration scanning all vertices, taking \ud835\udc42(|\ud835\udc49 |) time. As vertices are peeled, updates are necessitated for the peeling weights of their neighboring vertices. Over the course of \ud835\udc45 iterations, there are no more than |\ud835\udc38 | such updates for DG, DW and FD. Consequently, Algorithm 3 incurs \ud835\udc42((|\ud835\udc38 |+|\ud835\udc49 |) log 1+\ud835\udf16 |\ud835\udc49 |) node/edge weight updates. For DG, DW and FD, the update costs are \ud835\udc42(1). For TDS and \ud835\udc58CLiDS, we follow previous studies [11, 14] to compute the peeling weights, and the complexity is \ud835\udc42(\ud835\udc58 |\ud835\udc38 |\ud835\udefc(\ud835\udc3a) \ud835\udc58\u22122 ), where \ud835\udefc(\ud835\udc3a) is the arboricity of the graph. Hence, the overall complexity is \ud835\udc42(\ud835\udc58 |\ud835\udc38 |\ud835\udefc(\ud835\udc3a) \ud835\udc58\u22122 (|\ud835\udc38 |+|\ud835\udc49 |) log 1+\ud835\udf16 |\ud835\udc49 |). The cost of peeling weight up- dates is orthogonal to the Dupin framework. Approximation Ratio. Next, we are ready to show that Dupin provides a theoretical guarantee with a \ud835\udc58(1 + \ud835\udf16)-approximation for all density metrics studied in this work. We denote \ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\ud835\udc5d as the first vertex in \ud835\udc46\u2217 peeled by Dupin, and \ud835\udc46 \u2032 as the peeling subsequence starting from \ud835\udc62\ud835\udc56 . Theorem 4.2. For the vertex set \ud835\udc46\ud835\udc5d returned by Dupin and the optimal vertex set \ud835\udc46\u2217, the relationship \ud835\udc54(\ud835\udc46\ud835\udc5d ) \u2265 \ud835\udc54(\ud835\udc46\u2217) \ud835\udc58(1+\ud835\udf16) holds. Proof. We first prove that \u2200\ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\u2217, \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2265 \ud835\udc54(\ud835\udc46\u2217). We prove it in contradiction. We assume that \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) < \ud835\udc54(\ud835\udc46\u2217). By peeling \ud835\udc62\ud835\udc56 from \ud835\udc46\u2217, we have the following. \ud835\udc54(\ud835\udc46\u2217 \\ {\ud835\udc62\ud835\udc56 }) = \ud835\udc53 (\ud835\udc46\u2217) \u2212\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) |\ud835\udc46\u2217 |\u22121 > \ud835\udc53 (\ud835\udc46\u2217) \u2212 \ud835\udc54(\ud835\udc46\ud835\udc56 ) |\ud835\udc46\u2217 |\u22121 = \ud835\udc53 (\ud835\udc46\u2217) \u2212 \ud835\udc54(\ud835\udc46\u2217) |\ud835\udc46\u2217 |\u22121 = \ud835\udc53 (\ud835\udc46\u2217) \u2212 \ud835\udc53 (\ud835\udc46\u2217) |\ud835\udc46\u2217 | |\ud835\udc46\u2217 |\u22121 = \ud835\udc54(\ud835\udc46\u2217) (9) Therefore, a better solution can be obtained by removing \ud835\udc62\ud835\udc56 from \ud835\udc46\u2217, which contradicts the fact that \ud835\udc46\u2217 is the optimal solution. We can conclude that\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2265 \ud835\udc54(\ud835\udc46\u2217). Next, we assume that \ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\ud835\udc5d is the first vertex in \ud835\udc46\u2217 peeled by the peeling algorithm. Since \ud835\udc46\u2217 is the optimal vertex set, we have \ud835\udc54(\ud835\udc46\u2217) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ), (10) because the optimal value \ud835\udc54(\ud835\udc46\u2217) must be less than or equal to the weight contribution of any single vertex in \ud835\udc46\u2217, in particular \ud835\udc62\ud835\udc56 . Since \ud835\udc46\u2217 \u2286 \ud835\udc46 \u2032, it is clear that \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) (11) By the peeling condition, we have \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) \u2264 \ud835\udc58(1 + \ud835\udf16)\ud835\udc54(\ud835\udc46 \u2032) (12) Therefore, we have \ud835\udc54(\ud835\udc46\u2217) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) \u2264 \ud835\udc58(1 + \ud835\udf16)\ud835\udc54(\ud835\udc46 \u2032) \u2264 \ud835\udc58(1 + \ud835\udf16)\ud835\udc54(\ud835\udc46\ud835\udc5d ) (13) Hence, we can conclude that \ud835\udc54(\ud835\udc46\ud835\udc5d ) \u2265 \ud835\udc54(\ud835\udc46\u2217) \ud835\udc58(1+\ud835\udf16) . \u25a1 Summary. Dupin can easily balance efficiency and the worst-case approximation ratio with a single parameter, \ud835\udf16 . A larger \ud835\udf16 allows more vertices to be peeled in parallel, reducing the number of peeling iterations. Meanwhile, the worst-case approximation ratio of parallel peeling is only affected by a factor of (1 + \ud835\udf16) compared to the ratio for sequential peeling w.r.t. all density metrics studied in this work.",
        "long-tail pruning": "We observe that the parallel peeling algorithm encounters two sig- nificant issues. First, there is a long-tail problem where subsequent iterations fail to produce denser subgraphs. Instead, each iteration only peels off a small fraction of vertices, which significantly impacts the overall runtime efficiency. Second, during batch peeling, each peeling iteration often results in disparate structures. These are pri- marily caused by the peeling of certain vertices, which leaves their neighboring structure disconnected and fragmented. This phenome- non affects the continuity and coherence of the subgraphs. As shown in Table 2, on the la dataset (the largest social network dataset tested in our experiments), DG, DW, and FD experience 24.67%, 46.84%, and 3.01% of rounds as ineffective long-tail iterations, severely limiting response time. Additionally, during the peeling process, if the batch size is large (e.g., \ud835\udf16 = 0.5), approximately 25.34%, 29.46%, and 7.16% of nodes become disconnected and sparse, signifi- cantly impacting the quality of the detected subgraphs. To address the challenges of high iteration counts in peeling algorithms, Dupin introduces two long-tail pruning techniques: Global Peeling Optimization (GPO) to maintain a global peeling threshold, and Local Peeling Optimization (LPO) to improve the density of the current peeling iteration\u2019s subgraph, thereby increasing the peeling threshold. We tested three algorithms, DG, DW, and FD, and found that they required 17,637, 150,223, and 112,074 iterations respectively, which is significantly high. By strategically pruning long-tail ver- tices and sparse vertices, the number of iterations can be reduced by up to 46.84%. Additionally, LPO can further reduce the number of iterations by up to 92.79%. These optimizations significantly enhance the efficiency of the peeling process, as discussed in this section. 5.1 Global Peeling Optimization Initially, we define what constitutes a long-tail vertex during the peeling process. Peeling these long-tail vertices results in ineffective peeling iterations. To address this, we maintain a global maximum peeling threshold to determine which vertices can be peeled directly. When the global peeling threshold is greater than the current itera- tion\u2019s threshold, we use the global peeling threshold for peeling. Algorithm 3: DupinGPO: Global Peeling Optimization Input:\ud835\udc3a = (\ud835\udc49 , \ud835\udc38), a density metric \ud835\udc54(\ud835\udc46), and \ud835\udf16 \u2265 0 Output: A subset of vertices \ud835\udc46\ud835\udc5d that maximizes the density metric \ud835\udc54(\ud835\udc46) 1 \ud835\udc460 \u2190 \ud835\udc49 /* Initialize the subset with all vertices */ 2 \ud835\udc56 \u2190 1 3 \ud835\udf0fmax \u2190 \ud835\udc54(\ud835\udc46 0 ) \ud835\udc58(1+\ud835\udf16) /* Initialize the threshold */ 4 while \ud835\udc46\ud835\udc56\u22121 \u0338= \u2205 do 5 \ud835\udf0f \u2190 max{\ud835\udf0fmax, \ud835\udc58(1 + \ud835\udf16) \u00b7 \ud835\udc54(\ud835\udc46\ud835\udc56\u22121)} /* Peeling threshold */ 6 \ud835\udc48 \u2190 {\ud835\udc62 | \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 \ud835\udf0f } /* Vertices to be peeled */ 7 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56\u22121 \\\ud835\udc48 /* Update the subset */ 8 \ud835\udf0fmax = max{\ud835\udf0fmax, \ud835\udc54(\ud835\udc46\ud835\udc56 ) \ud835\udc58(1+\ud835\udf16) } /* Refine the threshold */ 9 \ud835\udc56 \u2190 \ud835\udc56 + 1 10 return arg max\ud835\udc46\ud835\udc56 \ud835\udc54(\ud835\udc46\ud835\udc56 ) /* The subset that maximizes \ud835\udc54(\ud835\udc46) */ Definition 5.1 (Long-Tail vertex). Given an \ud835\udefc-\ud835\udc4e\ud835\udc5d\ud835\udc5d\ud835\udc5f\ud835\udc5c\ud835\udc65\ud835\udc56\ud835\udc5a\ud835\udc4e\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b DSD algorithm and a set of vertices \ud835\udc46 \u2286 \ud835\udc49 , if\ud835\udc64\ud835\udc62 (\ud835\udc46) < \ud835\udc54(\ud835\udc46\u2217) \ud835\udefc and \ud835\udc46\u2217 is the optimal vertex set, then \ud835\udc62 is a long-tail vertex. Lemma 5.1. If \u2203\ud835\udc62 \u2208 \ud835\udc46\ud835\udc56 is a long-tail vertex, then \ud835\udc46\ud835\udc56 \u0338= \ud835\udc46\ud835\udc43 . Proof. We prove it in contradiction by assuming that \ud835\udc46\ud835\udc56 = \ud835\udc46\ud835\udc43 . Since \ud835\udc62 is a long-tail vertex in \ud835\udc46\ud835\udc56 ,\ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56 ) < \ud835\udc54(\ud835\udc46\u2217) \ud835\udefc < \ud835\udc54(\ud835\udc46\ud835\udc43 ). By peeling \ud835\udc62 from \ud835\udc46\ud835\udc43 , we have the following. \ud835\udc54(\ud835\udc46\ud835\udc43 \\ {\ud835\udc62}) = \ud835\udc53 (\ud835\udc46\ud835\udc43 ) \u2212\ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc43 ) |\ud835\udc46\ud835\udc43 |\u22121 > \ud835\udc53 (\ud835\udc46\ud835\udc43 ) \u2212 \ud835\udc54(\ud835\udc46\ud835\udc43 ) |\ud835\udc46\ud835\udc43 |\u22121 = \ud835\udc53 (\ud835\udc46\ud835\udc43 ) \u2212 \ud835\udc53 (\ud835\udc46\ud835\udc43 ) |\ud835\udc46\ud835\udc43 | |\ud835\udc46\ud835\udc43 |\u22121 = \ud835\udc54(\ud835\udc46\ud835\udc43 ) (14) A denser subgraph can be obtained by peeling \ud835\udc62 from \ud835\udc46\ud835\udc43 . This contradicts that \ud835\udc46\ud835\udc43 is the optimal solution. Hence, \ud835\udc46\ud835\udc56 \u0338= \ud835\udc46\ud835\udc43 . \u25a1 Identifying Long-Tail Vertices. Based on Lemma 5.2, we can also establish that a vertex\ud835\udc62 in set \ud835\udc46 can be classified as a long-tail vertex if \ud835\udc64\ud835\udc62 (\ud835\udc46) < \ud835\udc54(\ud835\udc46\u2217) \ud835\udc58(1+\ud835\udf16) . This insight allows us to implement a global peeling threshold, denoted as \ud835\udf0fmax. During each iteration, we compare \ud835\udc54(\ud835\udc46\ud835\udc56 ) \ud835\udc58(1+\ud835\udf16) with \ud835\udf0fmax. If the former exceeds the latter, Dupin updates \ud835\udf0fmax to \ud835\udc54(\ud835\udc46\ud835\udc56 ) \ud835\udc58(1+\ud835\udf16) , thereby enhancing the efficiency of the peeling. Peeling with Global Threshold (Algorithm 3). Using FD as an example, we can set \ud835\udc58 to 2. In Lemma 5.2, we recognize that long-tail vertices in set \ud835\udc46\ud835\udc56 can be peeled directly during iteration \ud835\udc56 for FD. To facilitate this, Dupin initiates with a global peeling threshold \ud835\udf0fmax (Line 3). After identifying a denser subgraph post-peeling, \ud835\udf0fmax is updated to \ud835\udc54(\ud835\udc46\ud835\udc56 ) 2(1+\ud835\udf16) , refining the peeling process (Line 8). Example 5.1. In the initial depiction provided in the leftmost panel of Figure 6 (the \ud835\udc56-th iteration), the density of the graph is 4.28. Traditionally, this scenario would necessitate two additional iterations to complete the peeling process, which could notably increase computational time. As illustrated, vertex \ud835\udc62 cannot be peeled in the (\ud835\udc56 + 1)-th iteration and would typically require an extra iteration, the (\ud835\udc56 + 2)-th, for its removal. However, Dupin can promptly peel vertices that fall below this threshold by employing our algorithm\u2019s global peeling threshold, which is calculated as half of the current density (\ud835\udf0fmax = 4.28/2 = 2.14). This approach enables the simultaneous peeling of three nodes in the (\ud835\udc56 + 1)-th iteration. Without this pruning strategy, an additional iteration would be essential to peel vertex \ud835\udc62, underscoring our method\u2019s enhanced efficiency in the peeling process. This optimization obviates the necessity for a prolonged iterative sequence. The example herein substantiates the efficacy of our tai- lored optimization for long-tail distribution, substantially enhancing the algorithm\u2019s time efficiency. 5.2 Local Peeling Optimization Algorithm 4: DupinLPO: Local Peeling Optimization Input: A graph\ud835\udc3a = (\ud835\udc49 , \ud835\udc38), a density metric \ud835\udc54(\ud835\udc46), and \ud835\udf16 \u2265 0 Output: A subset of vertices \ud835\udc46\ud835\udc5d representing the densest subgraph 1 \ud835\udc460 \u2190 \ud835\udc49 /* Initialize the subset with all vertices */ 2 \ud835\udf0fmax \u2190 \ud835\udc54(\ud835\udc46 0 ) \ud835\udc58(1+\ud835\udf16) /* Initialize the threshold */ 3 while \ud835\udc46\ud835\udc56\u22121 \u0338= \u2205 do 4 \ud835\udf0f1 \u2190 max{\ud835\udf0fmax, \ud835\udc58(1 + \ud835\udf16) \u00b7 \ud835\udc54(\ud835\udc46\ud835\udc56\u22121)} /* Peeling threshold */ 5 \ud835\udc481 \u2190 {\ud835\udc62 \u2208 \ud835\udc46 | \ud835\udc64\ud835\udc62 (\ud835\udc46) \u2264 \ud835\udf0f1 } 6 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56\u22121 \\\ud835\udc481 7 while \u2203\ud835\udc62 \u2208 \ud835\udc46\ud835\udc56 , \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56 ) < \ud835\udc54(\ud835\udc46\ud835\udc56 ) do 8 \ud835\udf0f2 \u2190 max{\ud835\udf0fmax, \ud835\udc54(\ud835\udc46\ud835\udc56 )} /* Update the threshold */ 9 \ud835\udc482 \u2190 {\ud835\udc62 | \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56 ) < \ud835\udf0f2 } 10 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56 \\\ud835\udc482 11 \ud835\udf0fmax = max{\ud835\udf0fmax, \ud835\udc54(\ud835\udc46\ud835\udc56 ) \ud835\udc58(1+\ud835\udf16) } /* Update the threshold */ 12 return arg max\ud835\udc46\ud835\udc56 \ud835\udc54(\ud835\udc46\ud835\udc56 ) /* The subset that maximizes \ud835\udc54(\ud835\udc46) */ It is important to note that each peeling iteration often results in disparate structures. This is primarily caused by the peeling of cer- tain vertices, which leaves their neighboring structures disconnected and fragmented. This not only affects the density of the detected sub- graph but also lowers the peeling threshold. Lemma 5.2 establishes a foundational property of vertices within a dense graph. Lemma 5.2. \u2200\ud835\udc62 \u2208 \ud835\udc46 , if\ud835\udc64\ud835\udc62 (\ud835\udc46) < \ud835\udc54(\ud835\udc46), \ud835\udc54(\ud835\udc46 \\ {\ud835\udc62}) > \ud835\udc54(\ud835\udc46). Proof. By peeling \ud835\udc62 from \ud835\udc46 , we have the following. \ud835\udc54(\ud835\udc46 \\ {\ud835\udc62}) = \ud835\udc53 (\ud835\udc46) \u2212\ud835\udc64\ud835\udc62 (\ud835\udc46) |\ud835\udc46 |\u22121 > \ud835\udc53 (\ud835\udc46) \u2212 \ud835\udc54(\ud835\udc46\ud835\udc56 ) |\ud835\udc46 |\u22121 = \ud835\udc53 (\ud835\udc46) \u2212 \ud835\udc54(\ud835\udc46) |\ud835\udc46\u2217 |\u22121 = \ud835\udc53 (\ud835\udc46) \u2212 \ud835\udc53 (\ud835\udc46) |\ud835\udc46 | |\ud835\udc46 |\u22121 = \ud835\udc54(\ud835\udc46) (15) Therefore, a denser graph can be obtained by peeling \ud835\udc62 from \ud835\udc46 . \u25a1 According to Lemma 5.2, we introduce local peeling optimization within the iteration. After each peeling iteration, if the peeling weight of a vertex is smaller than the current density, Dupin will trim it. We implement a local peeling optimization (Lines 7-10, Algorithm 4) before the next iteration. After a vertex \ud835\udc62 is peeled, Dupin invokes updateNgh to update the peeling weights of \ud835\udc62\u2019s neighboring nodes. If any of these neighbors have a peeling weight less than the current density, they are also peeled, thereby increasing the density of the current iteration. Consequently, when an iteration yields globally optimal results, a denser structure is obtained. The benefits of this approach extend beyond density improvements; performance is also enhanced. By trimming these vertices, we reduce the number of vertices to traverse in subsequent iterations, and a higher density enables more efficient iterations due to the possibility of using larger peeling thresholds. Lemma 5.3. If \ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\ud835\udc5d is the first vertex in \ud835\udc46\u2217 removed by Dupin, \ud835\udc62\ud835\udc56 will not be removed during the local peeling optimization process. Proof. Assume, for the sake of contradiction, that \ud835\udc62\ud835\udc56 is trimmed during the local peeling optimization process. Let \ud835\udc46 \u2032 be the set of vertices left before \ud835\udc62\ud835\udc56 is trimmed. By definition, we have: \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) < \ud835\udc54(\ud835\udc46\u2217). Since \ud835\udc62\ud835\udc56 is the first vertex in \ud835\udc46\u2217 to be removed, \ud835\udc46\u2217 \u2286 \ud835\udc46 \u2032, therefore: \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) < \ud835\udc54(\ud835\udc46\u2217). This contradicts Lemma 5.2, which states that \u2200\ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\u2217: \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2265 \ud835\udc54(\ud835\udc46\u2217). Otherwise, a better solution can be obtained by removing \ud835\udc62 from \ud835\udc46\u2217, which contradicts the fact that \ud835\udc46\u2217 is the optimal solution. Thus, \ud835\udc62\ud835\udc56 cannot be trimmed. Hence,\ud835\udc62\ud835\udc56 will not be removed during the local peeling optimization process. \u25a1 Due to Lemma 5.3, \ud835\udc62\ud835\udc56 will only be removed during the peeling process. Hence, the approximation ratios (Theorem 4.2) for different density metrics are preserved. 6 EXPERIMENTAL STUDY Our experiments are run on a machine that has an X5650 CPU, 512 GB RAM. The implementation is made memory-resident and implemented in C++. All codes are compiled by GCC-9.3.0 with -\ud835\udc423. Datasets. We report the datasets used in our experiment in Table 3. One industrial dataset is from Anon (gfg). Datasets links-anon(la) and Twitter-rv (rv)were obtained from Stanford NetworkDataset Collection [31]. Datasets kron-logn21(kron), soc-twitter(soc), Web-uk-2005(uk) and Web-sk-2005(sk) were obtained from Network Data Repository [38]. Dataset bio was from the BIOMINE [35]. Baseline Methods.We evaluate five commonly used density metrics pivotal in network structure analysis: DG [6], DW [23], FD [24], TDS [46], and \ud835\udc58CLiDS [14]. These metrics are implemented within our framework, Dupin, and their performance is compared against several existing frameworks: Spade [28], kCLIST [14], GBBS [16], PBBS [41], PKMC [32], FWA [15], and ALENEX [44]. Specifically, kCLIST and PBBS are parallel algorithms for \ud835\udc58CLiDS. Since GBBS does not natively support weighted graphs, we precompute the peeling weights offline and import them into GBBS to enable support for DW and FD; the reported runtime excludes this preprocessing time. Additionally, FWA, ALENEX, and PKMC support the DGmetric, and we have extended their algorithms to support DW and FD by modifying their codebases accordingly. For TDS and \ud835\udc58CLiDS, we adapted the API of Spade for implementation. To standardize the compari- son, we denote the incremental peeling process\u2014which iteratively removes graph elements based on density scores\u2014as Spade-X, where X corresponds to each metric. This follows the experimental condi- tions in [28], with the batch size set to 1K as per their default setting; we report the average runtime per batch for Spade. Our parallel peeling algorithms, incorporating global and local peeling optimizations, are denoted as DupinGPO-X and DupinLPO-X, respectively. Default Settings. In our experiments, the parameter \ud835\udf16 is set to 0.1 by default, and the number of threads \ud835\udc61 is configured to 128. These settings are used consistently unless otherwise specified. 6.1 Efficiency of Dupin Spade vs Dupin. Our initial comparison focuses on the performance disparity between the incremental and parallel peeling algorithms. Specifically, Dupin-DG (resp. Dupin-DW, Dupin-FD, Dupin-TDS, and Dupin-\ud835\udc58CLiDS) demonstrates a speedup factor of 6.97 (resp. 7.71, 7.71, 7.65, and 8.46) over Spade-DG (resp. Spade-DW, SpadeFD, Spade-TDS, and Spade-\ud835\udc58CLiDS) as shown in Table 4 and Table 5. Notably, Spade-TDS and Spade-\ud835\udc58CLiDS only complete computations within 7,200 seconds on gfg. The bottleneck for Spade arises in larger graphs where initial calculations of the triangle and \ud835\udc58-Clique counting are unable to finish. Dupin outpaces Spade primarily because Spade suffers from the frequent reordering of peeling sequences when there are many increments, which proves to be slower than recalculating. GBBS vs Dupin. Among the parallel methods for DG, DW, and FD, FWA, ALENEX, and PKMC are several to dozens of times slower than GBBS. Therefore, we selectGBBS as a representative for comparison withDupin. The runtimes of the other three methods are provided in Table 4. On average, Dupin-DG, Dupin-DW, and Dupin-FD demon- strated speedup factors of 6.33, 12.51, and 17.07 times, respectively, over GBBS-DG, GBBS-DW, and GBBS-FD. This performance ad- vantage is attributed to the fundamental difference in the peeling process between the two frameworks. In GBBS, the basic unit of peeling is a bucket, where all nodes within the same bucket have an identical peeling weight. This design limits parallelism in weighted graphs, such as those using DW and FD, where many buckets may contain only a single node. In contrast, Dupin peels batches of nodes at each step and maintains a global peeling threshold to enhance the efficiency of each peeling iteration and eliminate long-tail iter- ations. This approach achieves higher parallelism and consistently outperforms GBBS, particularly in weighted graph scenarios where the speedup is even more pronounced. kCLIST vs PBBS vs Dupin. Both kCLIST and PBBS support the density metrics TDS and \ud835\udc58CLiDS. In our comparisons, Dupin demonstrates notable performance advantages. Specifically, Dupin-TDS is faster than kCLIST-TDS and PBBS-TDS by 39.85 and 62.71 times, respectively. Furthermore, Dupin-\ud835\udc58CLiDS also outperforms kCLIST\ud835\udc58CLiDS by 4.16 times. A significant finding is that PBBS-\ud835\udc58CLiDS fails to complete computations within 7200 seconds on most datasets, highlighting the efficiency of Dupin in handling more complex met- rics under stringent time constraints. Impact of DupinGPO. Next, we evaluate the acceleration effect of DupinGPO, using Dupin as a baseline for comparison. Notably, DupinGPO-DG is found to be 1.14 times faster, DupinGPO-DW is 1.11 times faster,DupinGPO-TDS is 1.10 times faster, andDupinGPO\ud835\udc58CLiDS is 1.35 times faster than their respective Dupin implementations. The acceleration is particularly significant for \ud835\udc58CLiDS on larger datasets, such as soc, rv, kron, and sk. DupinGPO-\ud835\udc58CLiDS is 1.40, 1.54, 1.51, and 1.61 times faster than Dupin-\ud835\udc58CLiDS on soc, rv, kron, and sk, respectively. This is attributed to the greater number of iterations required due to the larger dataset sizes and the higher count of \ud835\udc58-Cliques, necessitating more peeling iterations. In such scenarios,DupinGPO effectively prunes the tail iterations early, thereby reducing the number of rounds needed. Impact of DupinLPO. We next compared the efficiency of Dupin andDupinLPO. On average, thoughDupinLPO-DGwas 10.09% slower than Dupin-DG, the speed is still comparable. For example, on the soc dataset, DupinLPO-DG was 5.94% faster than Dupin-DG. This is because DupinLPO requires some lock operations to update the peeling weights of neighboring vertices during local peeling optimization. However, the advantage is that DupinLPO can detect up to 26.26% denser subgraphs, as detailed in Section 6.2. On larger datasets, such as soc, rv, and la, the vertices being trimmed have relatively low correlations with each other, so the impact of locks is minimal. For example, on the soc (resp. rv), DupinLPO-DG was 5.94% (resp. 9.94%) faster than Dupin-DG. In contrast, on smaller datasets, such as bio and kron, the extra cost of locks is higher. Impact of the Number of Threads \ud835\udc61 . All methods are influenced by the concurrency level, i.e., the number of threads. Generally, the greater the number of threads, the faster the execution speed. In our experiments, using the la dataset as a benchmark, we varied the number of threads \ud835\udc61 from 2 to 128 to observe the impact on runtime performance. For GBBS-DG, runtime stabilizes and accelerates by 3.33 times as thread count increases from 2 to 8. For GBBS-DW, performance deteriorates when the thread count exceeds 32, but from 2 to 32 threads, it accelerates by 3.50 times. Similarly, GBBS-FD shows no significant change in runtime beyond 32 threads, with an acceleration of 3.09 times from 2 to 32 threads. GBBS-TDS and GBBS-\ud835\udc58CLiDS fail to complete computations on the la dataset. In contrast, all five methods tested onDupin exhibit good scalability. As the number of threads increases from 2 to 128,Dupin-DG accelerates by 9.91 times, Dupin-DW by 12.69 times, Dupin-FD by 13.03 times, and Dupin-TDS by 28.06 times. Although Dupin-\ud835\udc58CLiDS fails to produce results when the thread count is below 16, it accelerates by 1.32 times from 32 to 128 threads. These results demonstrate Dupin\u2019s strong scalability across varied threading levels. 6.2 Effectiveness of Dupin In addition to assessing performance speedup, we evaluate the den- sity of the subgraphs detected by different frameworks. For parallel methods, we consider GBBS, PBBS, and kCLIST, because they gen- erally detect subgraphs with higher density than those detected by other methods across most datasets. For incremental methods, we use Spade as a representative. Detailed density comparisons are presented in Table 6 and Table 7. GBBS vs Spade vs Dupin. Firstly, we compare the densities of the subgraphs identified by GBBS-DG (respectively GBBS-DW, and GBBS-FD) to those detected by Dupin in parallel execution. Our experimental results indicate that Dupin maintains comparable subgraph densities with GBBS, signifying that the increase in com- putational efficiency does not compromise the accuracy of the de- tected subgraphs. Specifically, the density of the subgraph detected byGBBS-DG (respectivelyGBBS-DW, andGBBS-FD) is 7.08% (resp. 6.48% and 7.43%) greater than that detected by Dupin-DG (respectively Dupin-DW, and Dupin-FD) on average. Spade shares similar densities with GBBS. Due to Spade\u2019s tendency to accumulate er- rors over time, its density can become inflated. We will explain its limitations in practical applications in more detail in the case study. kCLIST vs PBBS vs Dupin. a) For \ud835\udc58CLiDS, PBBS-\ud835\udc58CLiDS could not complete on most of our test datasets, so we did not compare their densities. kCLIST-\ud835\udc58CLiDS could not complete on the sk dataset. On the other datasets, Dupin-\ud835\udc58CLiDS\u2019s density was only 6.97% smaller than kCLIST-\ud835\udc58CLiDS. On some datasets, such as bio and kron,Dupin\ud835\udc58CLiDS even detected subgraphs with greater density. b) For TDS, PBBS-TDS could detect subgraphs on smaller graphs but failed on billion-scale graphs such as rv, sk, and la. Dupin-TDS\u2019s density was 2.03% greater than kCLIST-TDS. Therefore, we conclude that Dupin is comparable to existing parallel methods in terms of the density of the detected dense subgraphs. Ablation Study of Dupin. This experiment delves into the effectiveness of our optimizations, DupinGPO and DupinLPO. Our analysis primarily focuses on comparing the densities of dense subgraphs detected by both DupinGPO and DupinLPO in various settings. DupinGPO achieves the same density as Dupin across five den- sity metrics because it trims the long tail, enhancing efficiency. For DupinLPO-DG (resp. DupinLPO-DW, DupinLPO-FD, DupinLPOTDS, and DupinGPO-\ud835\udc58CLiDS), we observe that the detected sub- graphs exhibit densities 11.09% (resp. 7.32%, 8.00%, 1.01%, and 26.26%) greater than those detected by Dupin-DG, Dupin-DW, Dupin-FD, Dupin-TDS, andDupin-\ud835\udc58CLiDS, respectively, demonstrating notable outcomes. This is because DupinLPO trims the graph in each iteration, resulting in denser subgraphs compared to Dupin. Impact of the Approximation Ratio \ud835\udf16. The approximation ratio \ud835\udf16 serves to control accuracy. In our experiment, we vary \ud835\udf16 from 0.1 to 1 to investigate its influence on the accuracy of Dupin. We observe that as \ud835\udf16 increases from 0.1 to 1, the density of subgraphs detected by Dupin, DupinGPO, and DupinLPO generally decreases. ForDG, the densities ofDupin-DG,DupinGPO-DG, andDupinLPODG decrease by 22.71%, 22.71%, and 11.99%, respectively. The trends for DW and DG are similar, with the worst performance observed at \ud835\udf16 = 0.6 for both density metrics. The trends for FD, TDS, and \ud835\udc58CLiDS are also similar. DupinLPO detects denser subgraphs across most density metrics and is less affected by \ud835\udf16 , due to its iterative trimming. For example, for FD, DupinLPO\u2019s density decreases by only 6.23%, while DupinGPO and Dupin\u2019s densities decrease by 17.37%. 6.3 Case study We also compare the performance in real-world scenarios, focusing on three key aspects: accuracy, latency, and prevention ratio. Accuracy. As discussed in Section 1, although Spade can quickly respond to new transactions, it tends to accumulate errors over time. Our analysis utilizes transaction data from Anon, with the transaction network comprising |\ud835\udc38 |= 2 billion edges. Under the incremental computation framework of Spade, the assumption is made that the weights of existing edges remain constant, thereby neglecting the impact of newly inserted edges on these weights, leading to error accumulation. For instance, using FD density metric, we observe that errors accumulate up to 24.4% within a day and increase to 30.3% over a week, as illustrated in Figure 9. Although Dupin sacrifices some accuracy to achieve parallel computational efficiency, our experiments show that Dupin\u2019s errors remain relatively stable between 3% and 5%. Hence, the detection precision of Spade declines from 87.9% to 68.3%, while Dupin\u2019s precision remains above 86%. Latency and Prevention Ratio. If a transaction is identified as fraudulent, subsequent related transactions are blocked to mitigate potential losses. We define the ratio of successfully prevented sus- picious transactions to the total number of suspicious transactions as R. As shown in Figure 8, the prevention ratio R continues to decrease as latency increases on Anon\u2019s datasets. Using the default density metric, FD, in Anon, our results show thatDupin-FD can prevent 94.5% of fraudulent activities, GBBS-FD can prevent 3.0%, and Spade-FD can prevent 45.3%. The reason for the lower performance of GBBS-FD is its low parallelism in the peeling process, which results in long peeling times and thus an average latency of 6,014 seconds, delaying the prevention of many fraudulent activities. Although Spade-FD performs well in reordering techniques on smaller datasets, in industrial scenarios with billion-scale graphs, latency significantly worsens due to the extensive reordering range required in the peeling sequences as normal users transition to fraudsters, increasing the cost of incremental computations. Additional tests were conducted with other density metrics; for DG, Dupin-DG can prevent 78.8%, while other methods prevent varying amounts. Similarly, for DW, Dupin-DW can prevent 86.1%, while other methods demonstrate different prevention capabilities.",
        "conclusion and futureworks": "In this paper, we presented Dupin, a novel parallel fraud detection framework tailored for massive graphs. Our experiments demonstrated that Dupin\u2019s advanced peeling algorithms and long-tail pruning techniques, DupinGPO and DupinLPO, significantly enhance the detection efficiency of dense subgraphs without sacrificing accuracy. Comparative studies with GBBS, PBBS, kCLIST, Spade, and Dupin highlighted Dupin\u2019s superior performance in terms of com- putational efficiency and accuracy. Through case studies, we also validated that Dupin achieves lower latency and higher detection ac- curacy compared to existing fraud detection systems on billion-scale graphs. Overall, Dupinproves to be a powerful tool for large-scale fraud detection, providing a scalable and efficient solution for real-time applications. Future work will explore the integration of additional suspiciousness functions and further optimization to handle even larger datasets and more complex fraud scenarios.",
        "references": "[1] Distil networks: The 2019 bad bot report. https://www.bluecubesecurity.com/wp- content/uploads/bad-bot-report-2019LR.pdf. [2] B. Bahmani, R. Kumar, and S. Vassilvitskii. Densest subgraph in streaming and mapreduce. Proceedings of the VLDB Endowment, 5(5), 2012. [3] Y. Ban, X. Liu, T. Zhang, L. Huang, Y. Duan, X. Liu, and W. Xu. Badlink: Combining graph and information-theoretical features for online fraud group detection. arXiv preprint arXiv:1805.10053, 2018. [4] A. Beutel, W. Xu, V. Guruswami, C. Palow, and C. Faloutsos. Copycatch: stopping group attacks by spotting lockstep behavior in social networks. In Proceedings of the 22nd international conference on World Wide Web, pages 119\u2013130, 2013. [5] D. Boob, Y. Gao, R. Peng, S. Sawlani, C. Tsourakakis, D.Wang, and J.Wang. Flowless: Extracting densest subgraphs without flow computations. In Proceedings of The Web Conference 2020, pages 573\u2013583, 2020. [6] M. Charikar. Greedy approximation algorithms for finding dense components in a graph. In International Workshop on Approximation Algorithms for Combinatorial Optimization, pages 84\u201395. Springer, 2000. [7] M. Charikar. Greedy approximation algorithms for finding dense components in a graph. In Approximation Algorithms for Combinatorial Optimization, Third International Workshop, APPROX 2000, Saarbr\u00fccken, Germany, September 5-8, 2000, Proceedings, volume 1913 of Lecture Notes in Computer Science, pages 84\u201395. Springer, 2000. [8] C. Chekuri, K. Quanrud, and M. R. Torres. Densest subgraph: Supermodularity, iterative peeling, and flow. In Proceedings of the 2022 Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 1531\u20131555. SIAM, 2022. [9] J. Chen and Y. Saad. Dense subgraph extraction with application to community detection. IEEE Transactions on knowledge and data engineering, 24(7):1216\u20131230, 2010. [10] Y. Chen, J. Jiang, S. Sun, B. He, and M. Chen. Rush: Real-time burst subgraph detection in dynamic graphs. Proceedings of the VLDB Endowment, 17(11):3657\u2013 3665, 2024. [11] N. Chiba and T. Nishizeki. Arboricity and subgraph listing algorithms. SIAM Journal on computing, 14(1):210\u2013223, 1985. [12] L. Chu, Y. Zhang, Y. Yang, L. Wang, and J. Pei. Online density bursting subgraph detection from temporal graphs. Proceedings of the VLDB Endowment, 12(13):2353\u2013 2365, 2019. [13] L. Dagum and R. Menon. Openmp: an industry standard api for shared-memory programming. IEEE computational science and engineering, 5(1):46\u201355, 1998. [14] M. Danisch, O. Balalau, and M. Sozio. Listing k-cliques in sparse real-world graphs. In Proceedings of the 2018 World Wide Web Conference, pages 589\u2013598, 2018. [15] M. Danisch, T.-H. H. Chan, and M. Sozio. Large scale density-friendly graph decomposition via convex programming. In Proceedings of the 26th International Conference on World Wide Web, pages 233\u2013242, 2017. [16] L. Dhulipala, J. Shi, T. Tseng, G. E. Blelloch, and J. Shun. The graph based benchmark suite (gbbs). In Proceedings of the 3rd Joint International Workshop on Graph Data Management Experiences & Systems (GRADES) and Network Data Analytics (NDA), pages 1\u20138, 2020. [17] Y. Dourisboure, F. Geraci, and M. Pellegrini. Extraction and classification of dense communities in the web. In Proceedings of the 16th international conference on World Wide Web, pages 461\u2013470, 2007. [18] A. Epasto, S. Lattanzi, and M. Sozio. Efficient densest subgraph computation in evolving graphs. In Proceedings of the 24th international conference on world wide web, pages 300\u2013310, 2015. [19] D. Gibson, R. Kumar, and A. Tomkins. Discovering large dense subgraphs in massive graphs. In Proceedings of the 31st international conference on Very large data bases, pages 721\u2013732. Citeseer, 2005. [20] A. Gionis and C. E. Tsourakakis. Dense subgraph discovery: Kdd 2015 tutorial. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 2313\u20132314, 2015. [21] A. V. Goldberg. Finding a maximum density subgraph. 1984. [22] A. V. Goldberg and R. E. Tarjan. A new approach to the maximum-flow problem. Journal of the ACM (JACM), pages 921\u2013940, 1988. [23] N. V. Gudapati, E. Malaguti, and M. Monaci. In search of dense subgraphs: How good is greedy peeling? Networks, 77(4):572\u2013586, 2021. [24] B. Hooi, H. A. Song, A. Beutel, N. Shah, K. Shin, and C. Faloutsos. Fraudar: Bounding graph fraud in the face of camouflage. In Proceedings of the 22nd ACM SIGKDD international conference on knowledge discovery and data mining, pages 895\u2013904, 2016. [25] M. Jaggi. Revisiting frank-wolfe: Projection-free sparse convex optimization. In International conference on machine learning, pages 427\u2013435. PMLR, 2013. [26] J. Jiang, Y. Chen, B. He, M. Chen, and J. Chen. Spade+: A generic real-time fraud detection framework on dynamic graphs. IEEE Transactions on Knowledge and Data Engineering, 2024. [27] M. Jiang, P. Cui, A. Beutel, C. Faloutsos, and S. Yang. Inferring strange behavior from connectivity pattern in social networks. In Pacific-Asia conference on knowledge discovery and data mining, pages 126\u2013138. Springer, 2014. [28] J. Jiaxin, L. Yuan, H. Bingsheng, H. Bryan, C. Jia, and J. K. Z. Kang. A real-time fraud detection framework on evolving graphs. PVLDB, 2023. [29] S. Kumar, W. L. Hamilton, J. Leskovec, and D. Jurafsky. Community interaction and conflict on the web. In Proceedings of the 2018 world wide web conference, pages 933\u2013943, 2018. [30] V. E. Lee, N. Ruan, R. Jin, and C. Aggarwal. A survey of algorithms for dense subgraph discovery. In Managing and mining graph data, pages 303\u2013336. Springer, 2010. [31] J. Leskovec and A. Krevl. SNAP Datasets: Stanford large network dataset collection. http://snap.stanford.edu/data, June 2014. [32] W. Luo, Z. Tang, Y. Fang, C. Ma, and X. Zhou. Scalable algorithms for densest subgraph discovery. In 2023 IEEE 39th International Conference on Data Engineering (ICDE), pages 287\u2013300. IEEE, 2023. [33] C. Ma, Y. Fang, R. Cheng, L. V. Lakshmanan, and X. Han. A convex-programming approach for efficient directed densest subgraph discovery. In Proceedings of the 2022 International Conference on Management of Data, pages 845\u2013859, 2022. [34] M. Mitzenmacher, J. Pachocki, R. Peng, C. Tsourakakis, and S. C. Xu. Scalable large near-clique detection in large-scale networks via sampling. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 815\u2013824, 2015. [35] V. Podpe\u010dan, \u017d. Ram\u0161ak, K. Gruden, H. Toivonen, and N. Lavra\u010d. Interactive explo- ration of heterogeneous biological networks with biomine explorer. Bioinformatics, 06 2019. [36] H. Qin, R.-H. Li, Y. Yuan, G. Wang, L. Qin, and Z. Zhang. Mining bursting core in large temporal graphs. Proceedings of the VLDB Endowment, 2022. [37] Y. Ren, H. Zhu, J. Zhang, P. Dai, and L. Bo. Ensemfdet: An ensemble approach to fraud detection based on bipartite graph. In 2021 IEEE 37th International Conference on Data Engineering (ICDE), pages 2039\u20132044. IEEE, 2021. [38] R. A. Rossi and N. K. Ahmed. The network data repository with interactive graph analytics and visualization. In AAAI, 2015. [39] A. E. Sar\u0131y\u00fcce andA. Pinar. Peeling bipartite networks for dense subgraph discovery. In Proceedings of the Eleventh ACM International Conference on Web Search and Data Mining, pages 504\u2013512, 2018. [40] S. B. Seidman. Network structure and minimum degree. Social networks, 5(3):269\u2013 287, 1983. [41] J. Shi, L. Dhulipala, and J. Shun. Parallel clique counting and peeling algorithms. In SIAM Conference on Applied and Computational Discrete Algorithms (ACDA21), pages 135\u2013146. SIAM, 2021. [42] K. Shin, T. Eliassi-Rad, and C. Faloutsos. Corescope: Graph mining using k-core analysis\u2014patterns, anomalies and algorithms. In 2016 IEEE 16th international conference on data mining (ICDM), pages 469\u2013478. IEEE, 2016. [43] K. Shin, B. Hooi, J. Kim, and C. Faloutsos. Densealert: Incremental dense-subtensor detection in tensor streams. In Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 1057\u20131066, 2017. [44] P. Sukprasert, Q. C. Liu, L. Dhulipala, and J. Shun. Practical parallel algorithms for near-optimal densest subgraphs on massive graphs. In 2024 Proceedings of the Symposium on Algorithm Engineering and Experiments (ALENEX), pages 59\u201373. SIAM, 2024. [45] B. Sun, M. Danisch, T. H. Chan, and M. Sozio. Kclist++: A simple algorithm for finding k-clique densest subgraphs in large graphs. Proceedings of the VLDB Endowment (PVLDB), 2020. [46] C. Tsourakakis. The k-clique densest subgraph problem. In Proceedings of the 24th international conference on world wide web, pages 1122\u20131132, 2015. [47] C. Ye, Y. Li, B. He, Z. Li, and J. Sun. Gpu-accelerated graph label propagation for real-time fraud detection. In Proceedings of the 2021 International Conference on Management of Data, pages 2348\u20132356, 2021.",
        "title": "Dupin: A Parallel Densest Subgraph Discovery Framework on Massive Graphs"
    },
    "full_text": "Dupin: A Parallel Densest Subgraph Discovery Framework on Massive Graphs\n\nABSTRACT Detecting fraudulent activities in financial and e-commerce transac-\n\ntion networks is crucial, and one effective method for this is Densest Subgraph Discovery (DSD). However, deploying DSD methods in production systems faces substantial scalability challenges due to the predominantly sequential nature of existing methods, which impedes their ability to handle large-scale transaction networks and results in significant detection delays. In this paper, we introduce Dupin, a novel parallel processing framework designed for efficient DSD processing in billion-scale graphs. Dupin is powered by a processing engine that exploits the unique properties of the peeling process, with theoretical guarantees on detection quality and efficiency.Dupin provides user-friendly APIs for flexible customization of DSD objectives and ensures robust adaptability to diverse fraud detection scenarios. Empirical evaluations indicate that Dupin outperforms several existing DSD methods, with performance improvements observed in specific scenarios reaching up to two orders of magnitude. On billion-scale graphs, Dupin demonstrates the potential to enhance the prevention of fraudulent transactions by approximately 49.5 basis points and reduce density error from 30% to below 5%, as supported by our experimental results. ACM Reference Format: Anonymous Author(s). 2024. Dupin: A Parallel Densest Subgraph Discovery Framework on Massive Graphs. In Proceedings of ACM Conference (Conference\u201917). ACM, New York, NY, USA, 14 pages. https://doi.org/10.1145/ nnnnnnn.nnnnnnn \n\n1 INTRODUCTION\n\nGraph structures pervade numerous contemporary applications, ranging from transaction and communication networks to expan- sive social media platforms. The study of densest subgraph discovery (DSD), first explored by [21], has since proven instrumental in various domains: link spam identification [4, 19], community de- tection [9, 17], and notably, fraud detection [8, 24, 42]. Central to this domain is the peeling process [2, 5, 8, 24, 46], which operates by iteratively removing vertices based on density metrics, such as vertex degree or the cumulative weight of adjacent edges. Their widespread adoption can be attributed to their inherent efficiency, robustness, and proven worst-case performance guarantees for DSD. In practice, business requirements demand the detection of fraud- ulent communities on billion-scale graphs within seconds. Recent Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. Conference\u201917, July 2017, Washington, DC, USA \u00a9 2024 Association for Computing Machinery. ACM ISBN 978-x-xxxx-xxxx-x/YY/MM. . . $15.00 https://doi.org/10.1145/nnnnnnn.nnnnnnn studies, including those by [1] and [47], have highlighted the perva- sive issue of malicious bot activity in e-commerce, accounting for a substantial 21.4% of all traffic in 2018. These fraudulent activities often happen quickly, making them hard to detect. The inability to efficiently process and analyze such massive graphs not only ham- pers fraud detection efforts but also exposes businesses to substan- tial financial risks and reputational damage. Therefore, addressing these challenges is not merely an academic exercise; it is a press- ing necessity for enhancing the integrity of digital transactions and safeguarding consumer trust. Despite extensive research onDSD for static graphs [20\u201322, 30, 33, 34], dynamic graphs [2, 18, 26, 28, 43], and parallel approaches [14, 16, 41, 42], existing methods face significant challenges for practical de- ployment in real-world fraud detection systems. For instance, many existing algorithms primarily rely on static score functions for DSD, lacking the flexibility required for dynamic and evolving fraud detec- tion scenarios. Methods such as [4] and [27] are designed with fixed detection criteria, which can become less effective as fraudulent be- haviors adapt over time. Additionally, incremental algorithms remain inefficient at handling billion-scale graphs with high transaction volumes, leading to increased latency. Parallel DSD frameworks often lack efficient pruning techniques, resulting in excessive iterations that degrade performance on large-scale graphs. This paper addresses the following research question: How can we enhance the efficiency and scalability of DSD methods to effectively detect fraud in massive graphs? Challenges. We evaluated existing methods with our industry partner, Anon (anonymized for review). The following issues surfaced: Firstly, existing algorithms focus on static score functions for DSD and lack flexible customization. While this may be adequate for short-term detection, it becomes less effective over time. For example, as shown in Figure 1a, graph density can accumulate sig- nificant errors within a single day, highlighting the need for more adaptive and customizable detection methods. Secondly, existing incremental algorithms are still inefficient at handling billion-scale graphs with high transaction volumes, leading to increased latency. This limitation is evident in Figure 1b, which illustrates the system load distribution for a specific day\u2019s transactions, underscoring the inability of current methods to efficiently manage high transaction volumes without significant delays. Thirdly, existing parallel densest subgraph discovery frameworks lack efficient pruning techniques, re- sulting in a large number of iterations. This inefficiency is especially problematic on billion-scale graphs, where performance degrades substantially due to the excessive computational overhead caused by numerous iterations. Adapting to Evolving Research Needs. Recognizing the dynamic nature of fraud detection and the rapid evolution of fraudulent tactics, we have adapted our research focus to address these challenges. Our approach incorporates flexible customization options for DSD methods, allowing for adjustments based on the changing landscape of fraudulent activities. This adaptability is crucial for maintaining the effectiveness of fraud detection systems in an environment where new threats continuously emerge. Contributions. In this work, we propose a DSD framework for fraud detection. Our key contributions are as follows: \u2022 A DSD Parallelization Framework. We propose Dupin, a novel parallel processing framework for densest subgraph discovery (DSD) that breaks the sequential dependencies inherent in tra- ditional density metrics, significantly enhancing scalability and efficiency on both weighted and unweighted graphs. Unlike existing methods that focus on specific density metrics, Dupin allows developers to define custom fraud detection semantics through flexible suspiciousness functions for edges and vertices. It supports a wide range of DSD semantics, including DG [6], DW [23], FD [24], TDS [46], and \ud835\udc58CLiDS [14]. Importantly, Dupin not only leverages parallelism but also provides theoretical guarantees on approximation ratios for the supported density metrics. To the best of our knowledge, this is the first generic parallel processing framework that accommodates a broad class of density metrics in DSD, offering both flexibility and theoretical assurance. \u2022 Exploiting Long-Tail Properties.We identify and address the long-tail problem in the peeling process of DSD algorithms, where late iterations remove only a small fraction of vertices and con- tribute little to the quality of the densest subgraph, leading to inefficiency. To tackle this, we introduce two novel optimizations: Global Pruning Optimization, which proactively removes low-contribution vertices within each peeling iteration to reduce computational overhead, and Local Pruning Optimization, which eliminates disparate structures formed after vertex removal to enhance the density and quality of the detected subgraph. These optimizations significantly reduce the number of iterations re- quired, improving both performance and result quality. \u2022 Empirical Validation and Real-World Impact: We conduct comprehensive experiments on large-scale industry datasets to validate the effectiveness of Dupin. Our results show that Dupin achieves up to 100 times faster fraud detection compared to the state-of-the-art incremental method Spade [28] and parallel methods like PBBS [41]. Moreover,Dupin is capable of preventing up to 94.5% of potential fraud, demonstrating significant practical bene- fits and reinforcing system integrity in real-world applications. Organization. The remainder of this paper is structured as follows: Section 2 presents the background and the literature review. Section 3 introduces the architecture of Dupin. In Section 4, we propose the theoretical foundations for parallel peeling-based algorithms for DSD. Section 5 introduces long-tail pruning techniques to improve efficiency and effectiveness. The experimental evaluation of Dupin is presented in Section 6. Finally, Section 7 concludes the paper and outlines avenues for future research. \n\n2 BACKGROUND AND RELATEDWORK\n\n\n\n2.1 Preliminary\n\nThis subsection presents the preliminary. Some frequently used no- tations are summarized in Table 1. Graph \ud835\udc3a . In this work, we operate on a weighted graph denoted as \ud835\udc3a = (\ud835\udc49 , \ud835\udc38), where \ud835\udc49 represents the set of vertices and \ud835\udc38 (\u2286 \ud835\udc49 \u00d7\ud835\udc49 ) represents the set of edges. Each edge (\ud835\udc62\ud835\udc56 , \ud835\udc62 \ud835\udc57 ) \u2208 \ud835\udc38 is assigned a nonnegative weight, expressed as \ud835\udc50\ud835\udc56 \ud835\udc57 . Additionally, \ud835\udc41 (\ud835\udc62) denotes the set of neighboring vertices connected to vertex \ud835\udc62. Induced Subgraph. For a given subset \ud835\udc46 of vertices in \ud835\udc49 , we define the induced subgraph as \ud835\udc3a[\ud835\udc46] = (\ud835\udc46, \ud835\udc38[\ud835\udc46]), where \ud835\udc38[\ud835\udc46] = {(\ud835\udc62, \ud835\udc63) | (\ud835\udc62, \ud835\udc63) \u2208 \ud835\udc38 \u2227 \ud835\udc62, \ud835\udc63 \u2208 \ud835\udc46}. The size of the subset \ud835\udc46 is denoted by |\ud835\udc46 |. Density Metrics \ud835\udc54 and Weight Function \ud835\udc53 . We utilize the class of metrics\ud835\udc54 as defined in prior works [6, 24, 28], where for a given subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the density metric is computed as: \ud835\udc54(\ud835\udc46) = \ud835\udc53 (\ud835\udc46) |\ud835\udc46 | . Here, \ud835\udc53 (\ud835\udc46) represents the total weight of the induced subgraph \ud835\udc3a[\ud835\udc46], which is defined as the sum of the weights of vertices in \ud835\udc46 and the weights of edges in \ud835\udc38[\ud835\udc46]. More formally: \ud835\udc53 (\ud835\udc46) = \u2211\ufe01 \ud835\udc62\ud835\udc56 \u2208\ud835\udc46 \ud835\udc4e\ud835\udc56 + \u2211\ufe01 (\ud835\udc62\ud835\udc56 ,\ud835\udc62 \ud835\udc57 )\u2208\ud835\udc38[\ud835\udc46] \ud835\udc50\ud835\udc56 \ud835\udc57 (1) The weight of a vertex \ud835\udc62\ud835\udc56 , denoted as \ud835\udc4e\ud835\udc56 (\ud835\udc4e\ud835\udc56 \u2265 0), quantifies the suspiciousness of user \ud835\udc62\ud835\udc56 . The weight of an edge (\ud835\udc62\ud835\udc56 , \ud835\udc62 \ud835\udc57 ), represented by \ud835\udc50\ud835\udc56 \ud835\udc57 (\ud835\udc50\ud835\udc56 \ud835\udc57 > 0), reflects the suspiciousness of the transaction between users \ud835\udc62\ud835\udc56 and \ud835\udc62 \ud835\udc57 . Intuitively, the density metric \ud835\udc54(\ud835\udc46) encapsulates the overall suspiciousness density of the induced subgraph\ud835\udc3a[\ud835\udc46]. A larger value of \ud835\udc54(\ud835\udc46) indicates a higher density of suspiciousness within\ud835\udc3a[\ud835\udc46]. The vertex set that maximizes the density metric \ud835\udc54 is denoted by \ud835\udc46\u2217. We next introduce five representative density metrics extensively employed in many fraud detection applications. The density metrics are mainly differed by how the weight function is defined. Dense Subgraphs (DG) [6]. The DG metric is employed to quan- tify the connectivity of substructures within a graph. It has found extensive applications in various domains, such as detecting fake comments in online platforms [29] and identifying fraudulent activities in social networks [3]. Given a subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of DG is defined as \ud835\udc53 (\ud835\udc46) = |\ud835\udc38[\ud835\udc46]|, where |\ud835\udc38[\ud835\udc46]| denotes the number of edges in the induced subgraph \ud835\udc3a[\ud835\udc46]. Dense Subgraph on Weighted Graphs (DW) [23]. In transac- tion graphs, it is common to have weights assigned to the edges, representing quantities such as the transaction amount. The DW metric extends the concept of dense subgraphs to accommodate these weighted relationships. Given a subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of DW is defined as \ud835\udc53 (\ud835\udc46) = \u2211 (\ud835\udc62\ud835\udc56 ,\ud835\udc62 \ud835\udc57 )\u2208\ud835\udc38[\ud835\udc46] \ud835\udc50\ud835\udc56 \ud835\udc57 . Fraudar (FD) [24]. In order to mitigate the effects of fraudulent actors deliberately obfuscating their activities, Hooi et al. [24] introduced the FD algorithm. This approach innovatively incorporates weights for edges and assigns prior suspiciousness scores to vertices, potentially utilizing side information to enhance detection accuracy. Given a subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of FD is defined as Equation 1 where \ud835\udc4e\ud835\udc56 denotes the suspicious score of vertex \ud835\udc62\ud835\udc56 and \ud835\udc50\ud835\udc56 \ud835\udc57 = 1 log(\ud835\udc65+\ud835\udc50) . Here \ud835\udc65 is the degree of the object vertex between \ud835\udc62\ud835\udc56 and \ud835\udc62 \ud835\udc57 , and \ud835\udc50 is a positive constant [24]. Triangle Densest Subgraph (TDS) [46]. Triangles serve as a crucial structural motif in graphs, providing valuable insights into the connectivity and cohesiveness of subgraphs. The TDS metric, in par- ticular, leverages the prevalence of triangles to quantify the density of a subgraph. Given a subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of TDS is defined as \ud835\udc53 (\ud835\udc46) = \ud835\udc61 (\ud835\udc46) where \ud835\udc61 (\ud835\udc46) represents the total number of triangles within the induced subgraph \ud835\udc3a[\ud835\udc46]. \ud835\udc58-Clique Densest Subgraph (\ud835\udc58CLiDS) [14]. Extending the concept of triangle densest subgraphs, \ud835\udc58CLiDS focuses on identifying dense subgraphs based on the presence of \ud835\udc58-Cliques. A \ud835\udc58-Clique is a complete subgraph of \ud835\udc58 vertices, representing a tightly-knit group of vertices. For a given subset of vertices \ud835\udc46 \u2286 \ud835\udc49 , the weight function of \ud835\udc58CLiDS is defined as \ud835\udc53 (\ud835\udc46) = \ud835\udc58(\ud835\udc46), where \ud835\udc58(\ud835\udc46) denotes the number of \ud835\udc58-Cliques within the induced subgraph \ud835\udc3a[\ud835\udc46]. \n\n2.2 Sequential Peeling Algorithms\n\nPeeling algorithms have gained popularity for their efficiency, ro- bustness, and proven worst-case performance in various applica- tions [6, 24, 46]. Next, we provide a concise overview of the typical execution flow of these algorithms. Peeling Weight.We use\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46) to indicate the decrease in the value of the weight function \ud835\udc53 when the vertex\ud835\udc62\ud835\udc56 is removed from a vertex set \ud835\udc46 , i.e., the peeling weight. Formally, \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46) = \ud835\udc4e\ud835\udc56 + \u2211\ufe01 (\ud835\udc62 \ud835\udc57 \u2208\ud835\udc46) \u2227 ((\ud835\udc62\ud835\udc56 ,\ud835\udc62 \ud835\udc57 )\u2208\ud835\udc38) \ud835\udc50\ud835\udc56 \ud835\udc57 + \u2211\ufe01 (\ud835\udc62 \ud835\udc57 \u2208\ud835\udc46) \u2227 ((\ud835\udc62 \ud835\udc57 ,\ud835\udc62\ud835\udc56 )\u2208\ud835\udc38) \ud835\udc50 \ud835\udc57\ud835\udc56 (2) Algorithm 1: Sequential Peeling Algorithm Input: A graph\ud835\udc3a = (\ud835\udc49 , \ud835\udc38) and a density metric \ud835\udc54(\ud835\udc46) Output: A subset of vertices \ud835\udc46 that maximizes the density metric \ud835\udc54(\ud835\udc46) 1 \ud835\udc460 \u2190 \ud835\udc49 /* Initialize the subset with all vertices */ 2 for \ud835\udc56 \u2190 1 to |\ud835\udc49 | do 3 \ud835\udc62 \u2190 arg max\ud835\udc63\u2208\ud835\udc46\ud835\udc56\u22121 \ud835\udc54(\ud835\udc46\ud835\udc56\u22121 \\ {\ud835\udc63 }) /* The vertex to be peeled */ 4 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56\u22121 \\ {\ud835\udc62 } /* The selected vertex */ 5 return arg max\ud835\udc46\ud835\udc56 \ud835\udc54(\ud835\udc46\ud835\udc56 ) /* The subset that maximizes \ud835\udc54(\ud835\udc46) */ Sequential PeelingAlgorithm (Algorithm1).The peeling process starts with the full vertex set \ud835\udc460 = \ud835\udc49 (Line 1) and iteratively removes vertices to maximize the density metric \ud835\udc54. In each step \ud835\udc56 , a vertex\ud835\udc62\ud835\udc56 is removed from \ud835\udc46\ud835\udc56\u22121 to form \ud835\udc46\ud835\udc56 , such that \ud835\udc54(\ud835\udc46\ud835\udc56\u22121 \\ {\ud835\udc62\ud835\udc56 }) is maximized (Lines 3\u223c4). This process is repeated until \ud835\udc46\ud835\udc56 becomes empty, resulting in a sequence of nested sets \ud835\udc460, \ud835\udc461, . . . , \ud835\udc46 |\ud835\udc49 | . The algorithm ultimately returns the subset \ud835\udc46\ud835\udc56 \u2208 {\ud835\udc460, . . . , \ud835\udc46 |\ud835\udc49 |} that maximizes \ud835\udc54(\ud835\udc46\ud835\udc56 ). Example 2.1 (Seqential Peeling Algorithm Process). Consider the graph \ud835\udc3a as shown in Figure 2. The process begins with an initial graph density of 2.33. In the first iteration, vertex \ud835\udc621 is peeled due to its smallest peeling weight among all vertices. Subsequently, vertices are peeled in the following order: \ud835\udc622, \ud835\udc623, \ud835\udc624, \ud835\udc625, and \ud835\udc626 based on the updated criteria after each peeling operation. Notably, after peeling \ud835\udc622, the graph density increases, which is a characteristic observation in the peeling process. The sequence of peeling continues until the last vertex, \ud835\udc626, is peeled, resulting in a final graph density of 0. The peeling sequence, therefore, is \ud835\udc42 = [\ud835\udc621, \ud835\udc622, \ud835\udc623, \ud835\udc624, \ud835\udc625, \ud835\udc626], completely disassembling the graph. The induced subgraph\ud835\udc3a[\ud835\udc46] of \ud835\udc46 = [\ud835\udc623, \ud835\udc624, \ud835\udc625, \ud835\udc626] has the greatest density of 2.75, thus \ud835\udc3a[\ud835\udc46] is returned. Approximation. An algorithm \ud835\udc44 is defined as an \ud835\udefc-approximation for the Densest Subgraph Discovery (DSD), where \ud835\udefc \u2265 1, if for any given graph it returns a subset \ud835\udc46 satisfying the condition: \ud835\udc54(\ud835\udc46) \u2265 \ud835\udc54(\ud835\udc46\u2217) \ud835\udefc , where \ud835\udc46\u2217 is the optimal subset that maximizes the density metric \ud835\udc54. Theorem 2.1 ([24]). For the vertex set \ud835\udc46\ud835\udc5d returned by Algorithm 1 and the optimal vertex set \ud835\udc46\u2217, it holds that \ud835\udc54(\ud835\udc46\ud835\udc5d ) \u2265 \ud835\udc54(\ud835\udc46\u2217) 2 for DG, DW and FD as the density metrics. We extend the analysis to TDS and \ud835\udc58CLiDS. The proof of the following theorem is omitted due to space limitation. Theorem 2.2. For the vertex set \ud835\udc46\ud835\udc5d returned by Algorithm 1 and the optimal vertex set \ud835\udc46\u2217, it holds that \ud835\udc54(\ud835\udc46\ud835\udc5d ) \u2265 \ud835\udc54(\ud835\udc46\u2217) \ud835\udc58 for TDS and \ud835\udc58CLiDS as the density metrics where \ud835\udc58 = 3 for TDS. \n\n2.3 Related work\n\nDensest Subgraph Discovery (DSD). Densest subgraph discov- ery represents a core area of research in graph theory, extensively explored in literature [7, 8, 20, 30, 39, 40]. The foundational max-flow- based algorithm by Goldberg et al. [21] set a benchmark for exact densest subgraph detection, with subsequent studies introducing more scalable exact solutions [33, 34]. While speed enhancements have been achieved through various greedy approaches [6, 8, 24, 33], these methods are inherently sequential and difficult to parallelize. For example, they often peel one vertex at a time, which results in too many peeling iterations. This sequential nature limits their scalability and efficiency on massive graphs. In graph-based fraud de- tection, techniques like COPYCATCH [4] and GETTHESCOOP [27] leverage local search heuristics to identify dense subgraphs in bi- partite networks, frequently applied in fraud, spam, and community detection across social and review platforms [24, 37, 42]. Despite their widespread use, these methods suffer from efficiency issues in very large graphs, often involving numerous iterations and lack- ing effective pruning techniques, which exacerbates the long-tail problem. Moreover, they are limited to specific definitions of dense subgraphs. Contrarily, Dupin offers a versatile, parallel approach to densest subgraph detection. It facilitates the simultaneous peeling of multiple vertices, drastically reducing the computational overhead. Additionally, Dupin provides APIs that allow users to customize defi- nitions of dense subgraphs, ensuring that the resultant graph density adheres to theoretical bounds. DSD on Dynamic Graphs. To tackle real-time fraud detection, sev- eral variants have been designed for dynamic graphs [10, 18, 26, 28, 43]. [28] addresses real-time fraud community detection on evolving graphs (edge insertions) using an incremental peeling sequence re- ordering method, while [26] extends this approach to fully dynamic graphs (edge insertions and deletions). [43] proposes an incremental algorithm that maintains and updates a dense subtensor in a ten- sor stream. [12] and [36] utilize sliding windows to detect dense subgraphs and bursting cores within specific time windows. These methods have three limitations. First, response time is an issue. Al- though they respond quickly to benign communities, the results can change drastically for newly formed fraudulent communities, caus- ing significant delays in incremental calculations for fraud detection. Second, efficiency is problematic. While incremental processing is faster than recomputation for a single transaction on billion-scale graphs, frequent incremental evaluations can be slower than a full recomputation. Third, in terms of flexibility, most methods support only a single semantic. In contrast, Dupin introduces a unified parallel framework for peeling-based dense subgraph detection.Dupin can respond within seconds on billion-scale graphs and defines multiple density metrics that can be used on the Dupin platform. Parallel DSD. Several parallel methods for DSD have been pro- posed [2, 14, 16, 39, 41, 42]. Bahmani et al. [2] proposed a parallel algorithm for DG using the MapReduce framework. FWA [15] proposed a parallel algorithm for DW based on Frank-Wolfe algo- rithm [25] using OpenMP [13]. Some works propose parallel \ud835\udc58-core algorithms [32, 41, 44]. Others introduce parallel algorithms for \ud835\udc58- Clique detection, with approaches offering a (1 + \ud835\udf16)-approximation ratio and parallel implementations for the \ud835\udc58CLiDS problem [16, 45]. There are also algorithms for \ud835\udc58-Clique densest subgraph detection using OpenMP [14], and methods for dense subtensor detection [42]. However, these systems have two main limitations. First, they typi- cally support only a single-densitymetric and do not handle weighted graphs. In real-world applications, transactions between users can have varying degrees of importance based on amounts, frequen- cies [28], and other factors. Extending these systems to support other dense metrics with theoretical guarantees is non-trivial. Second, they often lack efficient pruning techniques, requiring numerous itera- tions and suffering from the long-tail issue, which hinders scalability on massive graphs. In contrast, Dupin defines the characteristics of a set of supported dense metrics and accommodates weighted sub- graphs, allowing for more nuanced analysis reflective of real-world data. Our method introduces efficient pruning strategies by peeling multiple vertices in parallel based on a threshold mechanism, signifi- cantly reducing the number of iterations and mitigating the long-tail problem. This makes Dupin more effective and scalable in diverse real-world scenarios compared to previous approaches. 3 THE Dupin FRAMEWORK \n\n3.1 Motivations\n\nA notable example of advanced fraud detection is seen in Anon, a prominent technology company in Southeast Asia known for its digital payment and food delivery services. As delineated in [28], the detection process begins with forming a transaction graph,\ud835\udc3a , derived from the platform\u2019s transactions. This graph is incrementally updated, represented as \ud835\udc3a = \ud835\udc3a \u2295 \u2206\ud835\udc3a . Subsequent stages utilize densest subgraph discovery algorithms to uncover fraudulent communities. A typical fraud scenario on the platform involves customer-merchant collusion, where fake accounts are created to exploit promotional incentives. These fraudulent activities manifest as densest subgraphs within the transaction graph. Efficiency. Our empirical findings reveal that the incremental execution of DSD algorithms, such as Spade [28], on a graph with 2 billion edges requires approximately 198 seconds per batch (default setting: one batch of 1K edge insertions). However, in practical business sce- narios, the number of incoming edges can peak at 400K per minute. Clearly, using incremental evaluation on billion-scale graphs does not provide sufficient throughput to meet business requirements. Latency and Prevention Ratio. Existing DSD systems face sig- nificant challenges in terms of latency and prevention ratio. Upon identification of fraudulent activities, actions such as account bans or freezes are implemented to prevent further losses. However, the aver- age latency for these systems to detect fraud and take action is often high, typically around 200 to 300 seconds for incremental algorithms and more than 1000 seconds for existing parallel algorithms, which is insufficient for real-time requirements (operational demand requires detection within seconds). Moreover, when the graph size increases from million-scale to billion-scale, the prevention ratio decreases from 92.47% to 45%. These issues underscore the necessity for more efficient and scalable algorithms that can maintain low latency and high prevention ratios, even under heavy transaction loads. Parallelization offers a viable solution to these challenges by dis- tributing the computational load across multiple processors. Mod- ern CPUs are equipped with numerous cores that are cost-effective, enabling parallel processing. If the peeling process of DSD is paral- lelized, different processors can simultaneously evaluate and peel different nodes, thereby increasing scalability and efficiency. For example, if we can improve processing speed by one to two orders of magnitude, the system would be able to meet industry requirements for real-time fraud detection, completing detection within seconds. Problem Statement. Given a graph \ud835\udc3a = (\ud835\udc49 , \ud835\udc38) and a community detection semantic with density metric \ud835\udc54(\ud835\udc46), our goal is to find a vertex subset \ud835\udc46\u2217 \u2286 \ud835\udc49 that maximizes \ud835\udc54(\ud835\udc46\u2217). \n\n3.2 System Architecture\n\nTo enable users to design complex DSD algorithms to detect fraudsters based on our framework, Dupin, we have introduced the archi- tecture, APIs, and supported density metrics in this section. Architecture of Dupin. Figure 3 presents the architecture of Dupin with user-defined functions for detecting suspicious activities.Dupin enables users to define their fraud detection semantics through a set of provided APIs. Within Dupin\u2019s computational engine, we sup- port both sequential and parallel peeling algorithms. Additionally, algorithms for long-tail pruning techniques are implemented to ac- celerate convergence and enhance the density of subgraphs in each iteration. Dupin identifies fraudulent communities, which are then flagged for further investigation by moderators. APIs of Dupin (Figure 3). Dupin simplifies the process of defining detection semantics by allowing users to specify a few simple functions. Additionally, Dupin offers APIs that enable users to balance detection speed and accuracy effectively. The key APIs encompass several components designed to facilitate the customization and op- timization of fraud detection processes. These components provide a robust framework for users to implement their fraud detection strate- gies, ensuring both high performance and precision in identifying fraudulent activities. Details are listed below: \u2022 pWeight and updateNgh. These functions are designed for the dynamic adjustment of weights within the network. They allow the user to define the peeling weight of a vertex and specify the method for updating the peeling weight of neighboring vertices after a vertex has been peeled. \u2022 VSusp and ESusp. Given a vertex/edge, these components are re- sponsible for deciding the suspiciousness of the endpoint of the edge or the edge with a user-defined strategy. \u2022 isBenign. This component is used to decide whether a vertex is benign during the whole peeling process (Section 5). If the vertex is benign, it is peeled within the current iteration. \u2022 setEpsilon. This function is utilized to control the precision of fraud detection. During periods of high system load, moderators can increase \ud835\udf16 to achieve higher throughput. Conversely, when the system load is low, \ud835\udf16 can be decreased to enhance accuracy. \u2022 setK. This function specifies the \ud835\udc58-Clique parameter, enabling the definition of the \ud835\udc58-Clique for analysis. 1 double vsusp(const Vertex& v, const Graph& g) { 2 return g.weight[v]; // Side information on vertex 3 } 4 double esusp(const Edge& e, const Graph& g) { 5 return 1.0 / log(g.deg[e.src] + 5.0); 6 } 7 int main() { 8 Dupin dupin; 9 dupin.VSusp(vsusp); // Plug in vsusp 10 dupin.ESusp(esusp); // Plug in esusp 11 dupin.setEpsilon (0.1); 12 dupin.LoadGraph(\"graph_sample_path\"); 13 vector <Vertex > fraudsters = dupin.ParDetect (); 14 return 0; 15 } Listing 1: Implementation of FD on Dupin Example (Listing 1). To implement FD [24] on Dupin, users simply need to plug in the suspiciousness function vsusp for the vertices by calling VSusp and the suspiciousness function esusp for the edges by calling ESusp. Specifically, 1) vsusp is a constant function, i.e., given a vertex \ud835\udc62, vsusp(\ud835\udc62) = \ud835\udc4e\ud835\udc56 and 2) esusp is a logarithmic function such that given an edge (\ud835\udc62\ud835\udc56 , \ud835\udc62 \ud835\udc57 ), esusp(\ud835\udc62\ud835\udc56 , \ud835\udc62 \ud835\udc57 ) = 1 log(\ud835\udc65+\ud835\udc50) , where \ud835\udc65 is the degree of the object vertex between \ud835\udc62\ud835\udc56 and \ud835\udc62 \ud835\udc57 , and \ud835\udc50 is a positive constant [24]. Developers can easily implement customized peeling algorithms with Dupin, significantly reducing the engineering effort. Density Metrics Support in Dupin. To illustrate the versatility of Dupin in handling various density metrics, we establish comprehensive sufficient conditions. These conditions ensure Dupin\u2019s adaptability in integrating a wide range of metrics to assess graph density effectively. This foundational approach enablesDupin to sup- port diverse density calculations, crucial for nuanced fraud detection and network analysis tasks. Property 3.1. Dupin supports a density metric \ud835\udc54(\ud835\udc46) if the following conditions are met: (1) \ud835\udc54(\ud835\udc46) = \ud835\udc53 (\ud835\udc46) |\ud835\udc46 | , where \ud835\udc53 is a monotone increasing function. (2) \ud835\udc4e\ud835\udc56 \u2265 0, ensuring non-negative vertex weight function. (3) \ud835\udc50\ud835\udc56 \ud835\udc57 \u2265 0, ensuring non-negative edge weight function. \n\n4 PARALLELABLE PEELING ALGORITHMS\n\nFor sequential peeling algorithms, only one vertex can be removed at a time, with each vertex\u2019s removal depending on the removal of previous vertices. This dependency prevents the algorithm from executing multiple vertex removals simultaneously. In this section, we introduce a parallel peeling paradigm to break this dependency chain. This new approach allowsmultiple vertices to be peeled in parallel without affecting the programming abstractions that Dupin provides to end users. We then demonstrate how this paradigm offers fine-grained trade-offs between parallelism and ap- proximation guarantees for all density metrics studied in this work. \n\n4.1 Parallel Peeling Paradigm\n\nInstead of peeling the vertex with the maximum peeling weight, we can peel all vertices that lead to a significant decrease in the density scores of the remaining graph. This decrease is controlled by a tunable parameter \ud835\udf16 . A larger \ud835\udf16 allows more vertices to be peeled in parallel, while a smaller \ud835\udf16 provides a better approximation ratio. Algorithm 2: Dupin: Parallel Peeling Input:\ud835\udc3a = (\ud835\udc49 , \ud835\udc38), a density metric \ud835\udc54(\ud835\udc46), and \ud835\udf16 \u2265 0 Output: A subset of vertices \ud835\udc46 that maximizes the density metric \ud835\udc54(\ud835\udc46) 1 \ud835\udc460 \u2190 \ud835\udc49 /* Initialize the subset with all vertices */ 2 \ud835\udc56 \u2190 1 /* Initialize the index */ 3 while \ud835\udc46\ud835\udc56\u22121 \u0338= \u2205 do 4 \ud835\udf0f = \ud835\udc58(1 + \ud835\udf16) \u00b7 \ud835\udc54(\ud835\udc46\ud835\udc56\u22121) /* The threshold for peeling */ 5 \ud835\udc48 \u2190 {\ud835\udc62 | \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 \ud835\udf0f } /* Vertices to be peeled */ 6 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56\u22121 \\\ud835\udc48 /* Update the subset */ 7 \ud835\udc56 \u2190 \ud835\udc56 + 1 /* Increment the index */ 8 return arg max\ud835\udc46\ud835\udc56 \ud835\udc54(\ud835\udc46\ud835\udc56 ) /* The subset that maximizes \ud835\udc54(\ud835\udc46) */ Parallel Peeling (Algorithm 2). Let \ud835\udc46\ud835\udc56 denote the vertex set after the \ud835\udc56-th peeling iteration. Initially, \ud835\udc460 = \ud835\udc49 (Line 1). In each iteration, it removes a subset of vertices\ud835\udc48 from \ud835\udc46\ud835\udc56\u22121, where \u2200\ud835\udc62 \u2208 \ud835\udc48 ,\ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 \ud835\udc58(1 + \ud835\udf16)\ud835\udc54(\ud835\udc46\ud835\udc56\u22121). Parameter \ud835\udc58 is determined by the metric used. \ud835\udc58 = 2 works for DG, DW and FD. \ud835\udc58 = 3 works for TDS and \ud835\udc58 is the size of the cliques for \ud835\udc58CLiDS. This process is repeated recursively until no vertices are left, resulting in a series of vertex sets \ud835\udc460, . . . , \ud835\udc46\ud835\udc45 , where \ud835\udc45 is the number of iterations. The algorithm then returns the set \ud835\udc46\ud835\udc56 (\ud835\udc56 \u2208 [0, \ud835\udc45]) that maximizes the density metric \ud835\udc54(\ud835\udc46\ud835\udc56 ), denoted as \ud835\udc46\ud835\udc5d . In what follows, we also show a case where \ud835\udc58CLiDS is the density metric for DSD. 3 3 6 6 5 4 21 0 00 3 3 6 6 3 3 0 0 Density: 0.91 Density: 1.33 Density: 0 Iteration i Iteration i+1 Iteration i+2 Iteration i+3 Density: 0 \u03c4 = 3\u00d7 0.91 = 2.73 \u03c4 = 3\u00d7 1.33 = 3.99 \u03c4 = 0 \u03c4 = 0 \n\n4.2 Theoretical Analysis\n\nIn this section, we analyze the theoretical properties of the parallel peeling process. We begin by examining the number of iterations required for parallel peeling. Built upon the result, we then determine the time complexity and the approximation ratio of the parallel peeling process. Lemma 4.1. Given any \ud835\udf16 > 0, \ud835\udc45 < log 1+\ud835\udf16 |\ud835\udc49 |. Proof. We prove that for any \ud835\udf16 \u2265 0, the size of the remaining vertex set is bounded by |\ud835\udc46\ud835\udc56 |< 1 1+\ud835\udf16 |\ud835\udc46\ud835\udc56\u22121 | for all \ud835\udc56 \u2208 [1, \ud835\udc45]. We first examine the peeling weights of the vertices in \ud835\udc46\ud835\udc56\u22121 for the density metrics DG. DW and FD where \ud835\udc58 = 2. As each edge weight in the peeling weight calculation contributes twice (once for each endpoint), and the vertex weights contribute once, we have\u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56\u22121 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 2\ud835\udc53 (\ud835\udc46\ud835\udc56\u22121), (3) The peeling weights of the vertices in \ud835\udc46\ud835\udc56\u22121 are calculated as follows:\u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56\u22121 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) = \u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56\u22121\\\ud835\udc46\ud835\udc56 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) + \u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2265 \u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) > 2(1 + \ud835\udf16)|\ud835\udc46\ud835\udc56 |\ud835\udc54(\ud835\udc46\ud835\udc56\u22121) (4) Combining Equation 3 and Equation 4, we have: 2(1 + \ud835\udf16)|\ud835\udc46\ud835\udc56 |\ud835\udc54(\ud835\udc46\ud835\udc56\u22121) < 2\ud835\udc53 (\ud835\udc46\ud835\udc56\u22121) = 2|\ud835\udc46\ud835\udc56\u22121 |\ud835\udc54(\ud835\udc46\ud835\udc56\u22121) (5) For all \ud835\udc56 \u2208 [1, \ud835\udc45], |\ud835\udc46\ud835\udc56 |< 1 1 + \ud835\udf16 |\ud835\udc46\ud835\udc56\u22121 | (6) Then we have: |\ud835\udc49 |= |\ud835\udc460 |> 1 1 + \ud835\udf16 |\ud835\udc461 |> . . . > ( 1 1 + \ud835\udf16 ) \ud835\udc45 |\ud835\udc46\ud835\udc45 | (7) Therefore, we have \ud835\udc45 < log 1+\ud835\udf16 |\ud835\udc49 |. For the density metrics TDS and \ud835\udc58CLiDS, we use the fact that each edge contributes to the peeling weight calculation exactly \ud835\udc58 times due to the counting of each edge within every \ud835\udc58-Clique in the graph (\ud835\udc58 = 3 for TDS). This multiplicity of edge contributions leads to the relationship: \u2211\ufe01 \ud835\udc62\u2208\ud835\udc46\ud835\udc56\u22121 \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 \ud835\udc58 \ud835\udc53 (\ud835\udc46\ud835\udc56\u22121), (8) We then adapt Equations 4-7 and the proof follows. \u25a1 Time Complexity. Algorithm 2 operates for at most \ud835\udc45 = log 1+\ud835\udf16 |\ud835\udc49 | iterations, with each iteration scanning all vertices, taking \ud835\udc42(|\ud835\udc49 |) time. As vertices are peeled, updates are necessitated for the peeling weights of their neighboring vertices. Over the course of \ud835\udc45 iterations, there are no more than |\ud835\udc38 | such updates for DG, DW and FD. Consequently, Algorithm 3 incurs \ud835\udc42((|\ud835\udc38 |+|\ud835\udc49 |) log 1+\ud835\udf16 |\ud835\udc49 |) node/edge weight updates. For DG, DW and FD, the update costs are \ud835\udc42(1). For TDS and \ud835\udc58CLiDS, we follow previous studies [11, 14] to compute the peeling weights, and the complexity is \ud835\udc42(\ud835\udc58 |\ud835\udc38 |\ud835\udefc(\ud835\udc3a) \ud835\udc58\u22122 ), where \ud835\udefc(\ud835\udc3a) is the arboricity of the graph. Hence, the overall complexity is \ud835\udc42(\ud835\udc58 |\ud835\udc38 |\ud835\udefc(\ud835\udc3a) \ud835\udc58\u22122 (|\ud835\udc38 |+|\ud835\udc49 |) log 1+\ud835\udf16 |\ud835\udc49 |). The cost of peeling weight up- dates is orthogonal to the Dupin framework. Approximation Ratio. Next, we are ready to show that Dupin provides a theoretical guarantee with a \ud835\udc58(1 + \ud835\udf16)-approximation for all density metrics studied in this work. We denote \ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\ud835\udc5d as the first vertex in \ud835\udc46\u2217 peeled by Dupin, and \ud835\udc46 \u2032 as the peeling subsequence starting from \ud835\udc62\ud835\udc56 . Theorem 4.2. For the vertex set \ud835\udc46\ud835\udc5d returned by Dupin and the optimal vertex set \ud835\udc46\u2217, the relationship \ud835\udc54(\ud835\udc46\ud835\udc5d ) \u2265 \ud835\udc54(\ud835\udc46\u2217) \ud835\udc58(1+\ud835\udf16) holds. Proof. We first prove that \u2200\ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\u2217, \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2265 \ud835\udc54(\ud835\udc46\u2217). We prove it in contradiction. We assume that \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) < \ud835\udc54(\ud835\udc46\u2217). By peeling \ud835\udc62\ud835\udc56 from \ud835\udc46\u2217, we have the following. \ud835\udc54(\ud835\udc46\u2217 \\ {\ud835\udc62\ud835\udc56 }) = \ud835\udc53 (\ud835\udc46\u2217) \u2212\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) |\ud835\udc46\u2217 |\u22121 > \ud835\udc53 (\ud835\udc46\u2217) \u2212 \ud835\udc54(\ud835\udc46\ud835\udc56 ) |\ud835\udc46\u2217 |\u22121 = \ud835\udc53 (\ud835\udc46\u2217) \u2212 \ud835\udc54(\ud835\udc46\u2217) |\ud835\udc46\u2217 |\u22121 = \ud835\udc53 (\ud835\udc46\u2217) \u2212 \ud835\udc53 (\ud835\udc46\u2217) |\ud835\udc46\u2217 | |\ud835\udc46\u2217 |\u22121 = \ud835\udc54(\ud835\udc46\u2217) (9) Therefore, a better solution can be obtained by removing \ud835\udc62\ud835\udc56 from \ud835\udc46\u2217, which contradicts the fact that \ud835\udc46\u2217 is the optimal solution. We can conclude that\ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2265 \ud835\udc54(\ud835\udc46\u2217). Next, we assume that \ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\ud835\udc5d is the first vertex in \ud835\udc46\u2217 peeled by the peeling algorithm. Since \ud835\udc46\u2217 is the optimal vertex set, we have \ud835\udc54(\ud835\udc46\u2217) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ), (10) because the optimal value \ud835\udc54(\ud835\udc46\u2217) must be less than or equal to the weight contribution of any single vertex in \ud835\udc46\u2217, in particular \ud835\udc62\ud835\udc56 . Since \ud835\udc46\u2217 \u2286 \ud835\udc46 \u2032, it is clear that \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) (11) By the peeling condition, we have \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) \u2264 \ud835\udc58(1 + \ud835\udf16)\ud835\udc54(\ud835\udc46 \u2032) (12) Therefore, we have \ud835\udc54(\ud835\udc46\u2217) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) \u2264 \ud835\udc58(1 + \ud835\udf16)\ud835\udc54(\ud835\udc46 \u2032) \u2264 \ud835\udc58(1 + \ud835\udf16)\ud835\udc54(\ud835\udc46\ud835\udc5d ) (13) Hence, we can conclude that \ud835\udc54(\ud835\udc46\ud835\udc5d ) \u2265 \ud835\udc54(\ud835\udc46\u2217) \ud835\udc58(1+\ud835\udf16) . \u25a1 Summary. Dupin can easily balance efficiency and the worst-case approximation ratio with a single parameter, \ud835\udf16 . A larger \ud835\udf16 allows more vertices to be peeled in parallel, reducing the number of peeling iterations. Meanwhile, the worst-case approximation ratio of parallel peeling is only affected by a factor of (1 + \ud835\udf16) compared to the ratio for sequential peeling w.r.t. all density metrics studied in this work. \n\n5 LONG-TAIL PRUNING\n\nWe observe that the parallel peeling algorithm encounters two sig- nificant issues. First, there is a long-tail problem where subsequent iterations fail to produce denser subgraphs. Instead, each iteration only peels off a small fraction of vertices, which significantly impacts the overall runtime efficiency. Second, during batch peeling, each peeling iteration often results in disparate structures. These are pri- marily caused by the peeling of certain vertices, which leaves their neighboring structure disconnected and fragmented. This phenome- non affects the continuity and coherence of the subgraphs. As shown in Table 2, on the la dataset (the largest social network dataset tested in our experiments), DG, DW, and FD experience 24.67%, 46.84%, and 3.01% of rounds as ineffective long-tail iterations, severely limiting response time. Additionally, during the peeling process, if the batch size is large (e.g., \ud835\udf16 = 0.5), approximately 25.34%, 29.46%, and 7.16% of nodes become disconnected and sparse, signifi- cantly impacting the quality of the detected subgraphs. To address the challenges of high iteration counts in peeling algorithms, Dupin introduces two long-tail pruning techniques: Global Peeling Optimization (GPO) to maintain a global peeling threshold, and Local Peeling Optimization (LPO) to improve the density of the current peeling iteration\u2019s subgraph, thereby increasing the peeling threshold. We tested three algorithms, DG, DW, and FD, and found that they required 17,637, 150,223, and 112,074 iterations respectively, which is significantly high. By strategically pruning long-tail ver- tices and sparse vertices, the number of iterations can be reduced by up to 46.84%. Additionally, LPO can further reduce the number of iterations by up to 92.79%. These optimizations significantly enhance the efficiency of the peeling process, as discussed in this section. \n\n5.1 Global Peeling Optimization\n\nInitially, we define what constitutes a long-tail vertex during the peeling process. Peeling these long-tail vertices results in ineffective peeling iterations. To address this, we maintain a global maximum peeling threshold to determine which vertices can be peeled directly. When the global peeling threshold is greater than the current itera- tion\u2019s threshold, we use the global peeling threshold for peeling. Algorithm 3: DupinGPO: Global Peeling Optimization Input:\ud835\udc3a = (\ud835\udc49 , \ud835\udc38), a density metric \ud835\udc54(\ud835\udc46), and \ud835\udf16 \u2265 0 Output: A subset of vertices \ud835\udc46\ud835\udc5d that maximizes the density metric \ud835\udc54(\ud835\udc46) 1 \ud835\udc460 \u2190 \ud835\udc49 /* Initialize the subset with all vertices */ 2 \ud835\udc56 \u2190 1 3 \ud835\udf0fmax \u2190 \ud835\udc54(\ud835\udc46 0 ) \ud835\udc58(1+\ud835\udf16) /* Initialize the threshold */ 4 while \ud835\udc46\ud835\udc56\u22121 \u0338= \u2205 do 5 \ud835\udf0f \u2190 max{\ud835\udf0fmax, \ud835\udc58(1 + \ud835\udf16) \u00b7 \ud835\udc54(\ud835\udc46\ud835\udc56\u22121)} /* Peeling threshold */ 6 \ud835\udc48 \u2190 {\ud835\udc62 | \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56\u22121) \u2264 \ud835\udf0f } /* Vertices to be peeled */ 7 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56\u22121 \\\ud835\udc48 /* Update the subset */ 8 \ud835\udf0fmax = max{\ud835\udf0fmax, \ud835\udc54(\ud835\udc46\ud835\udc56 ) \ud835\udc58(1+\ud835\udf16) } /* Refine the threshold */ 9 \ud835\udc56 \u2190 \ud835\udc56 + 1 10 return arg max\ud835\udc46\ud835\udc56 \ud835\udc54(\ud835\udc46\ud835\udc56 ) /* The subset that maximizes \ud835\udc54(\ud835\udc46) */ Definition 5.1 (Long-Tail vertex). Given an \ud835\udefc-\ud835\udc4e\ud835\udc5d\ud835\udc5d\ud835\udc5f\ud835\udc5c\ud835\udc65\ud835\udc56\ud835\udc5a\ud835\udc4e\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b DSD algorithm and a set of vertices \ud835\udc46 \u2286 \ud835\udc49 , if\ud835\udc64\ud835\udc62 (\ud835\udc46) < \ud835\udc54(\ud835\udc46\u2217) \ud835\udefc and \ud835\udc46\u2217 is the optimal vertex set, then \ud835\udc62 is a long-tail vertex. Lemma 5.1. If \u2203\ud835\udc62 \u2208 \ud835\udc46\ud835\udc56 is a long-tail vertex, then \ud835\udc46\ud835\udc56 \u0338= \ud835\udc46\ud835\udc43 . Proof. We prove it in contradiction by assuming that \ud835\udc46\ud835\udc56 = \ud835\udc46\ud835\udc43 . Since \ud835\udc62 is a long-tail vertex in \ud835\udc46\ud835\udc56 ,\ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56 ) < \ud835\udc54(\ud835\udc46\u2217) \ud835\udefc < \ud835\udc54(\ud835\udc46\ud835\udc43 ). By peeling \ud835\udc62 from \ud835\udc46\ud835\udc43 , we have the following. \ud835\udc54(\ud835\udc46\ud835\udc43 \\ {\ud835\udc62}) = \ud835\udc53 (\ud835\udc46\ud835\udc43 ) \u2212\ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc43 ) |\ud835\udc46\ud835\udc43 |\u22121 > \ud835\udc53 (\ud835\udc46\ud835\udc43 ) \u2212 \ud835\udc54(\ud835\udc46\ud835\udc43 ) |\ud835\udc46\ud835\udc43 |\u22121 = \ud835\udc53 (\ud835\udc46\ud835\udc43 ) \u2212 \ud835\udc53 (\ud835\udc46\ud835\udc43 ) |\ud835\udc46\ud835\udc43 | |\ud835\udc46\ud835\udc43 |\u22121 = \ud835\udc54(\ud835\udc46\ud835\udc43 ) (14) A denser subgraph can be obtained by peeling \ud835\udc62 from \ud835\udc46\ud835\udc43 . This contradicts that \ud835\udc46\ud835\udc43 is the optimal solution. Hence, \ud835\udc46\ud835\udc56 \u0338= \ud835\udc46\ud835\udc43 . \u25a1 Identifying Long-Tail Vertices. Based on Lemma 5.2, we can also establish that a vertex\ud835\udc62 in set \ud835\udc46 can be classified as a long-tail vertex if \ud835\udc64\ud835\udc62 (\ud835\udc46) < \ud835\udc54(\ud835\udc46\u2217) \ud835\udc58(1+\ud835\udf16) . This insight allows us to implement a global peeling threshold, denoted as \ud835\udf0fmax. During each iteration, we compare \ud835\udc54(\ud835\udc46\ud835\udc56 ) \ud835\udc58(1+\ud835\udf16) with \ud835\udf0fmax. If the former exceeds the latter, Dupin updates \ud835\udf0fmax to \ud835\udc54(\ud835\udc46\ud835\udc56 ) \ud835\udc58(1+\ud835\udf16) , thereby enhancing the efficiency of the peeling. Peeling with Global Threshold (Algorithm 3). Using FD as an example, we can set \ud835\udc58 to 2. In Lemma 5.2, we recognize that long-tail vertices in set \ud835\udc46\ud835\udc56 can be peeled directly during iteration \ud835\udc56 for FD. To facilitate this, Dupin initiates with a global peeling threshold \ud835\udf0fmax (Line 3). After identifying a denser subgraph post-peeling, \ud835\udf0fmax is updated to \ud835\udc54(\ud835\udc46\ud835\udc56 ) 2(1+\ud835\udf16) , refining the peeling process (Line 8). Example 5.1. In the initial depiction provided in the leftmost panel of Figure 6 (the \ud835\udc56-th iteration), the density of the graph is 4.28. Traditionally, this scenario would necessitate two additional iterations to complete the peeling process, which could notably increase computational time. As illustrated, vertex \ud835\udc62 cannot be peeled in the (\ud835\udc56 + 1)-th iteration and would typically require an extra iteration, the (\ud835\udc56 + 2)-th, for its removal. However, Dupin can promptly peel vertices that fall below this threshold by employing our algorithm\u2019s global peeling threshold, which is calculated as half of the current density (\ud835\udf0fmax = 4.28/2 = 2.14). This approach enables the simultaneous peeling of three nodes in the (\ud835\udc56 + 1)-th iteration. Without this pruning strategy, an additional iteration would be essential to peel vertex \ud835\udc62, underscoring our method\u2019s enhanced efficiency in the peeling process. This optimization obviates the necessity for a prolonged iterative sequence. The example herein substantiates the efficacy of our tai- lored optimization for long-tail distribution, substantially enhancing the algorithm\u2019s time efficiency. \n\n5.2 Local Peeling Optimization\n\nAlgorithm 4: DupinLPO: Local Peeling Optimization Input: A graph\ud835\udc3a = (\ud835\udc49 , \ud835\udc38), a density metric \ud835\udc54(\ud835\udc46), and \ud835\udf16 \u2265 0 Output: A subset of vertices \ud835\udc46\ud835\udc5d representing the densest subgraph 1 \ud835\udc460 \u2190 \ud835\udc49 /* Initialize the subset with all vertices */ 2 \ud835\udf0fmax \u2190 \ud835\udc54(\ud835\udc46 0 ) \ud835\udc58(1+\ud835\udf16) /* Initialize the threshold */ 3 while \ud835\udc46\ud835\udc56\u22121 \u0338= \u2205 do 4 \ud835\udf0f1 \u2190 max{\ud835\udf0fmax, \ud835\udc58(1 + \ud835\udf16) \u00b7 \ud835\udc54(\ud835\udc46\ud835\udc56\u22121)} /* Peeling threshold */ 5 \ud835\udc481 \u2190 {\ud835\udc62 \u2208 \ud835\udc46 | \ud835\udc64\ud835\udc62 (\ud835\udc46) \u2264 \ud835\udf0f1 } 6 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56\u22121 \\\ud835\udc481 7 while \u2203\ud835\udc62 \u2208 \ud835\udc46\ud835\udc56 , \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56 ) < \ud835\udc54(\ud835\udc46\ud835\udc56 ) do 8 \ud835\udf0f2 \u2190 max{\ud835\udf0fmax, \ud835\udc54(\ud835\udc46\ud835\udc56 )} /* Update the threshold */ 9 \ud835\udc482 \u2190 {\ud835\udc62 | \ud835\udc64\ud835\udc62 (\ud835\udc46\ud835\udc56 ) < \ud835\udf0f2 } 10 \ud835\udc46\ud835\udc56 \u2190 \ud835\udc46\ud835\udc56 \\\ud835\udc482 11 \ud835\udf0fmax = max{\ud835\udf0fmax, \ud835\udc54(\ud835\udc46\ud835\udc56 ) \ud835\udc58(1+\ud835\udf16) } /* Update the threshold */ 12 return arg max\ud835\udc46\ud835\udc56 \ud835\udc54(\ud835\udc46\ud835\udc56 ) /* The subset that maximizes \ud835\udc54(\ud835\udc46) */ It is important to note that each peeling iteration often results in disparate structures. This is primarily caused by the peeling of cer- tain vertices, which leaves their neighboring structures disconnected and fragmented. This not only affects the density of the detected sub- graph but also lowers the peeling threshold. Lemma 5.2 establishes a foundational property of vertices within a dense graph. Lemma 5.2. \u2200\ud835\udc62 \u2208 \ud835\udc46 , if\ud835\udc64\ud835\udc62 (\ud835\udc46) < \ud835\udc54(\ud835\udc46), \ud835\udc54(\ud835\udc46 \\ {\ud835\udc62}) > \ud835\udc54(\ud835\udc46). Proof. By peeling \ud835\udc62 from \ud835\udc46 , we have the following. \ud835\udc54(\ud835\udc46 \\ {\ud835\udc62}) = \ud835\udc53 (\ud835\udc46) \u2212\ud835\udc64\ud835\udc62 (\ud835\udc46) |\ud835\udc46 |\u22121 > \ud835\udc53 (\ud835\udc46) \u2212 \ud835\udc54(\ud835\udc46\ud835\udc56 ) |\ud835\udc46 |\u22121 = \ud835\udc53 (\ud835\udc46) \u2212 \ud835\udc54(\ud835\udc46) |\ud835\udc46\u2217 |\u22121 = \ud835\udc53 (\ud835\udc46) \u2212 \ud835\udc53 (\ud835\udc46) |\ud835\udc46 | |\ud835\udc46 |\u22121 = \ud835\udc54(\ud835\udc46) (15) Therefore, a denser graph can be obtained by peeling \ud835\udc62 from \ud835\udc46 . \u25a1 According to Lemma 5.2, we introduce local peeling optimization within the iteration. After each peeling iteration, if the peeling weight of a vertex is smaller than the current density, Dupin will trim it. We implement a local peeling optimization (Lines 7-10, Algorithm 4) before the next iteration. After a vertex \ud835\udc62 is peeled, Dupin invokes updateNgh to update the peeling weights of \ud835\udc62\u2019s neighboring nodes. If any of these neighbors have a peeling weight less than the current density, they are also peeled, thereby increasing the density of the current iteration. Consequently, when an iteration yields globally optimal results, a denser structure is obtained. The benefits of this approach extend beyond density improvements; performance is also enhanced. By trimming these vertices, we reduce the number of vertices to traverse in subsequent iterations, and a higher density enables more efficient iterations due to the possibility of using larger peeling thresholds. Lemma 5.3. If \ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\ud835\udc5d is the first vertex in \ud835\udc46\u2217 removed by Dupin, \ud835\udc62\ud835\udc56 will not be removed during the local peeling optimization process. Proof. Assume, for the sake of contradiction, that \ud835\udc62\ud835\udc56 is trimmed during the local peeling optimization process. Let \ud835\udc46 \u2032 be the set of vertices left before \ud835\udc62\ud835\udc56 is trimmed. By definition, we have: \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) < \ud835\udc54(\ud835\udc46\u2217). Since \ud835\udc62\ud835\udc56 is the first vertex in \ud835\udc46\u2217 to be removed, \ud835\udc46\u2217 \u2286 \ud835\udc46 \u2032, therefore: \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2264 \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2032 ) < \ud835\udc54(\ud835\udc46\u2217). This contradicts Lemma 5.2, which states that \u2200\ud835\udc62\ud835\udc56 \u2208 \ud835\udc46\u2217: \ud835\udc64\ud835\udc62\ud835\udc56 (\ud835\udc46 \u2217 ) \u2265 \ud835\udc54(\ud835\udc46\u2217). Otherwise, a better solution can be obtained by removing \ud835\udc62 from \ud835\udc46\u2217, which contradicts the fact that \ud835\udc46\u2217 is the optimal solution. Thus, \ud835\udc62\ud835\udc56 cannot be trimmed. Hence,\ud835\udc62\ud835\udc56 will not be removed during the local peeling optimization process. \u25a1 Due to Lemma 5.3, \ud835\udc62\ud835\udc56 will only be removed during the peeling process. Hence, the approximation ratios (Theorem 4.2) for different density metrics are preserved. 6 EXPERIMENTAL STUDY Our experiments are run on a machine that has an X5650 CPU, 512 GB RAM. The implementation is made memory-resident and implemented in C++. All codes are compiled by GCC-9.3.0 with -\ud835\udc423. Datasets. We report the datasets used in our experiment in Table 3. One industrial dataset is from Anon (gfg). Datasets links-anon(la) and Twitter-rv (rv)were obtained from Stanford NetworkDataset Collection [31]. Datasets kron-logn21(kron), soc-twitter(soc), Web-uk-2005(uk) and Web-sk-2005(sk) were obtained from Network Data Repository [38]. Dataset bio was from the BIOMINE [35]. Baseline Methods.We evaluate five commonly used density metrics pivotal in network structure analysis: DG [6], DW [23], FD [24], TDS [46], and \ud835\udc58CLiDS [14]. These metrics are implemented within our framework, Dupin, and their performance is compared against several existing frameworks: Spade [28], kCLIST [14], GBBS [16], PBBS [41], PKMC [32], FWA [15], and ALENEX [44]. Specifically, kCLIST and PBBS are parallel algorithms for \ud835\udc58CLiDS. Since GBBS does not natively support weighted graphs, we precompute the peeling weights offline and import them into GBBS to enable support for DW and FD; the reported runtime excludes this preprocessing time. Additionally, FWA, ALENEX, and PKMC support the DGmetric, and we have extended their algorithms to support DW and FD by modifying their codebases accordingly. For TDS and \ud835\udc58CLiDS, we adapted the API of Spade for implementation. To standardize the compari- son, we denote the incremental peeling process\u2014which iteratively removes graph elements based on density scores\u2014as Spade-X, where X corresponds to each metric. This follows the experimental condi- tions in [28], with the batch size set to 1K as per their default setting; we report the average runtime per batch for Spade. Our parallel peeling algorithms, incorporating global and local peeling optimizations, are denoted as DupinGPO-X and DupinLPO-X, respectively. Default Settings. In our experiments, the parameter \ud835\udf16 is set to 0.1 by default, and the number of threads \ud835\udc61 is configured to 128. These settings are used consistently unless otherwise specified. 6.1 Efficiency of Dupin Spade vs Dupin. Our initial comparison focuses on the performance disparity between the incremental and parallel peeling algorithms. Specifically, Dupin-DG (resp. Dupin-DW, Dupin-FD, Dupin-TDS, and Dupin-\ud835\udc58CLiDS) demonstrates a speedup factor of 6.97 (resp. 7.71, 7.71, 7.65, and 8.46) over Spade-DG (resp. Spade-DW, SpadeFD, Spade-TDS, and Spade-\ud835\udc58CLiDS) as shown in Table 4 and Table 5. Notably, Spade-TDS and Spade-\ud835\udc58CLiDS only complete computations within 7,200 seconds on gfg. The bottleneck for Spade arises in larger graphs where initial calculations of the triangle and \ud835\udc58-Clique counting are unable to finish. Dupin outpaces Spade primarily because Spade suffers from the frequent reordering of peeling sequences when there are many increments, which proves to be slower than recalculating. GBBS vs Dupin. Among the parallel methods for DG, DW, and FD, FWA, ALENEX, and PKMC are several to dozens of times slower than GBBS. Therefore, we selectGBBS as a representative for comparison withDupin. The runtimes of the other three methods are provided in Table 4. On average, Dupin-DG, Dupin-DW, and Dupin-FD demon- strated speedup factors of 6.33, 12.51, and 17.07 times, respectively, over GBBS-DG, GBBS-DW, and GBBS-FD. This performance ad- vantage is attributed to the fundamental difference in the peeling process between the two frameworks. In GBBS, the basic unit of peeling is a bucket, where all nodes within the same bucket have an identical peeling weight. This design limits parallelism in weighted graphs, such as those using DW and FD, where many buckets may contain only a single node. In contrast, Dupin peels batches of nodes at each step and maintains a global peeling threshold to enhance the efficiency of each peeling iteration and eliminate long-tail iter- ations. This approach achieves higher parallelism and consistently outperforms GBBS, particularly in weighted graph scenarios where the speedup is even more pronounced. kCLIST vs PBBS vs Dupin. Both kCLIST and PBBS support the density metrics TDS and \ud835\udc58CLiDS. In our comparisons, Dupin demonstrates notable performance advantages. Specifically, Dupin-TDS is faster than kCLIST-TDS and PBBS-TDS by 39.85 and 62.71 times, respectively. Furthermore, Dupin-\ud835\udc58CLiDS also outperforms kCLIST\ud835\udc58CLiDS by 4.16 times. A significant finding is that PBBS-\ud835\udc58CLiDS fails to complete computations within 7200 seconds on most datasets, highlighting the efficiency of Dupin in handling more complex met- rics under stringent time constraints. Impact of DupinGPO. Next, we evaluate the acceleration effect of DupinGPO, using Dupin as a baseline for comparison. Notably, DupinGPO-DG is found to be 1.14 times faster, DupinGPO-DW is 1.11 times faster,DupinGPO-TDS is 1.10 times faster, andDupinGPO\ud835\udc58CLiDS is 1.35 times faster than their respective Dupin implementations. The acceleration is particularly significant for \ud835\udc58CLiDS on larger datasets, such as soc, rv, kron, and sk. DupinGPO-\ud835\udc58CLiDS is 1.40, 1.54, 1.51, and 1.61 times faster than Dupin-\ud835\udc58CLiDS on soc, rv, kron, and sk, respectively. This is attributed to the greater number of iterations required due to the larger dataset sizes and the higher count of \ud835\udc58-Cliques, necessitating more peeling iterations. In such scenarios,DupinGPO effectively prunes the tail iterations early, thereby reducing the number of rounds needed. Impact of DupinLPO. We next compared the efficiency of Dupin andDupinLPO. On average, thoughDupinLPO-DGwas 10.09% slower than Dupin-DG, the speed is still comparable. For example, on the soc dataset, DupinLPO-DG was 5.94% faster than Dupin-DG. This is because DupinLPO requires some lock operations to update the peeling weights of neighboring vertices during local peeling optimization. However, the advantage is that DupinLPO can detect up to 26.26% denser subgraphs, as detailed in Section 6.2. On larger datasets, such as soc, rv, and la, the vertices being trimmed have relatively low correlations with each other, so the impact of locks is minimal. For example, on the soc (resp. rv), DupinLPO-DG was 5.94% (resp. 9.94%) faster than Dupin-DG. In contrast, on smaller datasets, such as bio and kron, the extra cost of locks is higher. Impact of the Number of Threads \ud835\udc61 . All methods are influenced by the concurrency level, i.e., the number of threads. Generally, the greater the number of threads, the faster the execution speed. In our experiments, using the la dataset as a benchmark, we varied the number of threads \ud835\udc61 from 2 to 128 to observe the impact on runtime performance. For GBBS-DG, runtime stabilizes and accelerates by 3.33 times as thread count increases from 2 to 8. For GBBS-DW, performance deteriorates when the thread count exceeds 32, but from 2 to 32 threads, it accelerates by 3.50 times. Similarly, GBBS-FD shows no significant change in runtime beyond 32 threads, with an acceleration of 3.09 times from 2 to 32 threads. GBBS-TDS and GBBS-\ud835\udc58CLiDS fail to complete computations on the la dataset. In contrast, all five methods tested onDupin exhibit good scalability. As the number of threads increases from 2 to 128,Dupin-DG accelerates by 9.91 times, Dupin-DW by 12.69 times, Dupin-FD by 13.03 times, and Dupin-TDS by 28.06 times. Although Dupin-\ud835\udc58CLiDS fails to produce results when the thread count is below 16, it accelerates by 1.32 times from 32 to 128 threads. These results demonstrate Dupin\u2019s strong scalability across varied threading levels. 6.2 Effectiveness of Dupin In addition to assessing performance speedup, we evaluate the den- sity of the subgraphs detected by different frameworks. For parallel methods, we consider GBBS, PBBS, and kCLIST, because they gen- erally detect subgraphs with higher density than those detected by other methods across most datasets. For incremental methods, we use Spade as a representative. Detailed density comparisons are presented in Table 6 and Table 7. GBBS vs Spade vs Dupin. Firstly, we compare the densities of the subgraphs identified by GBBS-DG (respectively GBBS-DW, and GBBS-FD) to those detected by Dupin in parallel execution. Our experimental results indicate that Dupin maintains comparable subgraph densities with GBBS, signifying that the increase in com- putational efficiency does not compromise the accuracy of the de- tected subgraphs. Specifically, the density of the subgraph detected byGBBS-DG (respectivelyGBBS-DW, andGBBS-FD) is 7.08% (resp. 6.48% and 7.43%) greater than that detected by Dupin-DG (respectively Dupin-DW, and Dupin-FD) on average. Spade shares similar densities with GBBS. Due to Spade\u2019s tendency to accumulate er- rors over time, its density can become inflated. We will explain its limitations in practical applications in more detail in the case study. kCLIST vs PBBS vs Dupin. a) For \ud835\udc58CLiDS, PBBS-\ud835\udc58CLiDS could not complete on most of our test datasets, so we did not compare their densities. kCLIST-\ud835\udc58CLiDS could not complete on the sk dataset. On the other datasets, Dupin-\ud835\udc58CLiDS\u2019s density was only 6.97% smaller than kCLIST-\ud835\udc58CLiDS. On some datasets, such as bio and kron,Dupin\ud835\udc58CLiDS even detected subgraphs with greater density. b) For TDS, PBBS-TDS could detect subgraphs on smaller graphs but failed on billion-scale graphs such as rv, sk, and la. Dupin-TDS\u2019s density was 2.03% greater than kCLIST-TDS. Therefore, we conclude that Dupin is comparable to existing parallel methods in terms of the density of the detected dense subgraphs. Ablation Study of Dupin. This experiment delves into the effectiveness of our optimizations, DupinGPO and DupinLPO. Our analysis primarily focuses on comparing the densities of dense subgraphs detected by both DupinGPO and DupinLPO in various settings. DupinGPO achieves the same density as Dupin across five den- sity metrics because it trims the long tail, enhancing efficiency. For DupinLPO-DG (resp. DupinLPO-DW, DupinLPO-FD, DupinLPOTDS, and DupinGPO-\ud835\udc58CLiDS), we observe that the detected sub- graphs exhibit densities 11.09% (resp. 7.32%, 8.00%, 1.01%, and 26.26%) greater than those detected by Dupin-DG, Dupin-DW, Dupin-FD, Dupin-TDS, andDupin-\ud835\udc58CLiDS, respectively, demonstrating notable outcomes. This is because DupinLPO trims the graph in each iteration, resulting in denser subgraphs compared to Dupin. Impact of the Approximation Ratio \ud835\udf16. The approximation ratio \ud835\udf16 serves to control accuracy. In our experiment, we vary \ud835\udf16 from 0.1 to 1 to investigate its influence on the accuracy of Dupin. We observe that as \ud835\udf16 increases from 0.1 to 1, the density of subgraphs detected by Dupin, DupinGPO, and DupinLPO generally decreases. ForDG, the densities ofDupin-DG,DupinGPO-DG, andDupinLPODG decrease by 22.71%, 22.71%, and 11.99%, respectively. The trends for DW and DG are similar, with the worst performance observed at \ud835\udf16 = 0.6 for both density metrics. The trends for FD, TDS, and \ud835\udc58CLiDS are also similar. DupinLPO detects denser subgraphs across most density metrics and is less affected by \ud835\udf16 , due to its iterative trimming. For example, for FD, DupinLPO\u2019s density decreases by only 6.23%, while DupinGPO and Dupin\u2019s densities decrease by 17.37%. \n\n6.3 Case study\n\nWe also compare the performance in real-world scenarios, focusing on three key aspects: accuracy, latency, and prevention ratio. Accuracy. As discussed in Section 1, although Spade can quickly respond to new transactions, it tends to accumulate errors over time. Our analysis utilizes transaction data from Anon, with the transaction network comprising |\ud835\udc38 |= 2 billion edges. Under the incremental computation framework of Spade, the assumption is made that the weights of existing edges remain constant, thereby neglecting the impact of newly inserted edges on these weights, leading to error accumulation. For instance, using FD density metric, we observe that errors accumulate up to 24.4% within a day and increase to 30.3% over a week, as illustrated in Figure 9. Although Dupin sacrifices some accuracy to achieve parallel computational efficiency, our experiments show that Dupin\u2019s errors remain relatively stable between 3% and 5%. Hence, the detection precision of Spade declines from 87.9% to 68.3%, while Dupin\u2019s precision remains above 86%. Latency and Prevention Ratio. If a transaction is identified as fraudulent, subsequent related transactions are blocked to mitigate potential losses. We define the ratio of successfully prevented sus- picious transactions to the total number of suspicious transactions as R. As shown in Figure 8, the prevention ratio R continues to decrease as latency increases on Anon\u2019s datasets. Using the default density metric, FD, in Anon, our results show thatDupin-FD can prevent 94.5% of fraudulent activities, GBBS-FD can prevent 3.0%, and Spade-FD can prevent 45.3%. The reason for the lower performance of GBBS-FD is its low parallelism in the peeling process, which results in long peeling times and thus an average latency of 6,014 seconds, delaying the prevention of many fraudulent activities. Although Spade-FD performs well in reordering techniques on smaller datasets, in industrial scenarios with billion-scale graphs, latency significantly worsens due to the extensive reordering range required in the peeling sequences as normal users transition to fraudsters, increasing the cost of incremental computations. Additional tests were conducted with other density metrics; for DG, Dupin-DG can prevent 78.8%, while other methods prevent varying amounts. Similarly, for DW, Dupin-DW can prevent 86.1%, while other methods demonstrate different prevention capabilities. \n\n7 CONCLUSION AND FUTUREWORKS\n\nIn this paper, we presented Dupin, a novel parallel fraud detection framework tailored for massive graphs. Our experiments demonstrated that Dupin\u2019s advanced peeling algorithms and long-tail pruning techniques, DupinGPO and DupinLPO, significantly enhance the detection efficiency of dense subgraphs without sacrificing accuracy. Comparative studies with GBBS, PBBS, kCLIST, Spade, and Dupin highlighted Dupin\u2019s superior performance in terms of com- putational efficiency and accuracy. Through case studies, we also validated that Dupin achieves lower latency and higher detection ac- curacy compared to existing fraud detection systems on billion-scale graphs. Overall, Dupinproves to be a powerful tool for large-scale fraud detection, providing a scalable and efficient solution for real-time applications. Future work will explore the integration of additional suspiciousness functions and further optimization to handle even larger datasets and more complex fraud scenarios. \n\nREFERENCES\n\n[1] Distil networks: The 2019 bad bot report. https://www.bluecubesecurity.com/wp- content/uploads/bad-bot-report-2019LR.pdf. [2] B. Bahmani, R. Kumar, and S. Vassilvitskii. Densest subgraph in streaming and mapreduce. Proceedings of the VLDB Endowment, 5(5), 2012. [3] Y. Ban, X. Liu, T. Zhang, L. Huang, Y. Duan, X. Liu, and W. Xu. Badlink: Combining graph and information-theoretical features for online fraud group detection. arXiv preprint arXiv:1805.10053, 2018. [4] A. Beutel, W. Xu, V. Guruswami, C. Palow, and C. Faloutsos. Copycatch: stopping group attacks by spotting lockstep behavior in social networks. In Proceedings of the 22nd international conference on World Wide Web, pages 119\u2013130, 2013. [5] D. Boob, Y. Gao, R. Peng, S. Sawlani, C. Tsourakakis, D.Wang, and J.Wang. Flowless: Extracting densest subgraphs without flow computations. In Proceedings of The Web Conference 2020, pages 573\u2013583, 2020. [6] M. Charikar. Greedy approximation algorithms for finding dense components in a graph. In International Workshop on Approximation Algorithms for Combinatorial Optimization, pages 84\u201395. Springer, 2000. [7] M. Charikar. Greedy approximation algorithms for finding dense components in a graph. In Approximation Algorithms for Combinatorial Optimization, Third International Workshop, APPROX 2000, Saarbr\u00fccken, Germany, September 5-8, 2000, Proceedings, volume 1913 of Lecture Notes in Computer Science, pages 84\u201395. Springer, 2000. [8] C. Chekuri, K. Quanrud, and M. R. Torres. Densest subgraph: Supermodularity, iterative peeling, and flow. In Proceedings of the 2022 Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 1531\u20131555. SIAM, 2022. [9] J. Chen and Y. Saad. Dense subgraph extraction with application to community detection. IEEE Transactions on knowledge and data engineering, 24(7):1216\u20131230, 2010. [10] Y. Chen, J. Jiang, S. Sun, B. He, and M. Chen. Rush: Real-time burst subgraph detection in dynamic graphs. Proceedings of the VLDB Endowment, 17(11):3657\u2013 3665, 2024. [11] N. Chiba and T. Nishizeki. Arboricity and subgraph listing algorithms. SIAM Journal on computing, 14(1):210\u2013223, 1985. [12] L. Chu, Y. Zhang, Y. Yang, L. Wang, and J. Pei. Online density bursting subgraph detection from temporal graphs. Proceedings of the VLDB Endowment, 12(13):2353\u2013 2365, 2019. [13] L. Dagum and R. Menon. Openmp: an industry standard api for shared-memory programming. IEEE computational science and engineering, 5(1):46\u201355, 1998. [14] M. Danisch, O. Balalau, and M. Sozio. Listing k-cliques in sparse real-world graphs. In Proceedings of the 2018 World Wide Web Conference, pages 589\u2013598, 2018. [15] M. Danisch, T.-H. H. Chan, and M. Sozio. Large scale density-friendly graph decomposition via convex programming. In Proceedings of the 26th International Conference on World Wide Web, pages 233\u2013242, 2017. [16] L. Dhulipala, J. Shi, T. Tseng, G. E. Blelloch, and J. Shun. The graph based benchmark suite (gbbs). In Proceedings of the 3rd Joint International Workshop on Graph Data Management Experiences & Systems (GRADES) and Network Data Analytics (NDA), pages 1\u20138, 2020. [17] Y. Dourisboure, F. Geraci, and M. Pellegrini. Extraction and classification of dense communities in the web. In Proceedings of the 16th international conference on World Wide Web, pages 461\u2013470, 2007. [18] A. Epasto, S. Lattanzi, and M. Sozio. Efficient densest subgraph computation in evolving graphs. In Proceedings of the 24th international conference on world wide web, pages 300\u2013310, 2015. [19] D. Gibson, R. Kumar, and A. Tomkins. Discovering large dense subgraphs in massive graphs. In Proceedings of the 31st international conference on Very large data bases, pages 721\u2013732. Citeseer, 2005. [20] A. Gionis and C. E. Tsourakakis. Dense subgraph discovery: Kdd 2015 tutorial. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 2313\u20132314, 2015. [21] A. V. Goldberg. Finding a maximum density subgraph. 1984. [22] A. V. Goldberg and R. E. Tarjan. A new approach to the maximum-flow problem. Journal of the ACM (JACM), pages 921\u2013940, 1988. [23] N. V. Gudapati, E. Malaguti, and M. Monaci. In search of dense subgraphs: How good is greedy peeling? Networks, 77(4):572\u2013586, 2021. [24] B. Hooi, H. A. Song, A. Beutel, N. Shah, K. Shin, and C. Faloutsos. Fraudar: Bounding graph fraud in the face of camouflage. In Proceedings of the 22nd ACM SIGKDD international conference on knowledge discovery and data mining, pages 895\u2013904, 2016. [25] M. Jaggi. Revisiting frank-wolfe: Projection-free sparse convex optimization. In International conference on machine learning, pages 427\u2013435. PMLR, 2013. [26] J. Jiang, Y. Chen, B. He, M. Chen, and J. Chen. Spade+: A generic real-time fraud detection framework on dynamic graphs. IEEE Transactions on Knowledge and Data Engineering, 2024. [27] M. Jiang, P. Cui, A. Beutel, C. Faloutsos, and S. Yang. Inferring strange behavior from connectivity pattern in social networks. In Pacific-Asia conference on knowledge discovery and data mining, pages 126\u2013138. Springer, 2014. [28] J. Jiaxin, L. Yuan, H. Bingsheng, H. Bryan, C. Jia, and J. K. Z. Kang. A real-time fraud detection framework on evolving graphs. PVLDB, 2023. [29] S. Kumar, W. L. Hamilton, J. Leskovec, and D. Jurafsky. Community interaction and conflict on the web. In Proceedings of the 2018 world wide web conference, pages 933\u2013943, 2018. [30] V. E. Lee, N. Ruan, R. Jin, and C. Aggarwal. A survey of algorithms for dense subgraph discovery. In Managing and mining graph data, pages 303\u2013336. Springer, 2010. [31] J. Leskovec and A. Krevl. SNAP Datasets: Stanford large network dataset collection. http://snap.stanford.edu/data, June 2014. [32] W. Luo, Z. Tang, Y. Fang, C. Ma, and X. Zhou. Scalable algorithms for densest subgraph discovery. In 2023 IEEE 39th International Conference on Data Engineering (ICDE), pages 287\u2013300. IEEE, 2023. [33] C. Ma, Y. Fang, R. Cheng, L. V. Lakshmanan, and X. Han. A convex-programming approach for efficient directed densest subgraph discovery. In Proceedings of the 2022 International Conference on Management of Data, pages 845\u2013859, 2022. [34] M. Mitzenmacher, J. Pachocki, R. Peng, C. Tsourakakis, and S. C. Xu. Scalable large near-clique detection in large-scale networks via sampling. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 815\u2013824, 2015. [35] V. Podpe\u010dan, \u017d. Ram\u0161ak, K. Gruden, H. Toivonen, and N. Lavra\u010d. Interactive explo- ration of heterogeneous biological networks with biomine explorer. Bioinformatics, 06 2019. [36] H. Qin, R.-H. Li, Y. Yuan, G. Wang, L. Qin, and Z. Zhang. Mining bursting core in large temporal graphs. Proceedings of the VLDB Endowment, 2022. [37] Y. Ren, H. Zhu, J. Zhang, P. Dai, and L. Bo. Ensemfdet: An ensemble approach to fraud detection based on bipartite graph. In 2021 IEEE 37th International Conference on Data Engineering (ICDE), pages 2039\u20132044. IEEE, 2021. [38] R. A. Rossi and N. K. Ahmed. The network data repository with interactive graph analytics and visualization. In AAAI, 2015. [39] A. E. Sar\u0131y\u00fcce andA. Pinar. Peeling bipartite networks for dense subgraph discovery. In Proceedings of the Eleventh ACM International Conference on Web Search and Data Mining, pages 504\u2013512, 2018. [40] S. B. Seidman. Network structure and minimum degree. Social networks, 5(3):269\u2013 287, 1983. [41] J. Shi, L. Dhulipala, and J. Shun. Parallel clique counting and peeling algorithms. In SIAM Conference on Applied and Computational Discrete Algorithms (ACDA21), pages 135\u2013146. SIAM, 2021. [42] K. Shin, T. Eliassi-Rad, and C. Faloutsos. Corescope: Graph mining using k-core analysis\u2014patterns, anomalies and algorithms. In 2016 IEEE 16th international conference on data mining (ICDM), pages 469\u2013478. IEEE, 2016. [43] K. Shin, B. Hooi, J. Kim, and C. Faloutsos. Densealert: Incremental dense-subtensor detection in tensor streams. In Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 1057\u20131066, 2017. [44] P. Sukprasert, Q. C. Liu, L. Dhulipala, and J. Shun. Practical parallel algorithms for near-optimal densest subgraphs on massive graphs. In 2024 Proceedings of the Symposium on Algorithm Engineering and Experiments (ALENEX), pages 59\u201373. SIAM, 2024. [45] B. Sun, M. Danisch, T. H. Chan, and M. Sozio. Kclist++: A simple algorithm for finding k-clique densest subgraphs in large graphs. Proceedings of the VLDB Endowment (PVLDB), 2020. [46] C. Tsourakakis. The k-clique densest subgraph problem. In Proceedings of the 24th international conference on world wide web, pages 1122\u20131132, 2015. [47] C. Ye, Y. Li, B. He, Z. Li, and J. Sun. Gpu-accelerated graph label propagation for real-time fraud detection. In Proceedings of the 2021 International Conference on Management of Data, pages 2348\u20132356, 2021."
}